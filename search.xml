<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Guava cache 介绍和简单使用</title>
    <url>/2021/04/26/Guava-cache-%E4%BB%8B%E7%BB%8D%E5%92%8C%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<blockquote>
<p>近期做了一个项目迁移工作，用到了 Guava cache 实现缓存功能</p>
</blockquote>
<p>Guava cache 是 Google Guava 下的一个缓存模块<br>
缓存分为本地缓存和远端缓存。Guava cache 则属于本地缓存，数据存储在 JVM 内存中</p>
<h4 id="数据操作">数据操作</h4>
<p>一般在业务中操作数据时，都会操作缓存和数据源 (DB) 两部分</p>
<ul>
<li>put 操作，先插入数据，再删除缓存；</li>
<li>get 操作，先查缓存，命中则返回，没有命中则查库，然后把结果放入缓存</li>
</ul>
<h4 id="Guava-cache-的优势">Guava cache 的优势</h4>
<ul>
<li>封装 get / put 操作，能集成数据源；</li>
<li>实现了线程安全 （具体实现：与 CocurrentHashMap 类似，但是添加更多元素失效策略）；</li>
<li>Guava Cache提供了三种基本的缓存回收方式：基于容量回收、定时回收和基于引用回收。定时回收有两种：按照写入时间，最早写入的最先回收；按照访问时间，最早访问的最早回收；</li>
<li>监控缓存的 加载 / 命中 情况</li>
</ul>
<h4 id="和-Redis-相比">和 Redis 相比</h4>
<ul>
<li>因为应用和缓存在同一个进程内，请求缓存速度更加迅速</li>
<li>单线程下 Guava cache 优于 Redis；并发下 Redis 读取时间下降较明显，Guava cache 影响不大<br>
过期清理机制<br>
项目达到过期时间后不会马上清除，会在写操作和读操作时顺带清理</li>
</ul>
<h4 id="Java-实例">Java 实例</h4>
<ol>
<li>在 pom.xml 中添加以下内容，引入 jar 包</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.guava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>guava<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>19.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>在代码中根据需求创建缓存对象</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 缓存</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> LoadingCache&lt;String, Map&lt;String, String&gt; cache = CacheBuilder</span><br><span class="line">        .newBuilder()</span><br><span class="line">        .refreshAfterWrite(EXPIRE_TIME_MINUTES, TimeUnit.MINUTES)</span><br><span class="line">        .build(<span class="keyword">new</span> CacheLoader&lt;String, Map&lt;String, String&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Map&lt;String, String&gt; <span class="title">load</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> getFromDb();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>获取缓存的方法</li>
</ol>
<h2 id="code￼2"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">cache.getUnchecked(<span class="string">&quot;&quot;</span>);</span><br></pre></td></tr></table></figure></h2>
<h4 id="加载机制">加载机制</h4>
<h5 id="CacheLoader">CacheLoader</h5>
<p>从 LoadingCache 查询缓存的正规方法是 get(key) 方法，要么返回已经缓存的值，要么使用 CacheLoader 向缓存<strong>原子地</strong>添加新值</p>
<h5 id="Callable">Callable</h5>
<p>如果没有合理的默认方法来加载或计算与键关联的值，或者想要覆盖默认的加载运算，同时保留“获取缓存-如果没有-则计算”[get-if-absent-compute]的原子语义。<br>
所有类型的Guava Cache，不管有没有自动加载功能，都支持get(K, Callable<V>)方法。这个方法实现的是，如果有缓存，返回相应的值；如果缓存不存在，用给定的 Callable 运算把结果加入到缓存</p>
<h5 id="Cache-put">Cache.put</h5>
<p>cache.put(key, value) 可以直接向缓存中插入值，会覆盖掉 key 之前映射的 value</p>
<h3 id="参考">参考</h3>
<p><a href="https://www.cnblogs.com/rickiyang/p/11074159.html">Guava cache 使用总结</a><br>
<a href="https://blog.wangqi.love/articles/Java/Guava%20Cache%E4%B8%8ERedis%E7%9A%84%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94.html">Guava cache 和 Redis 性能对比</a><br>
<a href="https://www.jianshu.com/p/38bd5f1cf2f2">Google Guava Cache 全解析</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Guava</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo 常用</title>
    <url>/2021/04/24/Hexo-%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<p>收录编辑、发布博客时常用到的 Hexo 指令等</p>
<span id="more"></span>
<h3 id="新建文章">新建文章</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new &quot;title&quot; </span><br></pre></td></tr></table></figure>
<blockquote>
<p>path -&gt; /source/_posts/</p>
</blockquote>
<h3 id="本地测试">本地测试</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>
<h3 id="部署">部署</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure>
<h3 id="图标">图标</h3>
<p>原生支持图标库 Font Awesome<br>
<a href="https://fontawesome.com/icons?d=gallery&amp;p=2">https://fontawesome.com/icons?d=gallery&amp;p=2</a></p>
<h3 id="参考">参考</h3>
<p><a href="https://winney07.github.io/2018/08/02/%E5%9C%A8Hexo%E5%8D%9A%E5%AE%A2%E4%B8%AD%E5%8F%91%E5%B8%83%E6%96%87%E7%AB%A0/">在Hexo博客中发布文章</a></p>
]]></content>
      <categories>
        <category>效率</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Java Excel 相关操作</title>
    <url>/2021/05/10/Java-Excel/</url>
    <content><![CDATA[<p>Excel 文件导入导出的相关操作</p>
<h3 id="引入-poi-相关依赖">引入 poi 相关依赖</h3>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.poi<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>poi<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.poi<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>poi-ooxml<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="解析-Excel">解析 Excel</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.poi.xssf.usermodel.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@CrossOrigin</span></span><br><span class="line"><span class="meta">@RequestMapping(value = &#123;&quot;/parseExcel&quot;&#125;, method = RequestMethod.POST, produces = &#123;&quot;application/json;charset=UTF-8&quot;&#125;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Result&lt;Boolean&gt; <span class="title">parseExcel</span><span class="params">(<span class="meta">@RequestParam(&quot;file&quot;)</span> MultipartFile file)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// @RequestParam(&quot;file&quot;)MultipartFile file 用来接受前端传过来的 Excel 文件</span></span><br><span class="line">        <span class="comment">// 创建 Workbook 对象，读取整个文档</span></span><br><span class="line">        InputStream inputStream = file.getInputStream();</span><br><span class="line">        XSSFWorkbook xssfWorkbook = <span class="keyword">new</span> XSSFWorkbook(inputStream);</span><br><span class="line">        <span class="comment">// 读取页脚 sheet</span></span><br><span class="line">        XSSFSheet xssfSheet = xssfWorkbook.getSheetAt(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 循环取每行的数据</span></span><br><span class="line">        <span class="comment">// rowIndex 为 1 是为了跳过标题行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> rowIndex = <span class="number">1</span>; rowIndex &lt; xssfSheet.getPhysicalNumberOfRows(); rowIndex++) &#123;</span><br><span class="line">            XSSFRow xssfRow = xssfSheet.getRow(rowIndex);</span><br><span class="line">            <span class="keyword">if</span> (xssfRow == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 获取单元格数据</span></span><br><span class="line">            Long id = ExcelUtils.getLong(xssfRow.getCell(<span class="number">0</span>));</span><br><span class="line">            String str = ExcelUtils.getString(xssfRow.getCell(<span class="number">1</span>)));</span><br><span class="line">            Integer num = ExcelUtils.getInteger(xssfRow.getCell(<span class="number">2</span>));</span><br><span class="line">            Boolean isFalse = ExcelUtils.getBoolean(xssfRow.getCell(<span class="number">3</span>));</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="导出-Excel">导出 Excel</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.poi.xssf.usermodel.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ApiOperation(value = &quot;exportExcel&quot;)</span></span><br><span class="line"><span class="meta">@RequestMapping(value = &#123;&quot;/exportExcel&quot;&#125;, method = RequestMethod.GET)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Result&lt;Boolean&gt; <span class="title">exportExcel</span><span class="params">(HttpServletResponse response)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 设置要导出的文件的名字</span></span><br><span class="line">    String fileName = <span class="string">&quot;data&quot;</span>  + <span class="keyword">new</span> Date() + <span class="string">&quot;.xlsx&quot;</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        XSSFWorkbook workbook = <span class="keyword">new</span> XSSFWorkbook();</span><br><span class="line">        XSSFSheet sheet = workbook.createSheet(<span class="string">&quot;信息表&quot;</span>);</span><br><span class="line">        <span class="comment">// headers表示excel表中第一行的表头 在excel表中添加表头</span></span><br><span class="line">        String[] headers = &#123; <span class="string">&quot;id&quot;</span>, <span class="string">&quot;名称&quot;</span>, <span class="string">&quot;类型&quot;</span>&#125;;</span><br><span class="line">        XSSFRow head = sheet.createRow(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; headers.length; i++)&#123;</span><br><span class="line">            XSSFCell cell = head.createCell(i);</span><br><span class="line">            XSSFRichTextString text = <span class="keyword">new</span> XSSFRichTextString(headers[i]);</span><br><span class="line">            cell.setCellValue(text);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 新增数据行，并且设置单元格数据</span></span><br><span class="line">        XSSFRow row =sheet.createRow(<span class="number">1</span>);</span><br><span class="line">        row.createCell(<span class="number">0</span>).setCellValue(id);</span><br><span class="line">        row.createCell(<span class="number">1</span>).setCellValue(name);</span><br><span class="line">        row.createCell(<span class="number">2</span>).setCellValue(type);</span><br><span class="line">        response.setContentType(<span class="string">&quot;application/octet-stream&quot;</span>);</span><br><span class="line">        response.setHeader(<span class="string">&quot;Content-disposition&quot;</span>, <span class="string">&quot;attachment;filename=&quot;</span> + fileName);</span><br><span class="line">        response.flushBuffer();</span><br><span class="line">        workbook.write(response.getOutputStream());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="单元格数据类型转换">单元格数据类型转换</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.poi.xssf.usermodel.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把单元格值转为 String</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getString</span><span class="params">(XSSFCell xssfCell)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (xssfCell == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (xssfCell.getCellTypeEnum() == CellType.NUMERIC) &#123;</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(xssfCell.getNumericCellValue());</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (xssfCell.getCellTypeEnum() == CellType.BOOLEAN) &#123;</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(xssfCell.getBooleanCellValue());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> xssfCell.getStringCellValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 切割是为了去除小数点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Long <span class="title">getLong</span><span class="params">(XSSFCell xssfCell)</span> </span>&#123;</span><br><span class="line">    String s = getString(xssfCell);</span><br><span class="line">    <span class="keyword">return</span> Long.valueOf(s.substring(<span class="number">0</span>, s.length() - <span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">getInteger</span><span class="params">(XSSFCell xssfCell)</span> </span>&#123;</span><br><span class="line">    String s = getString(xssfCell);</span><br><span class="line">    <span class="keyword">return</span> Integer.valueOf(s.substring(<span class="number">0</span>, s.length() - <span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title">getBoolean</span><span class="params">(XSSFCell xssfCell)</span> </span>&#123;</span><br><span class="line">    String s = getString(xssfCell);</span><br><span class="line">    <span class="keyword">return</span> Boolean.valueOf(s.substring(<span class="number">0</span>, s.length() - <span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java常用日志框架</title>
    <url>/2021/12/12/Java%E5%B8%B8%E7%94%A8%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<p>2021年12月10日，Log4j2 被爆出存在<a href="https://nosec.org/home/detail/4917.html">严重安全漏洞</a>，攻击者可以通过 JNDI 注入的方式远程在目标机器上执行任意代码来发动攻击，一种场景就是，如果有一个接口会将入参用log4j2打印出来，攻击者就可以传入形如<code>$&#123;jndi:rmi//xxxxxx&#125;</code>的命令，在目标机器上执行远程代码。</p>
<p>在排查最近在开发的一个 Java 项目是否存在该漏洞时，发现这个项目打印的日志并不会触发漏洞，但是项目中又确实存在 log4j2 的依赖。仔细看了一下项目的日志方法，原来这个项目使用的日志框架是 logback 而非 log4j2。这也刚好勾起了我的疑问，平时在使用日志时知道有 slf4j，log4j 这类字眼，logback 很少有见到，对于日志这一块，也是只需要能打印出来供线上问题排查即可。那么 Java 中的各种日志框架各自的区别又是什么呢？</p>
<h3 id="Slf4j">Slf4j</h3>
<p>很长一段时间，我都以为 slf4j 是和 log4j 一样的一种日志框架，但其实它的全称（Simple Logging Facade for Java）告诉我们，这是专门针对 Java 提供的一种简单日志门面。它本身不提供日志服务，而是统一了接口，供其他日志框架来接入。优点就是，如果后续项目升级时需要更换日志框架，省去了对代码的改动，只需要更换日志框架的 jar 包即可。</p>
<h3 id="Log4j">Log4j</h3>
<p>Log4j 一款比较早的日志框架，log4j2 是在此基础上的升级版，有更强大的性能。两者在获取 Logger 的路径上有差异，配置方式也有区别。如果要使用 slf4j + log4j 的方式输出日志，需要引入额外的桥接 jar 包。</p>
<h3 id="Logback">Logback</h3>
<p>Logback 是 Log4j 的升级版，由 Slf4j 的作者开发，使用 xml 进行配置。该框架默认实现了 Slf4j 标准，所使用的 Logger 和 LoggerFactory 都是 Slf4j 的实现，使用 slf4j + logback 的组合不需要引入额外的 jar 包。</p>
<h3 id="参考">参考</h3>
<p><a href="https://nosec.org/home/detail/4917.html">【安全通报】Apache Log4j2 远程代码执行漏洞</a><br>
<a href="https://juejin.cn/post/7033021644142542878">log4j、log4j2、slf4j、logback什么关系？到底该使用哪些jar??</a><br>
<a href="https://www.codenong.com/cs105272888/">Slf4j与log4j及log4j2的关系及使用方法</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java I/O</title>
    <url>/2021/04/24/Java%20I:O/</url>
    <content><![CDATA[<h3 id="Java-I-O分类">Java I/O分类</h3>
<hr>
<ul>
<li>磁盘操作：File</li>
<li>字节操作：InputStream 和 OutputStream</li>
<li>字符操作：Reader 和 Writer</li>
<li>对象操作：Serializable</li>
<li>网络操作：Socket</li>
<li>新的输入/输出：NIO</li>
</ul>
<p>File可用于表示文件和目录的信息，但不表示文件内容</p>
<span id="more"></span>
<h3 id="装饰者模式">装饰者模式</h3>
<hr>
<p>Java I/O 使用了装饰者模式来实现。以 InputStream 为例，</p>
<ul>
<li>InputStream 是抽象组件；</li>
<li>FileInputStream 是 InputStream 的子类，属于具体组件，提供了字节流的输入操作；</li>
<li>FilterInputStream 属于抽象装饰者，装饰者用于装饰组件，为组件提供额外的功能。例如 BufferedInputStream 为 FileInputStream 提供缓存的功能。</li>
</ul>
<p>装饰者用于装饰组件，为组件提供额外的功能</p>
<p>实例化一个具有缓存功能的字节流对象时，只需要在 FileInputStream 对象上再套一层 BufferedInputStream 对象即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FileInputStream fileInputStream = <span class="keyword">new</span> FileInputStream(filePath);</span><br><span class="line">BufferedInputStream bufferedInputStream = <span class="keyword">new</span> BufferedInputStream(fileInputStream);</span><br></pre></td></tr></table></figure>
<h3 id="字符的编码与解码">字符的编码与解码</h3>
<hr>
<p>编码就是把字符转换为字节，解码就是把字节转换成字符</p>
<ul>
<li>GBK 编码中，中文字符占 2 个字节，英文字符占 1 个字节；</li>
<li>UTF-8 编码中，中文字符占 3 个字节，英文字符占 1 个字节；</li>
<li>UTF-16be 编码中，中文字符和英文字符都占 2 个字节。</li>
</ul>
<p>Java 的内存编码使用双字节编码 UTF-16be，这不是指 Java 只支持这一种编码方式，而是说 char 这种类型使用 UTF-16be 进行编码。char 类型占 16 位，也就是两个字节，Java 使用这种双字节编码是为了让一个中文或者一个英文都能使用一个 char 来存储。</p>
<h3 id="Reader与Writer">Reader与Writer</h3>
<hr>
<p>不管是磁盘还是网络传输，最小的存储单元都是字节，而不是字符。但是在程序中操作的通常是字符形式的数据，因此需要提供对字符进行操作的方法。</p>
<ul>
<li>InputStreamReader 实现从字节流解码成字符流；</li>
<li>OutputStreamWriter 实现字符流编码成为字节流。</li>
</ul>
<h3 id="序列化">序列化</h3>
<hr>
<p>序列化就是将一个对象转换成字节序列，方便存储和传输。</p>
<ul>
<li>序列化：ObjectOutputStream.writeObject()</li>
<li>反序列化：ObjectInputStream.readObject()</li>
</ul>
<p>不会对静态变量进行序列化，因为序列化只是保存对象的状态，静态变量属于类的状态。</p>
<h4 id="Serializable">Serializable</h4>
<p>序列化的类需要实现 Serializable 接口，它只是一个标准，没有任何方法需要实现，但是如果不去实现它的话而进行序列化，会抛出异常。</p>
<h4 id="transient">transient</h4>
<p>transient 关键字可以使一些属性不会被序列化。</p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java常用容器及其方法</title>
    <url>/2021/04/24/Java%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8%E5%8F%8A%E5%85%B6%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h3 id="HashSet">HashSet</h3>
<p>HashSet<T>  hash = new HashSet&lt;&gt;();</p>
<ul>
<li>add() 添加元素,返回boolean类型。如果不存在该元素，则添加指定元素并返回true。否则不更改set并返回false</li>
<li>clear() 移除set所有元素</li>
<li>remove(Object o) 如果指定元素存在于set中，移除指定元素</li>
<li>isEmpty() 如果set不包含任何元素，返回true</li>
<li>contains(Object o) 如果set包含指定元素，返回true</li>
<li>size() 返回set中元素数量</li>
</ul>
<span id="more"></span>
<h3 id="HashMap">HashMap</h3>
<p>HashMap&lt;T, T&gt; hashMap = new HashMap&lt;&gt;();</p>
<ul>
<li>put(key, value) 添加键值对，如果key已经存在，就返回旧value，并更新成新value。如果不存在，就返回null</li>
<li>putIfAbsent(key, value); 不会覆盖原有的value</li>
<li>remove(key) 删除元素。删除成功返回对应的value，否则返回null</li>
<li>get(key) 获取key对应的value</li>
<li>containsKey(key) 判断key是否存在</li>
<li>containsValue(value) 判断value是否存在</li>
<li>replace(key, value) 对于已经存在的key，替换其value</li>
</ul>
<h4 id="HashMap-遍历方法">HashMap 遍历方法</h4>
<p>一、for-each循环中使用entries遍历</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Integer, Integer&gt; hash = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(Map.Entry&lt;Integer, Integer&gt; entry : hash.entrySet()) &#123;</span><br><span class="line">    entry.getKey() + entry.getValue()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>二、在for-each中遍历key或者value集合</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Integer, Integer&gt; hash = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(Integer key : hash.keySet()) &#123;</span><br><span class="line">  key;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(Integer value : hash.values()) &#123;</span><br><span class="line">  value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>三、通过键找值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Integer, Integer&gt; hash = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(Integer key : hash.keySet()) &#123;</span><br><span class="line">  value = hash.get(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方法效率低，因为通过键来取值很耗时</p>
<hr>
<h3 id="LinkedList">LinkedList</h3>
<p>LinkedList<T> list = new LinkedList&lt;&gt;();</p>
<h5 id="基本操作">基本操作</h5>
<p><strong>add</strong></p>
<ul>
<li>add() 在链表后添加元素</li>
<li>addFirst() 在链表头部插入一个元素</li>
<li>addLast() 在链表尾部添加一个元素</li>
<li>add(index, element) 在指定位置插入一个元素</li>
</ul>
<p><strong>remove</strong></p>
<ul>
<li>remove() 移除链表第一个元素</li>
<li>remove(Obejct o) 移除链表中指定元素</li>
<li>remove(index) 移除链表中指定位置元素</li>
<li>removeFirst() 移除链表中第一个元素，与remove类似</li>
<li>removeLast() 移除链表中最后一个元素</li>
</ul>
<p><strong>get</strong></p>
<ul>
<li>getFirst() 获取第一个元素</li>
<li>getLast() 获取最后一个元素</li>
</ul>
<h5 id="栈操作">栈操作</h5>
<ul>
<li>push() 与addFirst一样</li>
<li>pop() 与removeFirst一样</li>
<li>poll() 查询并移除第一个元素</li>
<li>peek() 获取第一个元素，但是不移除</li>
</ul>
<h5 id="队列操作">队列操作</h5>
<p>Queue&lt;&gt; queue = new LinkedList&lt;&gt;();</p>
<ul>
<li>offer() 在队列尾部插入元素</li>
<li>add() 让元素入队</li>
<li>poll() 首部元素出队列</li>
</ul>
<p><strong>其他</strong></p>
<ul>
<li>contains(e) 是否包含某元素</li>
</ul>
<h5 id="双端队列-可实现单调队列">双端队列 - 可实现单调队列</h5>
<p>Deque&lt;&gt; deque = new LinkedList&lt;&gt;();</p>
<p>peekLast() 获取队列尾端值</p>
<p>peekFirst() 获取队列尾部值</p>
<p>removeFirst() 移除队列头部第一个值</p>
<p>removeLast() 移除队列尾部第一个值</p>
<hr>
<h3 id="ArrayList">ArrayList</h3>
<ul>
<li>add() 顺序添加元素</li>
<li>get(i) 获取第i个元素</li>
<li>Arrays.sort() 列表排序</li>
<li>remove(index) 删除对应索引的元素</li>
</ul>
<hr>
<h3 id="Stack">Stack</h3>
<p>是Vector的子类</p>
<p>push()</p>
<p>pop()</p>
<p>peek()</p>
<hr>
<h3 id="StringBuilder">StringBuilder</h3>
<p>append() 向尾部添加字符串</p>
<p>deleteCharAt(i) 定点删除字符</p>
<h3 id="String">String</h3>
<p>//把字符串去头尾后以“，”为分隔符分割成字符串数组</p>
<p>String[] list = data.substring(1, data.length() - 1).split(“,”);</p>
<hr>
<h3 id="System">System</h3>
<p>arraycopy(Object src, int srcPos, Object dest, int destPos, int length)</p>
<p>src:源数组;</p>
<p>srcPos:源数组要复制的起始位置;</p>
<p>dest:目的数组;</p>
<p>destPos:目的数组放置的起始位置;</p>
<p>length:复制的长度.</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 虚拟机</title>
    <url>/2021/04/24/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
    <content><![CDATA[<h2 id="Java虚拟机">Java虚拟机</h2>
<hr>
<h3 id="一、运行时数据区域">一、运行时数据区域</h3>
<hr>
<p>JVM执行Java程序时会把内存分为多个数据区域，其中：</p>
<p>堆、方法区（包括运行时常量池）和直接内存被线程共享</p>
<p>每个线程有自己的程序计数器、本地方法栈和虚拟机栈</p>
<span id="more"></span>
<hr>
<h4 id="程序计数器">程序计数器</h4>
<p>可以看作是当前线程正在执行的那条字节码指令的地址，如果执行的是本地方法，程序计数器的值是<code>undefined</code></p>
<p>字节码解释器通过改变计数器的值来选取下一条需要执行的字节码指令</p>
<p>每条线程有独立的程序计数器，所以在线程切换后能恢复到正确的执行位置</p>
<p><strong>程序计数器主要的两个作用：</strong></p>
<ol>
<li>字节码解释器通过改变计数器的值依次读取指令，从而实现代码的流程控制</li>
<li>多线程下，程序计数器记录当前线程的执行位置，切换回来后可以知道上次运行到哪</li>
</ol>
<p><strong>程序计数器是唯一一个不会出现OutOfMemoryError的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。</strong></p>
<hr>
<h4 id="Java虚拟机栈">Java虚拟机栈</h4>
<p>Java虚拟机栈为每个即将运行的Java方法创建一个栈帧</p>
<p>Java内存可以粗糙分为堆内存和栈内存，栈就是虚拟机栈</p>
<p>Java虚拟机栈是由一个个栈帧组成，每个栈帧中都有局部变量表、操作数栈、动态链接、方法出口信息。</p>
<p><strong>局部变量表随着栈帧的创建而创建，大小在编译时就确定，运行时大小不会改变</strong></p>
<p><strong>存放了编译器可知的8种基本数据类型、对象的引用</strong>（不同于对象本身，可能是对象某个位置的引用）</p>
<p>方法需要创建局部变量时，就将值放入局部变量表</p>
<p>Java 虚拟机栈的栈顶的栈帧是当前正在执行的活动栈，也就是当前正在执行的方法，PC 寄存器也会指向这个地址。只有这个活动的栈帧的本地变量可以被操作数栈使用，当在这个栈帧中调用另一个方法，与之对应的栈帧又会被创建，新创建的栈帧压入栈顶，变为当前的活动栈帧。</p>
<p>方法结束后，当前栈帧被移出，栈帧的返回值变成新的活动栈帧中操作数栈的一个操作数。如果没有返回值，那么新的活动栈帧中操作数栈的操作数没有变化。</p>
<p><strong>Java 虚拟机栈会出现两种异常：StackOverFlowError 和 OutOfMemoryError。</strong></p>
<ul>
<li><strong>StackOverFlowError：</strong> 若Java虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前Java虚拟机栈的最大深度的时候，就抛出StackOverFlowError异常。</li>
<li><strong>OutOfMemoryError：</strong> 若 Java 虚拟机栈的内存大小允许动态扩展，且当线程请求栈时内存用完了，无法再动态扩展了，此时抛出OutOfMemoryError异常。</li>
</ul>
<p>随着线程的创建而创建，随着线程的死亡而死亡</p>
<hr>
<h4 id="本地方法栈">本地方法栈</h4>
<p>虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的<strong>Native方法服务</strong>，本地方法栈是描述本地方法运行过程的内存模型。</p>
<p>本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。</p>
<p>方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 StackOverFlowError 和 OutOfMemoryError 两种异常。</p>
<hr>
<h4 id="堆">堆</h4>
<p>虚拟机管理内存中最大的一块。**此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。**在虚拟机启动时创建。</p>
<p>Java堆是垃圾收集器管理的主要区域，所以也被称作<strong>GC堆（Garbage Collection Heap）</strong></p>
<p>Java堆会被进一步划分（新生代、老年代、永久代，其中前两种使用的是Java程序可以使用的堆内存），这样可以更好地回收内存和分配内存。永久代是对JVM方法区的实现</p>
<p>因为是被所有线程共享的，所以访问要注意同步的问题</p>
<p>对于主流虚拟机，堆是可扩展的。如果线程请求分配内存，但是堆满了，内存也无法扩展，就会抛出OutOfMemoryError异常</p>
<p>JDK1.8中移除了永久代，用元空间（Metaspace）取代。元空间使用物理内存，永久代使用JVM堆内存</p>
<p>方法区是一个 JVM 规范，永久代与元空间都是其一种实现方式。在 JDK 1.8 之后，原来永久代的数据被分到了堆和元空间中。<strong>元空间存储类的元信息，静态变量和常量池等放入堆中</strong>。</p>
<hr>
<h4 id="方法区">方法区</h4>
<p>是堆的一个逻辑部分，和Java堆不一样。存储被虚拟机加载的类信息、常量、静态变量、即时编译器编译的代码等。</p>
<p>方法区被称为“永久代”，因为其中的信息一般都需要长久存在。对方法区的主要回收目标是：对常量池回收；对类的卸载</p>
<p><strong>相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入方法区后就“永久存在”了。</strong></p>
<p><strong>运行时常量池</strong>是方法区的一部分，存放编译期间生成的常量（<strong>字面量</strong>和<strong>符号引用</strong>）</p>
<p>字面量包括：文本字符串，final常量，基本数据类型</p>
<p>符号引用：类的完全限定名，字段名和描述符，方法名和描述符</p>
<p>受到方法区内存的限制，无法申请到内存时会抛出OutOfMemoryError异常</p>
<p>JDK1.7之后的版本将运行时常量池从方法区移到了Java堆中</p>
<hr>
<h4 id="直接内存">直接内存</h4>
<p>不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区，但会被频繁使用，也会出现内存超出</p>
<p>直接内存申请空间耗费更高的性能</p>
<p>直接内存读取 IO 的性能要优于普通的堆内存。</p>
<hr>
<h4 id="Java对象的创建过程">Java对象的创建过程</h4>
<p>类加载检查 – 分配内存 – 初始化零值 – 设置对象头 – 执行init方法</p>
<p>类加载检查：遇到new指令，先去检查能否在常量池中定位到类的符号引用，并检查其代表的类是否被加载、解析和初始化过，如果没有，要先执行相应的类加载过程</p>
<p>分配内存：通过类加载检查后为新生对象分配内存，所需内存大小在类加载完成后就确定，从Java堆中分出一块确定大小的区域，分配方式有<strong>指针碰撞</strong>和<strong>空闲列表</strong>两种</p>
<p>两种方式取决于堆是否规整，取决于垃圾收集器的算法是“标记-清除”还是“标记-整理”</p>
<p>指针碰撞：用过的内存放一边，没用过的放一边，只要沿着没用过的地方移动指针就行</p>
<p>空闲列表：虚拟机会维护一个列表，记录哪些内存块可用。分配内存时找一块足够大的内存块分配给对象，更新列表</p>
<p>初始化零值：将对象分配到的内存都初始化为零值，保证对象的实例可以不赋初始值就使用</p>
<p>设置对象头：虚拟机对对象进行必要的设置，将对象的相关信息如：是哪个类的实例、对象的哈希码等放到对象头中</p>
<p>执行init方法：虚拟机已经产生一个新的对象，但是Java程序中才刚刚开始，init执行后一个新的对象才算产生</p>
<hr>
<h4 id="对象的内存布局">对象的内存布局</h4>
<p>分为3块：对象头、实例数据和对其填充</p>
<p>对象头包括：自身的运行时数据（哈希码，GC分代年龄）、类型指针（指向类元数据的指针，确定对象是哪个类的实例）</p>
<p>实例数据：对象的成员变量</p>
<p>对其填充：起占位作用</p>
<p>访问对象的方式：</p>
<p>创建对象时在两个地方分配了内存。引用存在Java虚拟机栈的局部变量表中，但是实际对象存储在堆中</p>
<p>句柄访问：引用类型的变量存储了对象的句柄地址，通过访问句柄池找到对象，包括对象实例数据（java堆）和对象所属类的数据（方法区）</p>
<p>直接指针访问：对象的变量直接存放Java堆中对象的地址，但是Java堆中的对象实例还需要额外存储方法区中对象所属类信息的地址。</p>
<p>hotspot采用直接指针访问，只要一次寻址速度比前者快一倍，但是需要额外策略来存储地址。</p>
<hr>
<p>常量池</p>
<p>直接使用双引号声明出来的 String 对象会直接存储在常量池中， new出来的在堆内存中。</p>
<ul>
<li><strong>Byte,Short,Integer,Long,Character,Boolean；这5种包装类默认创建了数值[-128，127]的相应类型的缓存数据，但是超出此范围仍然会去创建新的对象。</strong></li>
<li><strong>两种浮点数类型的包装类 Float,Double 并没有实现常量池技术。</strong></li>
</ul>
<hr>
<h3 id="二、垃圾收集策略">二、垃圾收集策略</h3>
<hr>
<p>关注Java堆和方法区的内存，因为只有运行时才知道创建了哪些对象，这部分内存的分配和回收都是动态的</p>
<h4 id="判断对象是否存活">判断对象是否存活</h4>
<hr>
<p>如果一个对象不被任何对象引用，就是无效对象，会被回收</p>
<h5 id="引用计数器法">引用计数器法</h5>
<p>对象头维护一个counter计数器，被引用一次+1，引用失效-1，如果计数器为0该对象就无效</p>
<p>实现简单，判定效率搞。但主流Java虚拟机没有采用这个方法，因为很难解决对象间循环引用的问题 – 如果两个对象互相引用，计数器都不为0，就无法被回收。</p>
<h5 id="可达性分析法">可达性分析法</h5>
<p>所有和GC Roots直接或间接关联的对象都是有效对象，否则是无效对象</p>
<p>GC Roots 指：</p>
<ul>
<li>Java虚拟机栈（栈帧中的局部变量表）中引用的对象</li>
<li>本地方法栈中引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>方法区中静态属性引用的对象</li>
</ul>
<p>不包括堆中对象引用的对象，所以不会有循环引用</p>
<h4 id="引用的种类">引用的种类</h4>
<hr>
<h5 id="强引用-Strong">强引用 Strong</h5>
<p>类似Object obj = new Object()就是强引用，只要强引用存在。GC永远不会回收被引用的对象。但是，如果我们<strong>错误地保持了强引用</strong>，比如：赋值给了 static 变量，那么对象在很长一段时间内不会被回收，会产生内存泄漏。</p>
<h5 id="软引用-Soft">软引用 Soft</h5>
<p>软引用是一种相对强引用弱化一些的引用，可以让对象豁免一些垃圾收集，只有当 JVM 认为内存不足时，才会去试图回收软引用指向的对象。JVM 会确保在抛出 OutOfMemoryError 之前，清理软引用指向的对象。软引用通常用来<strong>实现内存敏感的缓存</strong>，如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。</p>
<h5 id="弱引用-Weak">弱引用 Weak</h5>
<p>弱引用的<strong>强度比软引用更弱</strong>一些。当 JVM 进行垃圾回收时，<strong>无论内存是否充足，都会回收</strong>只被弱引用关联的对象。</p>
<h5 id="虚引用-Phantom">虚引用 Phantom</h5>
<p>虚引用也称幽灵引用或者幻影引用，它是<strong>最弱</strong>的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响。它仅仅是提供了一种确保对象被 finalize 以后，做某些事情的机制，比如，通常用来做所谓的 Post-Mortem 清理机制。</p>
<h4 id="回收堆中无效对象">回收堆中无效对象</h4>
<hr>
<h5 id="判断finalize-是否有必要执行">判断finalize()是否有必要执行</h5>
<p>对于不可达的对象，会判断finalize()方法是否有必要执行，如果已经被执行过（任何一个对象的 finalize() 方法只会被系统自动调用一次）或者该方法没有被对象重写，对象就会真的被回收。</p>
<p>如果被判定为有必要执行finalize()方法，就会放入一个F-Queue队列以较低优先级执行方法，但不确保会执行结束。</p>
<h5 id="对象重生或死亡">对象重生或死亡</h5>
<p>之所以提finalize()，是因为如果在方法中将this赋给某一引用，对象就重生了。否则对象就会被GC清除。</p>
<h4 id="回收方法区内存">回收方法区内存</h4>
<hr>
<p>方法区中主要清除2类垃圾：废弃常量、无用的类</p>
<h5 id="判定废弃常量">判定废弃常量</h5>
<p>对于常量，只要常量池中的常量没有被任何的变量或对象引用，就会被清除</p>
<h5 id="判定无用的类">判定无用的类</h5>
<p>条件较为苛刻：</p>
<ul>
<li>该类的所有对象都被清除</li>
<li>加载该类的classLoader已经被回收</li>
<li>该类的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问到该类的方法</li>
</ul>
<p><strong>一个类被虚拟机加载进方法区，在堆中就会有一个代表该类的对象：java.lang.Class。这个对象在类被加载到方法区时被创建，在方法区该类被删除时清除。</strong></p>
<h4 id="垃圾收集算法">垃圾收集算法</h4>
<hr>
<p>常见的垃圾收集算法</p>
<p>见： <a href="https://github.com/doocs/jvm/blob/master/docs/03-gc-algorithms.md">https://github.com/doocs/jvm/blob/master/docs/03-gc-algorithms.md</a></p>
<h3 id="三、内存分配与回收策略">三、内存分配与回收策略</h3>
<hr>
<p>对象的内存分配就是在堆上分配</p>
<h4 id="对象优先在Eden分配">对象优先在Eden分配</h4>
<hr>
<p>多数情况下对象在新生代Eden区进行分配，Eden区内存不够时，虚拟机将发起一次Minor GC。</p>
<ul>
<li>Minor GC：回收新生代（包括 Eden 和 Survivor 区域），因为 Java 对象大多都具备朝生夕灭的特性，所以 Minor GC 非常频繁，一般回收速度也比较快。</li>
<li>Major GC / Full GC: 回收老年代，出现了 Major GC，经常会伴随至少一次的 Minor GC，但这并非绝对。Major GC 的速度一般会比 Minor GC 慢 10 倍 以上。</li>
</ul>
<h4 id="大对象直接进入老年代">大对象直接进入老年代</h4>
<hr>
<p>大对象指需要大量连续内存空间的Java对象，例如很长的字符串或数据</p>
<p>一个大对象能够存入 Eden 区的概率比较小，发生分配担保的概率比较大，而分配担保需要涉及大量的复制，就会造成效率低下。</p>
<p>虚拟机提供了一个 -XX:PretenureSizeThreshold 参数，令大于这个设置值的对象直接在老年代分配，这样做的目的是避免在 Eden 区及两个 Survivor 区之间发生大量的内存复制。</p>
<h4 id="长期存活的对象将进入老年代">长期存活的对象将进入老年代</h4>
<hr>
<p>JVM给每个对象定义一个年龄计数器，每次发生Minor GC存活时，存活下的对象年龄+1，超过一定值就转移到老年代</p>
<p>使用 -XXMaxTenuringThreshold 设置新生代的最大年龄，只要超过该参数的新生代对象都会被转移到老年代中去。</p>
<h4 id="动态对象年龄判定">动态对象年龄判定</h4>
<hr>
<p>如果新生代Survivor中相同年龄所有对象的总和大于Survivor空间的一半，将年龄&gt;=该年龄的对象直接放入老年代。</p>
<h4 id="空间分配担保">空间分配担保</h4>
<hr>
<p>JDK 6 Update24 之后</p>
<p>只要老年代的连续空间大于历次晋升的平均大小，就进行Minor GC，否则进行Full GC。</p>
<p>通过清除老年代中飞起数据来扩大老年代空闲空间，为新生代作担保，这个过程就是分配担保。</p>
<hr>
<h4 id="会触发JVM进行Full-GC的情况">会触发JVM进行Full GC的情况</h4>
<p>System.gc()的调用</p>
<p>老年代空间不足</p>
<p>发生空间分配担保</p>
<hr>
<h3 id="四、JVM-类加载">四、JVM 类加载</h3>
<h4 id="JVM的“无关性”">JVM的“无关性”</h4>
<hr>
<p>谈论 JVM 的无关性，主要有以下两个：</p>
<ul>
<li>平台无关性：任何操作系统都能运行 Java 代码</li>
<li>语言无关性： JVM 能运行除 Java 以外的其他代码</li>
</ul>
<p>Java 源代码首先需要使用 Javac 编译器编译成 .class 文件，然后由 JVM 执行 .class 文件，从而程序开始运行。</p>
<p><strong>JVM 只认识 .class 文件，它不关心是何种语言生成了 .class 文件，只要 .class 文件符合 JVM 的规范就能运行。</strong> 目前已经有 JRuby、Jython、Scala 等语言能够在 JVM 上运行。它们有各自的语法规则，不过它们的编译器 都能将各自的源码编译成符合 JVM 规范的 .class 文件，从而能够借助 JVM 运行它们。</p>
<h4 id="类加载的时机">类加载的时机</h4>
<hr>
<p>详细查看：<a href="https://github.com/doocs/jvm/blob/master/docs/08-load-class-time.md">https://github.com/doocs/jvm/blob/master/docs/08-load-class-time.md</a></p>
<h4 id="接口的加载过程">接口的加载过程</h4>
<p>接口加载过程与类加载过程稍有不同。</p>
<p>当一个类在初始化时，要求其父类全部都已经初始化过了，但是一个接口在初始化时，并不要求其父接口全部都完成了初始化，当真正用到父接口的时候才会初始化。</p>
<h4 id="类加载的过程">类加载的过程</h4>
<hr>
<p>类加载过程包括5个阶段：加载、验证、准备、解析、初始化</p>
<h5 id="加载">加载</h5>
<p>“加载”是“类加载”过程的一个阶段，不能混淆这两个名词。在加载阶段，虚拟机需要完成 3 件事：</p>
<ul>
<li>通过类的全限定名获取该类的二进制字节流。</li>
<li>将二进制字节流所代表的静态结构转化为方法区的运行时数据结构</li>
<li>在内存中创建一个java.lang.Class对象，作为方法区这个类的各种数据的访问入口</li>
</ul>
<p><strong>二进制字节流</strong>（Class文件）从哪获取：</p>
<ul>
<li>压缩包，如jar、war包</li>
<li>网络中，applet</li>
<li>由jsp文件生成对应的class</li>
</ul>
<h5 id="“数组类”和“非数组类”加载比较">“数组类”和“非数组类”加载比较</h5>
<p>在Java中数组是一个Java类</p>
<ul>
<li>数组类本身不通过类加载器创建，是由Java虚拟机直接创建的，再由类加载器创建数组中的元素类</li>
<li>非数组类加载阶段可以使用系统提供的引导类加载器，也可以由用户自定义的加载器完成</li>
</ul>
<h5 id="注意事项">注意事项</h5>
<ul>
<li>虚拟机没有规定class对象（java.lang.Class）的存储位置，对于Hotspot来说，class对象虽然是对象，但是存在方法区中。</li>
<li>加载和连接阶段交叉进行，加载没有完成就可能开始连接了。</li>
</ul>
<h4 id="验证">验证</h4>
<hr>
<h5 id="验证阶段的重要性">验证阶段的重要性</h5>
<p>保证class文件的字节流包含的信息符合当前虚拟机的要求。不会危害虚拟机自身的安全。</p>
<h5 id="验证的过程">验证的过程</h5>
<p>文件格式验证、元数据验证、字节码验证、符号引用验证</p>
<h4 id="准备">准备</h4>
<hr>
<p>准备阶段是正式为类变量（或称“静态成员变量”）分配内存并设置初始值的阶段。这些变量（不包括实例变量）所使用的内存都在方法区中进行分配。</p>
<p>类变量的初始值通常是数据类型的零值（0， null）</p>
<p>但如果这个类变量被声明为常量，就会被初始化为所指定的值</p>
<p>如 <code>public static final int value = 123;</code> 在准备阶段，jvm会将value赋值为123</p>
<h4 id="解析">解析</h4>
<hr>
<p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程</p>
<p>符号引用：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能够无歧义的定位到目标即可。</p>
<p>直接引用可以是：</p>
<ul>
<li>
<p>直接指向目标的指针（比如，指向“类型”【Class对象】、类变量、类方法的直接引用可能是指向方法区的指针）</p>
</li>
<li>
<p>相对偏移量（比如，指向实例变量、实例方法的直接引用都是偏移量）</p>
</li>
<li>
<p>一个能间接定位到目标的句柄</p>
</li>
</ul>
<p>直接引用是和虚拟机的布局相关的，同一个符号引用在不同的虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经被加载入内存中了。</p>
<h4 id="初始化">初始化</h4>
<hr>
<p>类初始化阶段是类加载过程的最后一步，是执行类构造器<clinit>()方法的过程。</p>
<p><clinit>()方法是由编译器自动收集类中所有类变量的赋值动作和静态语句块（static{}块）中的语句产生</p>
<p><clinit>() 方法不需要显式调用父类构造器，虚拟机会保证在子类的 <clinit>() 方法执行之前，父类的 <clinit>() 方法已经执行完毕。</p>
<p>由于父类的 <clinit>() 方法先执行，意味着父类中定义的静态语句块要优先于子类的变量赋值操作。</p>
<p><clinit>() 方法不是必需的，如果一个类没有静态语句块，也没有对类变量的赋值操作，那么编译器可以不为这个类生成 <clinit>() 方法。</p>
<p>接口中不能使用静态代码块，但接口也需要通过 <clinit>() 方法为接口中定义的静态成员变量显式初始化。但接口与类不同，接口的 <clinit>() 方法不需要先执行父类的 <clinit>() 方法，只有当父接口中定义的变量使用时，父接口才会初始化。</p>
<p>虚拟机会保证一个类的 <clinit>() 方法在多线程环境中被正确加锁、同步。如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的 <clinit>() 方法。</p>
<h3 id="五、Java类加载器">五、Java类加载器</h3>
<hr>
<ul>
<li>见：<a href="https://github.com/doocs/jvm/blob/master/docs/10-class-loader.md">https://github.com/doocs/jvm/blob/master/docs/10-class-loader.md</a></li>
</ul>
<h4 id="双亲委派模型">双亲委派模型</h4>
<h5 id="什么是双亲委派模型">什么是双亲委派模型</h5>
<p>双亲委派模型是描述类加载器之间的层次关系。它要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。（父子关系一般不会以继承的关系实现，而是以组合关系来复用父加载器的代码）</p>
<p>在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载。加载的时候，首先会把该请求委派该父类加载器的 <code>loadClass()</code> 处理，因此所有的请求最终都应该传送到顶层的启动类加载器 <code>BootstrapClassLoader</code> 中。当父类加载器无法处理时，才由自己来处理。当父类加载器为null时，会使用启动类加载器 <code>BootstrapClassLoader</code> 作为父类加载器。</p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 实现分布式锁</title>
    <url>/2021/06/10/Redis-%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
    <content><![CDATA[<h3 id="Redis-实现">Redis 实现</h3>
<p>Redis 分布式锁的实现主要基于 <code>SETNX key value</code> 这个指令</p>
<ul>
<li>如果 key 不存在，就创建对应的键值对，创建成功，返回 1</li>
<li>如果 key 存在，创建失败，返回 0</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> setnx 1 xin</span></span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> setnx 1 xin2</span></span><br><span class="line">(integer) 0</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> setnx 2 xin</span></span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>
<p>除此之外还需要解决键值对长期有效的问题，还需要为键值对设置一个过期时间，对应的 redis 指令为 <code>EXPIRE key seconds</code>，到期之后键值会自动删除</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> get 1</span></span><br><span class="line">&quot;xin&quot;</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> expire 1 2</span></span><br><span class="line">(integer) 1</span><br><span class="line">// 2秒后</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> get 1</span></span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure>
<p>在 redis 2.6.12 以后的版本，可以用组合指令来实现上述的分布式锁<br>
<code>SET key value [EX seconds] NX</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">set</span> 1 xin ex 10 nx</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> get 1</span></span><br><span class="line">&quot;xin&quot;</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> ttl 1</span></span><br><span class="line">(integer) 4</span><br><span class="line">// 10秒后</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> ttl 1</span></span><br><span class="line">(integer) -2</span><br></pre></td></tr></table></figure>
<p><code>ttl key</code> 命令用于查看键值对的剩余过期时间</p>
<ul>
<li>对于设置了过期时间并且尚未过期的键值对，ttl 命令返回剩余过期时间；</li>
<li>对于已过期不存在的键值对，ttl 命令返回 -2；</li>
<li>对于没有过期时间的键值对，ttl 命令返回 -1；</li>
</ul>
<h3 id="Jedis-实现">Jedis 实现</h3>
<p>在 Jedis 中可以实现一个 <code>setNxAndExp</code> 方法来实现分布式锁的功能</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">setNxAndExp</span><span class="params">(String key, String val, <span class="keyword">int</span> expSecond)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果键值对创建成功，设置一个过期时间</span></span><br><span class="line">    <span class="keyword">if</span> (jedisCluster.setNx(key, val) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (expSecond &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            jedisCluster.expire(key, expSecond);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果创建失败，并且已有的键值对没有过期时间，为其设置一个过期时间，一段时间后释放锁</span></span><br><span class="line">        <span class="keyword">if</span> (jedisCluster.ttl(key).longValue() == -<span class="number">1</span>) &#123;</span><br><span class="line">            jedisCluster.expire(key, expSecond);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建成功返回 1，创建失败返回 0，与 setNx 返回值相同</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="参考">参考</h3>
<p><a href="https://blog.csdn.net/CoreyXuu/article/details/89019869">redis 基于SETNX和EXPIRE的用法 实现redis 分布式锁</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Java面试重点</title>
    <url>/2021/04/24/Java%E9%9D%A2%E8%AF%95%E9%87%8D%E7%82%B9/</url>
    <content><![CDATA[<h2 id="基础">基础</h2>
<hr>
<h3 id="Object类方法-4">Object类方法 4</h3>
<p>getClass() 获取运行时对象的Class对象</p>
<p>hashCode() 获取对象的哈希码，在哈希表中被使用</p>
<p>toString() 输出 类名@实例的十六进制哈希码</p>
<p>clone() 返回当前对象的一份拷贝</p>
<p>equals() 比较对象是否等价</p>
<span id="more"></span>
<hr>
<h3 id="BIO、NIO、AIO-3"><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/BIO-NIO-AIO">BIO、NIO、AIO</a> 3</h3>
<p>是 Java 对各种 IO 模型的封装，Java 中的 IO 都是依赖操作系统内核进行的，其实调用的是内核中的read 和 write 两大系统调用</p>
<hr>
<p><strong>IO交互的步骤</strong></p>
<ul>
<li>网卡接收网络传输过来的数据，并将数据写入内存</li>
<li>写入完成后，发送一个中断信号给 CPU，操作系统便得知有数据到来，然后通过网卡中断去处理数据</li>
<li>将内存中的数据写到对应的 socket 接收缓冲区中</li>
<li>接收缓冲区数据写好后，应用程序开始进行数据处理</li>
</ul>
<hr>
<p><strong>同步和异步</strong></p>
<p><strong>同步</strong>：两个任务相互依赖，一个任务要依赖另一个任务的执行</p>
<p><strong>异步</strong>：两个任务完全独立，一方的执行不需要等待另一方执行完成</p>
<p><strong>阻塞和非阻塞</strong></p>
<p><strong>阻塞</strong>：发起一个请求，一直在等结果返回，期间会被挂起，不执行后续操作</p>
<p><strong>非阻塞</strong>：在等待结果返回时，先去做其他工作，隔段时间查看同步是否完成</p>
<hr>
<p><strong>BIO Blocking I/O</strong></p>
<p>是传统的 <a href="http://java.io">java.io</a> 包，交互的方式是同步阻塞，就是在发起一个读写请求后，在读写操作完成之前时，线程会一直阻塞，直到读写操作完成才会继续执行。代码简单直观但是效率低。适用于连接数目小且固定的结构。在网络通信中使用 BIO，如果想要同时处理多个客户端请求，就需要创建多个线程。</p>
<p><strong>NIO Non-Blocking IO</strong></p>
<p>是 Java 1.4 以后引入的 java.nio 包，提供<strong>Channel，Selector，Buffer</strong>等抽象。它支持面向缓冲的，基于通道的 IO 操作方法</p>
<p>线程发起 IO 请求后，立即返回去做其他工作，定期检查 IO 缓冲区数据是否就绪。 等到读写完成之后线程再继续处理数据。Java 中的 NIO 加入多路复用技术，会轮询一堆 IO 缓冲区中有哪些准备就绪。</p>
<p><strong>IO 面向流</strong>，直接将数据写到 Stream 中；<strong>NIO 面向缓冲区 Buffer</strong>，直接将数据读读到 Buffer 中进行操作，任何时候访问 NIO 中的数据，都是通过缓冲区进行操作</p>
<p><strong>NIO</strong> 通过 Channel 进行读写，通道是双向的，可读也可写，通道只能和 Buffer 进行交互；<strong>IO</strong> 的流是单向的，分输入流和输出流</p>
<p><strong>NIO</strong> 使用 Selector 来基于单线程处理多个通道</p>
<p><strong>AIO</strong></p>
<p>Java 7 中引入了 NIO 2，是异步非阻塞 IO。线程在执行 IO 操作后，马上返回继续执行操作，等到缓冲区就绪，由内核通知线程或者执行回调函数来进行后续操作。</p>
<hr>
<h3 id="反射-2">反射 2</h3>
<p><strong>反射</strong>是指<strong>在运行时</strong>，对任意一个类都能知道这个类的所有属性和方法。对于任何一个对象，都能调用它的任意一个方法和属性。这种<strong>动态获取信息和动态调用对象方法的功能</strong>称为反射机制。</p>
<p><strong>原理</strong>：反射是由Class类对象开始的。当一个类被加载以后，JVM就会自动产生一个Class对象，通过Class对象我们就能获得加载到虚拟机中的这个类的方法和属性。</p>
<p>获取类的方法有</p>
<ul>
<li>Class.forName()</li>
<li>类名.class</li>
<li>对象.getClass()</li>
</ul>
<p><strong>使用场景：框架开发的动态配置</strong></p>
<p>在properties里写好了配置，在Java类里面解析配置内容，得到对应实体类的字节码字符串，使用反射机制获取到某个类的Class实例，然后动态配置实例的属性。</p>
<hr>
<h3 id="、equals-区别-2">==、equals()区别 2</h3>
<p>对于基本数据类型，==比较他们的值是否相等，基本数据类型没有equals()方法</p>
<p>对于引用数据类型，==比较他们是否引用同一对象，而equals()判断引用的对象是否等价，如果equals没有被重写，就比较指向的地址是否相等，如果被重写，会比较地址中的内容，例如String中比较的是字符是否都相同。</p>
<p>判断方法是：</p>
<ul>
<li>如果是同一对象的引用，返回true</li>
<li>检查是否是同一类型，如果不是，返回false</li>
<li>将Object对象转型然后判断关键域是否相等</li>
</ul>
<hr>
<h3 id="深拷贝和浅拷贝-2">深拷贝和浅拷贝 2</h3>
<p><strong>浅拷贝</strong>是按位拷贝，会创建一个新的对象，拥有原始对象属性值的拷贝。对于基本数据类型，拷贝的就是他们的值，但是对于引用数据类型，只是拷贝了引用地址，与原对象相比，在内存中指向的还是同一个对象</p>
<p><strong>深拷贝</strong>相比浅拷贝，还把其中引用其他对象的变量指向了一个被复制过的新对象。也就是把拷贝对象所引用的对象也复制了一遍。所以深拷贝很慢。</p>
<hr>
<h3 id="Java-的三大特性">Java 的三大特性</h3>
<p><strong>封装性</strong></p>
<p>就是把相关属性和方法都封装到一个类中，保留特定的借口供外界调用</p>
<p><strong>继承性</strong></p>
<p>可以从一个已知的类中派生出一个新的类，具有父类的一些方法和属性，也可以通过重写父类方法来扩展新的功能</p>
<p><strong>多态性</strong></p>
<p>本质就是一个程序<strong>存在同名的多个不同方法</strong>，主要通过：</p>
<ul>
<li>子类重写父类方法</li>
<li>类中对方法进行重载</li>
<li>将子类对象作为父类对象来使用</li>
</ul>
<hr>
<h3 id="static、final关键字">static、final关键字</h3>
<p><strong>static</strong></p>
<p><strong>内部类</strong>就是定义在类内部的类，分为非静态内部类和静态内部类，其中只有内部类才可以被声明为静态。</p>
<p><strong>非静态内部类</strong></p>
<ul>
<li>依赖于外部的实例创建，外部类要先创建实例，再通过实例创建内部类</li>
<li>内部成员不能是静态的</li>
<li>可以访问外部类的所有属性</li>
</ul>
<p><strong>静态内部类</strong></p>
<ul>
<li>可以直接通过外部类访问创建。内部成员可以是静态也可以是非静态</li>
<li>成员可以是静态也可以是非静态</li>
<li>只能访问外部类静态成员</li>
</ul>
<p>其中<strong>静态方法</strong>在类加载的时候就存在，<strong>静态成员</strong>和<strong>静态语句块</strong>则是在类初始化的时候才被初始化</p>
<p><strong>静态方法</strong>必须要有实现，只能访问所属类的静态成员，方法中不能有this，super因为他们都对应了具体实例</p>
<hr>
<p><strong>final</strong></p>
<p>final类不能被继承，final方法不能被重写，final变量值无法改变</p>
<hr>
<h2 id="容器">容器</h2>
<h3 id="HashMap-11">HashMap 11</h3>
<hr>
<p><strong>HashMap</strong></p>
<p><strong>JDK1.8之前</strong>HashMap是由数组加链表的结构实现的，数组是主体，链表是用来解决哈希冲突而存在的（拉链法）。<strong>JDK1.8以后</strong>，如果链表长度大于8，会转化为红黑树；但是如果数组长度小于64，则会选择先对数组进行扩容，而不是转化为红黑树。使用红黑树是为了减少搜索时间。</p>
<p>HashMap会使用<strong>扰动函数</strong>处理key的hashcode得到一个hash，根据这个hash决定插入位置，扰动函数可以减少碰撞。JDK1.8的操作是<strong>无符号右移16位然后异或</strong>。</p>
<p><strong>初始容量</strong>为16，<strong>加载因子</strong>0.75，扩容是翻倍。当元素个数超过容量的四分之三（0.75）会进行扩容。</p>
<hr>
<p><strong>线程不安全</strong></p>
<p>线程不安全主要考虑到多线程情况下扩容会出现<strong>HashMap死循环</strong>，由于「扩容会建个新哈希，然后把数据从老的hash表迁移」这个过程。</p>
<p>快速失败fail-fast机制：多个线程改变集合结构的时候程序会抛出CocurrentModificationException异常，发生fail-fast</p>
<hr>
<p><strong>大小和扩容</strong></p>
<p>默认的初始化大小是16，之后每次扩容会变为原来的两倍；如果设置了初始值，会把其扩容到2的幂次方大小。<strong>扩容是指对数组长度扩容</strong>，数组是主体。但是判断是否要扩容，是根据map中元素的个数与threshold进行比较，threshold是当前容量乘以加载因子</p>
<p><strong>为什么大小是2的幂次</strong></p>
<p>计算数组下标一般会考虑到取余。有一个规律是:</p>
<p><strong>hash % length == hash &amp; (length - 1)</strong></p>
<p>也就是一个数与除数取余等于这个数和比除数小1的数进行与操作，但是<strong>前提是除数为2的幂次</strong>。因为数组下标的计算方式选择 (n - 1) &amp; hash，所以 n 要满足是2的幂次。<strong>与操作运算速度更快</strong>。</p>
<p><strong>并且resize之后，元素要么在原位置，要么在原位置移动2次幂的位置，不用每个元素都移动位置</strong></p>
<hr>
<p><strong>HashMap如何计算下标</strong></p>
<p>用扰动函数hash计算key的hashcode得到一个hash，方法是将原来hashcode无符号右移16位然后异或。之后对hash进行取模运算，函数中的运算方法是 hash &amp; (length - 1) length为数组长度</p>
<hr>
<p><strong>CocurrentHashMap下标空如何操作</strong></p>
<p>通过CAS操作进行赋值，将key、value、hash生成的节点放入桶中</p>
<hr>
<p><strong>插入方法</strong></p>
<p>1.7是头插法，1.8是尾插法</p>
<hr>
<p><strong>遍历方式</strong></p>
<ul>
<li>迭代器 entrySet 遍历，同时获取key和value</li>
<li>迭代器 keySet 遍历，只获取key，value通过key来get</li>
<li>ForEach entrySet 同上</li>
<li>ForEach keySet 同上</li>
<li>lambada表达式遍历</li>
<li>Streams API 进行遍历</li>
</ul>
<hr>
<p><strong>HashMap和HashTable的区别</strong></p>
<ul>
<li>HashMap是线程不安全的；HashTable使用了synchronized关键字，是线程安全的</li>
<li>HashMap允许null作为Key；HashTable不允许null作为Key，也不允许value为null</li>
</ul>
<hr>
<p><strong><a href="https://www.cnblogs.com/aspirant/p/8623864.html">CocurrentHashMap</a></strong></p>
<p><strong>底层数据结构</strong>还是数组加链表/红黑树的形式。</p>
<p>在<strong>JDK1.8之前</strong>是由<strong>Segment数组</strong>来实现的，Segment数组将一个大table分割成多个小table来进行加锁，每个Segment元素存储的是<strong>HashEntry数组和链表（和HashMap结构一样）</strong>，会有分段锁锁住一个Segment，多线程访问不同数据段的数据，就不会存在锁竞争，提高并发率。Segment默认大小为16，HashEntry最小容量为2。在这个版本需要经过两次 hash 才能到达指定 hashEntry，第一次先到达 Segment，第二次再到达 Segment 中的 hashEntry，然后再遍历 entry 链表</p>
<p><strong>JDK1.8之后</strong>摒弃了Segment概念，直接使用 <strong>Node数组 + 链表 + 红黑树</strong>的数据结构来实现，<strong>并发控制使用 sychronized 和 CAS</strong>，sychronized只锁定当前链表或者红黑树的首节点，只要不发生哈希冲突，就不存在并发问题。不过 Node 只适用于链表情况，转换为红黑树后要转为TreeNode</p>
<p>HashTable也是线程安全，但是只用一把锁，会出现锁竞争，效率低下</p>
<hr>
<p><strong>如何线程安全地使用HashMap</strong></p>
<p><strong>HashMap线程不安全</strong>是因为两个进程同时进行put操作可能导致数据被覆盖；多个线程同时进行扩容还可能导致死循环，Node形成环状数据结构</p>
<p><strong>HashTable</strong>是线程安全的，实现方式是 get 和 put 方法加了sychronized 关键字保证线程安全，但是所有线程竞争一把锁，效率很低</p>
<p><strong>CocurrentHashMap</strong>把数据分段，每段数据配一把锁，一个线程占用一段数据时，其他线程还可以访问其他数据，并发性更高。1.8中加锁粒度细分到桶。</p>
<p><strong>Sychronized Map</strong>中对每个方法加了sychronized关键字来保证线程安全，也是对整个表加锁</p>
<hr>
<h3 id="Hashcode方法-3">Hashcode方法 3</h3>
<p>hashCode()方法默认是对堆上的对象产生独特值，是对象地址的一个映射。如果不重写hashCode()，即使两个对象指向相同的数据，也不会有相同的哈希值。</p>
<p><strong>在重写equals方法的同时，必须重写hashCode方法</strong></p>
<hr>
<h3 id="ArrayList和LinkedList区别-3">ArrayList和LinkedList区别 3</h3>
<ul>
<li>两者都不保证线程安全</li>
<li>ArrayList底层使用Object数组；LinkedList使用双向链表</li>
<li>ArrayList在<strong>随机存取</strong>方面效率高于LinkedList</li>
<li>LinkedList在节点的<strong>增删</strong>方面效率高于ArrayList</li>
<li>ArrayList的空间浪费主要是因为尾部会预留一定空间；LinkedList则是每个节点都需要额外保存信息，前驱后驱节点</li>
</ul>
<p><strong>遍历长度很大的数组和链表，哪个效率更快</strong></p>
<p>数组，局部性原理，数组中的元素是连续的，周围的数据会提前加载到高速缓存cache中来</p>
<hr>
<h3 id="HashSet-2">HashSet  2</h3>
<p>实现Set接口，底层基于HashMap实现，对象不重复。因为底层基于HashMap，所以扩容机制也是一样的</p>
<p>加入对象时会先计算对象的哈希值来判断对象加入的位置，同时与其他已加入对象的hashcode比较，如果没有相等的，就默认没有重复出现；如果发现有相同的hashcode，再调用equals()判断两个对象是否等价，如果等价，添加操作就不成功。</p>
<hr>
<h3 id="泛型-2">泛型 2</h3>
<ul>
<li>泛型就是把属性的类型进行参数化，数据的类别也能像参数一样从外部传入</li>
<li>提供了类型检测机制，只有相匹配的数据才能正常赋值，否则编译无法通过</li>
</ul>
<p>泛型是通过<strong>类型擦除</strong>实现的，泛型信息只存在于代码编译阶段，在进入JVM前所有类相关的信息会被擦掉，在运行时是无法访问到类型参数的。<strong>是为了与之前版本的代码兼容</strong>。</p>
<p><strong>通配符</strong></p>
<p>限定通配符：&lt;? extends T&gt; 必须是T的子类 &lt;? super T&gt; 必须是T的父类</p>
<p>非限定通配符：&lt;?&gt; 经常与容器类配合使用，所涉及的操作肯定和具体类无关</p>
<hr>
<h3 id="哈希冲突-2">哈希冲突 2</h3>
<ul>
<li>
<p>拉链法，将冲突值加到链表中。JDK1.8之后会在一定条件下把链表转为红黑树来减少搜索时间</p>
</li>
<li>
<p>使用扰动函数重新计算key的哈希值（避免哈希冲突）</p>
</li>
</ul>
<hr>
<h3 id="Map和List">Map和List</h3>
<p>Map是和Collection并列的所有集合框架的上层接口，List和Set是Collection的子接口。</p>
<hr>
<h3 id="Vector-和-ArrayList">Vector 和 ArrayList</h3>
<p>底层，扩容为什么是1.5倍</p>
<p><strong>Vector 和 ArrayList 都是 List 的实现</strong>，前者是古老实现类，底层都是Object数组，Vector线程安全，ArrayList线程不安全</p>
<p><strong>Vector扩容默认2倍，ArrayList是1.5倍</strong></p>
<p>默认大小是10</p>
<p>为什么扩容是1.5倍，因为函数中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将oldCapacity 右移一位，其效果相当于oldCapacity /2，</span></span><br><span class="line">        <span class="comment">//我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，</span></span><br><span class="line">        <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>加上原本容量右移一位后的值，就相当于加上原来值的二分之一，变成1.5倍</p>
<hr>
<h2 id="并发">并发</h2>
<hr>
<h3 id="进程和线程的区别-16">进程和线程的区别 16</h3>
<ul>
<li>进程是一个执行中的程序，是系统进行资源分配的基本单位</li>
<li>线程是进程的一个实体，一个进程中一般会有多个线程，他们共享进程的共享地址空间和其他资源（Java中是堆和方法区资源）</li>
<li>线程一般不拥有系统资源，但是ThreadLocal会存储一些线程的专有资源（Java线程有自己的程序计数器、本地方法栈和虚拟机栈）</li>
<li>线程的上下文切换比进程快很多</li>
</ul>
<p><strong>线程的上下文切换快</strong>是因为线程切换只需要保存和设置少量寄存器内容，但是进程切换需要涉及当前CPU环境的保存和新运行进程CPU环境的设置。</p>
<p><strong>任务从保存到再加载的过程就是一次上下文切换</strong></p>
<hr>
<p><strong>守护线程</strong></p>
<ul>
<li>虚拟机要确保用户线程执行完毕</li>
<li>虚拟机不必等待守护线程执行完毕</li>
<li>设置 thread.setDaemon(true)</li>
<li>例如 GC 线程</li>
</ul>
<hr>
<h3 id="线程状态">线程状态</h3>
<p>线程状态包括 <strong>新建态，运行态，阻塞态，消亡态</strong></p>
<ul>
<li>NEW 线程被创建但是还没有调用start方法启动</li>
<li>Runnable 创建线程并启动后就处于Runnable状态，此时有可能正在运行Running（运行），也可能在等待CPU资源（Ready就绪）</li>
<li>Blocked 表示线程阻塞于锁</li>
<li>Waiting 在等待另一个线程执行一些操作后将其唤醒(执行wait方法后进入waiting，收到notify后被唤醒)</li>
<li>Time_waiting 与waiting类似，不过有明确等待时间，在到达等待时间会自动返回(执行了sleep(second) wait(second)方法)</li>
<li>Terminated 表示线程执行完毕后关闭</li>
</ul>
<p><strong>sleep()和wait()的区别</strong></p>
<ul>
<li>都能<strong>暂停</strong>线程的执行</li>
<li>sleep是Thread类的方法；wait是Object类的方法</li>
<li><strong>sleep没有释放锁；wait会释放锁</strong></li>
<li>wait常用于线程间交互通信；sleep用于暂停线程执行</li>
<li>wait()方法调用后需要其他线程使用notify()方法唤醒。sleep()方法执行完后线程会自己苏醒。wait()也可以设置时间实现超时自动苏醒。</li>
</ul>
<p><strong>blocked和wait的区别</strong></p>
<p>blocked阻塞于锁；wait是等待另一个线程执行一些操作后将该线程唤醒（notify）</p>
<p><strong>可不可以直接调用run()方法而不通过start()方法</strong></p>
<p>调用start()方法才会启动一个线程并让线程进入就绪态。直接运行run()方法只会把run()方法当成main进程下的一个普通方法去执行，并不是多线程。</p>
<hr>
<h3 id="线程安全">线程安全</h3>
<p>多线程环境下的线程安全主要体现在<strong>原子性，可见性和有序性</strong>方面</p>
<hr>
<p><strong>原子性</strong></p>
<p>对于涉及到共享变量访问的操作，如果<strong>在外部变量看来操作是不可分割的，那操作就具有原子性</strong>。即其他线程不会看到执行操作的中间部分结果。例如转账流程中，外部只能看到A账户少100，B账户多100；而不会看到A账户少100，B账户不变的情况</p>
<ul>
<li>Java中 <strong>synchronized</strong> 关键字可以保证代码片段的原子性</li>
</ul>
<hr>
<p><strong>可见性</strong></p>
<p>指一个线程更新了变量后其他线程可以立马看到修改后的最新值。 <strong>volatile 关键字可以保证共享变量的可见性</strong></p>
<p>Java线程可能将变量的值保存在本地寄存器来读取。如果一个线程在主存中修改了变量值，而另一个线程还是读它本地寄存器中变量的值，造成<strong>数据不一致</strong>。volatile指示 JVM 每次读取变量都去主存读。</p>
<hr>
<p><strong>有序性</strong></p>
<p>指代码在执行过程中的先后顺序。因为 Java 的优化可能导致执行顺序未必是编写代码时的顺序。 volatile 关键字可以禁止指令重排。</p>
<hr>
<h3 id="sychronized-8">sychronized 8</h3>
<p>sychronized是一个<strong>内部锁</strong>，它使用在方法和语句块上。它可以保证被它修饰的方法或语句块在任意时刻只能有一个线程执行。</p>
<p>是重量级锁，为什么重量级？因为每次发生冲突都会把线程阻塞，而每次阻塞和唤醒都要 CPU 在用户态和内核态之间进行切换，上下文切换开销大。</p>
<hr>
<p><strong>最主要的三种使用方式</strong></p>
<p><strong>修饰实例方法</strong>：作用于对象实例加锁，进入同步方法前要获得当前对象实例的锁</p>
<p><strong>修饰静态方法</strong>：给当前类加锁，会作用于类的所有实例。如果一个线程 A 调用一个实例对象的非静态 synchronized 方法，而线程 B 需要调用这个实例对象所属类的静态 synchronized 方法，是允许的，不会发生互斥现象，<strong>因为访问静态 synchronized 方法占用的锁是当前类的锁，而访问非静态 synchronized 方法占用的锁是当前实例对象锁</strong>。<strong>是两把不同的锁</strong></p>
<p><strong>修饰语句块</strong>：指定加锁对象</p>
<hr>
<p><strong>内部锁底层实现</strong></p>
<ol>
<li><strong>sychronized 同步语句块</strong></li>
</ol>
<ul>
<li>进入时，执行 monitorenter指令 ，计数器+1，获取到 monitor 锁，执行monitorexit 指令后，计数器 -1，归为0，表明锁被释放。</li>
<li>当一个线程判断计数器为0时，当前锁空闲，可以占用；反之，当前线程进入阻塞等待状态</li>
</ul>
<ol start="2">
<li><strong>sychronized 修饰方法</strong></li>
</ol>
<ul>
<li>给方法添加一个ACC_SYNCHRONIZED标示，表明该方法是一个同步方法，从而执行相应同步调用。线程在执行方法前会先去尝试获取对象的 monitor 对象，完成之后释放 monitor 对象；如果 monitor 已经被其他对象获取，当前线程被阻塞</li>
</ul>
<hr>
<p><strong>sychronized 和 ReentrantLock 的区别</strong></p>
<ul>
<li>（ReentrantLock就是可重入锁的意思）<strong>两者都是可重入锁</strong>，可重入锁就是指在获取到锁之后，在内部还可以多次获取到锁，这样在递归调用带锁的方法时就不会发生死锁</li>
<li><strong>sychronized 是一个修饰符，JVM实现的； 而 ReentrantLock 是JDK实现的</strong></li>
<li><strong>ReentrantLock等待可中断</strong>，通过 lock.lockInterruptibly() 可以让线程放弃等待转而去执行其他事；synchronized 不可以</li>
<li>ReentrantLock <strong>可以实现公平锁</strong>（默认是非公平锁），就是先等待的线程先获得锁；synchronized 是非公平锁</li>
<li>ReentrantLock可以绑定多个 Condition 条件</li>
</ul>
<hr>
<p><strong>synchronized 和 volatile 的区别</strong></p>
<ul>
<li>volatile 只能用于修饰变量；synchronized 可以修饰方法和代码块</li>
<li>volatile 可以保证数据的可见性，但不能保证原子性； sychronized 两者都能保证（因为加了互斥锁）</li>
<li>volatile 主要是解决变量在多个线程间的可见性；synchronized主要解决的事多个线程访问资源的同步性</li>
</ul>
<hr>
<h3 id="volatile-5">volatile 5</h3>
<p>语义，虚拟机如何实现</p>
<p>volatile 关键字是一个轻量级的锁，主要保证数据可见性，但是不保证原子性。声明一个变量是不稳定的，要求每次读取都去主内存读取。</p>
<p>加上 volatile 关键字之后会多一个 lock 指令，它相当于一个内存屏障，可以阻止指令重排，还会立刻将对变量的修改操作写入主存。</p>
<hr>
<h3 id="Threadlocal-3"><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%B9%B6%E5%8F%91.md#2-%E7%BA%BF%E7%A8%8B%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8thread-local-storage">Threadlocal 3</a></h3>
<p>通常我们创建的每个变量是可以被任何线程访问并修改的。<strong>ThreadLocal 是一个创建线程局部变量的类</strong>。</p>
<p>在主线程中创建一个Threadlocal变量，在其他线程中访问这个变量，都只能通过这个threadlocal变量访问到属于当前线程自己的变量，一个 threadlocal 对象获取到的值就是当前线程的局部变量</p>
<p>对于以下代码，thread1 中设置 threadLocal 为 1，而 thread2 设置 threadLocal 为 2。过了一段时间之后，thread1 读取 threadLocal 依然是 1，不受 thread2 的影响。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadLocal threadLocal = <span class="keyword">new</span> ThreadLocal();</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            threadLocal.set(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(threadLocal.get());</span><br><span class="line">            threadLocal.remove();</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            threadLocal.set(<span class="number">2</span>);</span><br><span class="line">            threadLocal.remove();</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>底层原理</strong></p>
<p>Thread 类中有两个 ThreadLocalMap 类型的变量： threadLocals 和 inheritableThreadLocals</p>
<ul>
<li>ThreadLocalMap可以理解为ThreadLocal定制化的HashMap</li>
<li>默认情况下这两个变量都为null，只有调用 ThreadLocal 类的 get 和 set 方法时才被创建</li>
<li>其实所调用的 get 和 set 方法就是 ThreadLocalMap 对应的 get set 方法</li>
</ul>
<p>所以线程的局部变量其实是保存在当前线程的 ThreadLocalMap 中，ThreadLocal 类的变量只是一个接口，用来访问当前线程的 ThreadLocalMap 中的数据。而 ThreadLocalMap 中存储的是以 ThreadLocal 为 key ，Object 对象为 value 的键值对，所以通过一个ThreadLocal 变量可以获取到一个线程的局部变量，如果要设置多个局部变量，就需要创建多个 ThreadLocal 对象然后通过 set 赋局部变量值</p>
<p><strong>ThreadLocal 内存泄露</strong></p>
<p>会出现内存泄露是因为 ThreadLocalMap 中的 key 为 ThreadLocal 的弱引用，而 value 是强引用。所以如果 ThreadLocal 没有被外部强引用，在下一次GC回收的时候就会被清理掉，而 value 没有被清理，就会出现很多 key 为 null 的 Entry，如果不采取任何措施， value 永远不会被 GC 回收，就会发生内存泄漏。</p>
<p>TreadLocalMap 在调用 get set remove 方法的时候会清除 key 为 null 的记录，所以使用完 ThreadLocal 方法后最好手动调用remove 方法</p>
<hr>
<h3 id="CAS-3"><a href="https://juejin.im/post/6844903558937051144">CAS</a> 3</h3>
<p>传统的加锁方式 synchronized 和 ReentrantLock 叫做<strong>互斥同步</strong>，又叫阻塞同步，这种同步方式最主要的问题就是<strong>线程阻塞和唤醒带来的性能问题</strong></p>
<p>CAS 相比之下是一种乐观方式，争用失败的线程不会被阻塞挂起。CompareAndSwap 函数会进行一次比较，比较内存中 object 的value 是否和预期的 expect （即最初获取到的 value）相等，如果相等，就证明没有其他线程改变过这个变量，就更新它为 update，否则就采用自旋的方式继续进行 CAS 操作</p>
<p>底层使用 JNI 调用 C 代码实现的，这个操作其实是 JNI 调用一个CPU指令完成的，所以具备<strong>原子性</strong></p>
<p>但是有 ABA 问题存在，就是变量初次读取的是 A 值，后来被改为 B，后来又被改为 A，CAS就会认为这个变量从来没被改变过</p>
<hr>
<h3 id="Java锁-3"><a href="https://www.cnblogs.com/myseries/p/12213997.html">Java锁 3</a></h3>
<p>主要是针对 synchronized 的锁优化</p>
<p>锁升级过程：无锁 -&gt; 偏向锁 -&gt; 轻量级锁 -&gt; 重量级锁</p>
<p><strong>自旋锁</strong></p>
<p>自旋锁的思想就是让线程在请求一个共享数据的锁时循环一段时间，如果在这段时间获取到了锁，就可以避免被阻塞。虽然能避免线程进入阻塞而减少开销，但是会占用CPU时间，所以适合那些锁定状态很短的共享数据。</p>
<p>JDK1.6引入了自适应的自旋锁，自旋次数不再固定，而是由上一次在该锁上的自旋次数和使用者的状态决定</p>
<p><strong>偏向锁</strong></p>
<p>就是让第一个获取锁对象的线程，在之后获取该锁时不要进行同步操作，甚至 CAS 也不需要。如果有第二个线程尝试去获取这个锁，偏向状态就结束</p>
<p><strong>轻量级锁</strong></p>
<p>轻量级锁使用 CAS 操作来避免使用互斥量的开销，先用 CAS 进行同步，失败再改用互斥量同步</p>
<p><strong>锁消除</strong></p>
<p>如果检测出共享数据不可能存在竞争，就把锁消除</p>
<p><strong>锁粗化</strong></p>
<p>如果有一串连续的操作对一个对象加锁解锁，就会把锁的范围扩大到整个序列之外，避免反复加锁解锁</p>
<p>synchronized的执行过程：</p>
<ol>
<li>检测Mark Word里面是不是当前线程的ID，如果是，表示当前线程处于偏向锁</li>
<li>如果不是，则使用CAS将当前线程的ID替换Mard Word，如果成功则表示当前线程获得偏向锁，置偏向标志位1</li>
<li>如果失败，则说明发生竞争，撤销偏向锁，进而升级为轻量级锁。</li>
<li>当前线程使用CAS将对象头的Mark Word替换为锁记录指针，如果成功，当前线程获得锁</li>
<li>如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。</li>
<li>如果自旋成功则依然处于轻量级状态。</li>
<li>如果自旋失败，则升级为重量级锁。</li>
</ol>
<p>作者：自负的鱼<br>
链接：<a href="https://www.jianshu.com/p/704eb56aa52a">https://www.jianshu.com/p/704eb56aa52a</a><br>
来源：简书<br>
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<hr>
<h3 id="线程创建-2"><a href="https://juejin.im/post/5d6e5d0be51d4561d54de9d9">线程创建 2</a></h3>
<ol>
<li>
<p>Thread 类</p>
<ul>
<li>继承 Thread 类并重写 run() 方法；</li>
<li>创建线程对象</li>
<li>调用该对象的 start() 方法启动线程</li>
</ul>
</li>
<li>
<p>Runnable 接口</p>
<ul>
<li>定义一个类实现 Runnable 接口，并重写接口中的 run() 方法</li>
<li>创建类实例，将其作为创建的 Thread 类的 target 参数， Thread 对象才是真正的线程对象</li>
<li>调用 Thread 对象的 start() 方法启动线程</li>
</ul>
</li>
<li>
<p>Callable 和 Future</p>
</li>
</ol>
<p><strong>Callable 接口提供了 call() 方法作为线程的执行体，相比 run() ，它可以有返回值，还可以抛出异常。Future 接口可以用来接受 call() 方法中的返回值。</strong></p>
<p><strong>Callable 不是 Runnable 子接口，不能作为 target 传入 Thread，RunnableFuture 接口解决了这个问题</strong>。它是 Future 接口和 Runnable 接口的子接口，该接口的实现类可以作为 target 参数传入。其中 <strong>FutureTask</strong> 就是官方的实现类，可以作为 target 参数</p>
<ul>
<li>定义一个类实现 Callable 接口，并重写 call() 方法</li>
<li>创建 Callable 实现类的实例，并用 FutureTask 类的实例包装</li>
<li>将 FutureTask 的实例作为 target 传入 Thread 对象, 并启动线程</li>
<li>调用 FutureTask 对象的 get() 方法获取返回值</li>
</ul>
<ol start="4">
<li>线程池</li>
</ol>
<p><strong>三种方法的区别</strong></p>
<p>采用 Runnable 和 Callable 接口实现</p>
<ul>
<li>Thread 只是实现了接口，还可以继承其他类</li>
<li>同一个 target 可以共享给多个线程，适合让多个线程操作同一份资源</li>
<li>线程池只能放入 Runnable 和 Callable 接口的实现类，不能放入 Thread 子类</li>
</ul>
<hr>
<h3 id="线程池参数-2"><a href="https://juejin.im/post/5d1882b1f265da1ba84aa676">线程池参数 2</a></h3>
<p>看这一篇就够了 <a href="https://juejin.im/post/5d1882b1f265da1ba84aa676">https://juejin.im/post/5d1882b1f265da1ba84aa676</a></p>
<hr>
<p><strong>线程池作用</strong></p>
<ul>
<li>线程池帮助<strong>管理线程</strong>，减少创建和销毁线程的资源损耗</li>
<li>任务到达<strong>直接从线程池取</strong>线程，相比创建线程<strong>响应更快</strong></li>
<li>线程用完再放回池子，可以<strong>复用</strong></li>
</ul>
<hr>
<p><strong>核心参数</strong></p>
<ul>
<li><strong>corePoolSize：</strong> 线程池核心线程数最大值</li>
<li><strong>maximumPoolSize：</strong> 线程池最大线程数大小（任务队列满后会创建非核心线程）</li>
<li><strong>keepAliveTime：</strong> 线程池中非核心线程空闲的存活时间大小</li>
<li><strong>unit：</strong> keepAliveTime 的时间单位</li>
<li><strong>workQueue：</strong> 存放任务的阻塞队列</li>
<li><strong>threadFactory：</strong> 用于设置创建线程的工厂，可以给创建的线程设置有意义的名字，可方便排查问题。</li>
<li><strong>handler：</strong>  线城池的饱和策略事件，主要有四种类型：默认直接抛异常；丢弃任务；</li>
</ul>
<p><strong>任务执行流程：</strong></p>
<ul>
<li>收到一个任务，先检查核心线程池是否已满，如过没满，创建核心线程执行任务</li>
<li>如果核心线程池满了，看队列是否满，如果没满，把任务放入队列</li>
<li>如果队列满了，查看线程池是否满了，如果没满，创建一个非核心线程执行任务</li>
<li>如果线程池也满了，无法执行任务</li>
</ul>
<hr>
<p>通过 ThreadPoolExcutor 创建线程池，<strong>常见的线程池</strong>有：</p>
<ul>
<li>
<p><strong>newFixedThreadPool</strong></p>
<p>一个<strong>线程数量固定</strong>的线程池，核心线程数和最大线程数一样</p>
<p>如果新任务提交时线程池中有空闲线程，就执行任务；如果没有，就放到一个任务队列中，等到线程空闲执行队列中的任务</p>
<p>使用了无界阻塞队列 <strong>LinkedBlockingQueue</strong> 如果任务越积越多，会导致内存飙升最后OOM</p>
<p><strong>适用于CPU密集型任务，适用于执行长期任务</strong></p>
</li>
<li>
<p><strong>newSingleThreadExcutor</strong></p>
<p><strong>只有一个线程</strong>的线程池，进入的任务按照一定顺序依次执行</p>
<p><strong>适用于需要串行执行任务的场景</strong></p>
</li>
<li>
<p><strong>newCachedThreadPool</strong></p>
<p>没有核心线程，收到任务先放入阻塞队列，如果池中有空闲线程就使用，没有就创建新线程，线程空闲60秒后会被销毁</p>
<p>因为没有线程数量限制，如果一次性有很多任务，会导致创建很多线程，内存飙升</p>
<p><strong>用于并发执行大量短期小任务</strong></p>
</li>
</ul>
<hr>
<h3 id="AQS">AQS</h3>
<p>AbstractQueuedSynchronizer 是一个在 JUC 之下用来实现锁和同步器的框架，它底层用了 CAS 技术来保证操作的原子性</p>
<p>内部实现的关键是</p>
<ul>
<li>用 volatile 修饰的 state 状态来保证可见性，表示同步状态，通过 getState 和 setState 来操作同步状态</li>
<li>用 FIFO 队列来实现进程间的竞争和等待</li>
<li>还提供了各种基于 CAS 的原子操作方法</li>
</ul>
<p>AQS 提供了独占锁 ReentrantLock 和 共享锁 semaphore 机制等</p>
<h3 id="JUC包下的类">JUC包下的类</h3>
<p>各种基本类型的原子类：AtomicInteger，AtomicLong，AtomicBoolean</p>
<p>线程安全的容器：CopyOnWriteArrayList，CocurrentHashMap，BlockingQueue等</p>
<ul>
<li><strong>CopyOnWriteArrayList</strong>：写操作在一个复制数组上进行，完成后将原数组指向新的复制数组。写操作需要加锁，防止并发写入导致数据丢失。<strong>缺陷</strong>是：增加内存占用，以及写操作的数据没有同步到读数组时，会导致读写不一致。</li>
</ul>
<p>一些锁：ReentrantLock</p>
<p>一些工具：Semaphore信号量</p>
<hr>
<h2 id="JVM">JVM</h2>
<h3 id="内存结构-6">内存结构 6</h3>
<hr>
<p><strong>内存结构</strong></p>
<p>公共部分为</p>
<ul>
<li>堆</li>
<li>方法区</li>
<li>直接内存</li>
</ul>
<p>线程私有的</p>
<ul>
<li>程序计数器</li>
<li>本地方法栈</li>
<li>虚拟机栈</li>
</ul>
<hr>
<p><strong>具体功能</strong></p>
<hr>
<p><strong>程序计数器</strong></p>
<p>记录的是正在执行的那条字节码指令的地址，不会出现OOM</p>
<ol>
<li>字节码解释器通过改变计数器的值来依次读取指令</li>
<li>多线程下，程序计数器记录当前线程的执行位置，切换回来之后能从上次的位置继续执行</li>
</ol>
<hr>
<p><strong>虚拟机栈</strong></p>
<p>Java 虚拟机栈为每个即将运行的 Java 方法创建一个栈帧，每个栈帧中中有局部变量表、操作数栈等信息。</p>
<p><strong>局部变量表</strong>随着栈帧的创建而创建，大小在编译时就确定，运行时大小不变，其中存放了<strong>8种基本数据类型</strong>和<strong>堆内存中对象的引用变量</strong></p>
<p>栈顶的栈帧是当前正在执行的方法对应的栈，只有这个栈帧中的局部变量能被操作数栈使用，如果方法中调用了新的方法，就压一个新栈在原来的栈之上，执行新栈；方法结束后，栈帧被移除，如果有返回值，会作为之后栈的操作数栈中的一个操作数</p>
<p><strong>会出现的问题</strong></p>
<ul>
<li>如果栈内存不能动态扩展，当线程请求栈的深度超出当前栈的最大深度时，会出现StackOverFlowError</li>
<li>如果栈内存可以扩展，但是线程请求时内存用完了，就会出现 OOM</li>
</ul>
<hr>
<p><strong>本地方法栈</strong></p>
<p>和虚拟机栈类似，区别是虚拟机栈是为 Java 方法服务，而本地方法栈是为本地方法服务。</p>
<hr>
<p><strong>堆</strong></p>
<p>是 Java 虚拟机管理内存中最大的一块，主要作用就是<strong>存放对象实例</strong>，几乎所有的对象实例和数组都在这里分配内存。这里也是<strong>垃圾回收的主要场所</strong>。</p>
<p><strong>分代就是在这块区域</strong>，可以被细分为新生代和老年代，分代是为了更好地回收内存，更快地分配内存</p>
<hr>
<p><strong>方法区</strong></p>
<p>方法区中主要存放已被加载的类信息，还存有常量、静态变量和 JIT 编译后的代码。</p>
<p>JDK 1.8 之后，方法区（永久代）被移除，原先的数据，被加载的类信息被放到元空间（使用直接内存）、静态变量和常量池被放入堆内存。</p>
<p><strong>运行时常量池</strong>是方法区的一部分，存放一些编译期间生成的<strong>字面量</strong>和<strong>类的符号引用</strong></p>
<p>符号引用就是字符串，通过这个字符串可以定位到指定数据，直接引用就是指向地址</p>
<hr>
<h3 id="垃圾回收-6">垃圾回收 6</h3>
<p>GC算法和垃圾收集器，GC如何分代，为什么要分代（根据分代使用不同的垃圾收集算法，提高内存回收的效率）</p>
<hr>
<p><strong>GC 分代</strong></p>
<p>分为<strong>新生代</strong>和<strong>老年代</strong></p>
<p><strong>新生代</strong>分为 Eden、From Survivor、To Survivor，Old Memory区属于<strong>老年代</strong></p>
<p>大多数对象在新生代Eden区分配内存，当Eden区内存不够时，虚拟机将发起一次<strong>Minor GC</strong></p>
<ul>
<li>Minor GC：回收新生代（包括Eden 和 Survivor），Minor GC 发生频繁，并且速度很快</li>
<li>Major / Full GC：回收老年代，速度很慢。发生 Full GC 往往是老年代空间不足（大对象进入老年代）或者出现分配担保失败</li>
</ul>
<p><strong>大对象直接进入老年代</strong>，避免在 Eden 和两个 Survivor 区发生大量内存拷贝，降低效率</p>
<p><strong>长期存活的对象进入老年代</strong>，每进行一次 Minor GC，存活下的对象年龄加1，当年龄大于晋升年龄，就被转移到老年区。晋升年龄因垃圾收集器的不同而不同。</p>
<p><strong>动态年龄判定</strong>，如果 Survivor 区中相同年龄的对象大小大于 Survivor 空间的一半，把年龄大于等于这个数字的对象都移入老年区</p>
<p><strong>空间分配担保</strong></p>
<p>在发生 Minor GC 之前，虚拟机先检查老年代最大连续空间是否大于新生代所有对象总空间，如果大于， Minor GC 可以确认安全</p>
<p>如果不成立，并且不允许分配担保，就会进行Full GC ；如果允许分配担保，会检查老年代连续内存空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次 Minor GC；如果小于，进行 Full GC</p>
<hr>
<p><strong>如何判断对象已经死亡</strong></p>
<ul>
<li>
<p><strong>引用计数法</strong></p>
<p>对象头维护一个计数器，被引用，计数器+1，引用失效，计数器-1，如果计数为0该对象就被判定无效</p>
<p>JVM 没有实现这个方法，因为无法解决循环引用，如果两个对象互相引用，就无法被回收</p>
</li>
<li>
<p><strong>可达性分析法</strong></p>
<p>以 GC Roots 为起点进行搜索，可达的对象都有效，不可达对象被回收</p>
<p>GC Roots 包括：</p>
<ul>
<li>虚拟机栈局部变量表引用的对象</li>
<li>本地方法栈JNI引用的对象</li>
<li>方法区类静态属性引用的对象</li>
<li>方法区常量引用的对象</li>
</ul>
<p>用finalize()方法可能可以自救（在该方法中使用 this 让这个对象重新被引用），如果finalize方法没有被重写，或者已经被执行过一次，就真的回收对象了。</p>
</li>
</ul>
<p><strong>回收方法区</strong></p>
<ul>
<li>
<p><strong>常量的回收</strong>：如果常量没有被引用，就会被清除</p>
</li>
<li>
<p><strong>类什么情况下会被回收</strong></p>
</li>
<li>
<p>该类的所有实例已被回收</p>
</li>
<li>
<p>加载该类的 classLoader已被回收</p>
</li>
<li>
<p>该类的Class对象没有被引用，无法通过反射访问该类的方法</p>
</li>
</ul>
<hr>
<p><strong>垃圾收集算法</strong></p>
<p><strong>标记-清除</strong></p>
<ul>
<li><strong>标记</strong>：遍历GC Roots，将可达的对象标记为存活对象</li>
<li><strong>清除</strong>：遍历堆中所有对象，将没有标记的对象清除，将标记过对象的标记清除</li>
<li><strong>不足</strong>：标记和清除的效率不高；会产生大量不连续的内存碎片</li>
</ul>
<p><strong>复制算法（新生代）</strong></p>
<ul>
<li>思想是把内存等分为两块，其中一块进行垃圾收集后，把存活的对象复制到另一块，清除原来的区域。但是这样可用内存减少了一半</li>
<li>在新生代中把内存分为三块区域，Eden， From Survivor，To Survivor，比例8:1:1. 每次使用Eden和其中一块Survivor，然后把存活的对象复制到另一块Survivor，清除剩余两块区域</li>
</ul>
<p><strong>标记-整理（老年代）</strong></p>
<ul>
<li><strong>标记</strong>：第一阶段也是遍历GC Roots，将存活的对象标记</li>
<li><strong>整理</strong>：将所有存活的对象向一端移动，按地址排序，然后把末端内存地址以后的内存全部回收</li>
</ul>
<p>因为老年代每次都会有大量对象存活，如果采用复制算法开销很大</p>
<p><strong>分代收集算法</strong></p>
<p><strong>新生代</strong>使用复制算法；<strong>老年代</strong>使用 标记-清除 或者 标记-整理 算法</p>
<hr>
<p><strong>垃圾收集器</strong></p>
<p><strong>Serial 收集器</strong></p>
<p>单线程进行垃圾收集，会暂停所有用户线程</p>
<p><strong>ParNew 收集器</strong></p>
<p>Serial的多线程版本</p>
<p><strong>Parallel Scavenge 收集器</strong></p>
<p>多线程，关注吞吐量</p>
<p><strong>Serial Old 收集器</strong></p>
<p>老年代版 Serial</p>
<p><strong>Parallel Old 收集器</strong></p>
<p>老年代版 Parallel Scavenge</p>
<p><strong>CMS收集器</strong></p>
<p>追求低停顿的收集器，在垃圾收集时使用户线程和GC线程并发执行，用户不会感到明显停顿</p>
<ul>
<li><strong>初始标记</strong>：Stop The World，仅对GC Roots直接关联的标记进行标记，速度很快</li>
<li><strong>并发标记</strong>：使用多条标记线程，与用户线程并发执行。进行可达性分析，标记所有可达对象，</li>
<li><strong>重新标记</strong>：重新标记<strong>新分配到老年代的对象</strong>以及<strong>并发阶段被修改了的对象</strong></li>
<li><strong>并发清除</strong>：开启用户线程，同时GC线程对未标记的区域进行清理</li>
</ul>
<p><strong>缺点</strong>是：吞吐量低；无法处理浮动垃圾；标记-清除算法会产生大量内存碎片</p>
<p><strong>吞吐量低</strong>是因为并发阶段，虽然不会导致用户线程停顿，但是因为 GC 线程占用了一部分 CPU 资源导致应用程序变慢，最后导致吞吐量降低</p>
<p><strong>浮动垃圾</strong>是因为并发清除阶段用户线程继续运行而产生的垃圾，这部分垃圾只能到下次GC时才能回收，因此收集器一般需要预留出20%的空间存放浮动垃圾。如果预留的空间不够存放浮动垃圾，会临时启用Serial Old进行垃圾清理。</p>
<p><strong><a href="https://juejin.im/entry/6844903603103072263">G1 收集器</a></strong></p>
<p>将堆划分为若干个大小相等的 Region，每格块中的内存是连续的。G1 中每个块也会充当Eden，Survivor，Old。跟踪每个区域垃圾堆积的价值大小，在后台维护一个优先列表，每次回收优先级最高（根据回收获得的空间大小和回收所需的时间得出）的区域</p>
<ul>
<li><strong>初始标记</strong>：标记 GC Roots 能直接关联到的对象，这一段需要 STW ，但其实是进行 Minor GC 的时候同步完成的，所以并没有额外停顿</li>
<li><strong>并发标记</strong>：</li>
<li><strong>最终标记</strong></li>
<li><strong>筛选回收</strong></li>
</ul>
<p>高吞吐，低停顿，基于标记整理算法，不会产生空间碎片</p>
<hr>
<h3 id="类加载-3">类加载 3</h3>
<p>类加载机制（过程、<strong>类加载器</strong>、类初始化、实例化），双亲委派</p>
<hr>
<p><strong>类加载</strong></p>
<p>包括 加载、验证、准备、解析、初始化5个阶段</p>
<p><strong>加载</strong></p>
<ul>
<li>通过类的完全限定名获取到定义该类的二进制字节流（class文件）</li>
<li>将二进制字节流代表的静态存储结构转化为方法区的运行时存储结构</li>
<li>在内存中生成一个代表该类的Class对象，用于作为方法区中该类各数据的访问入口</li>
</ul>
<p><strong>验证</strong></p>
<ul>
<li>确保 Class 文件的内容符合虚拟机规范</li>
</ul>
<p><strong>准备</strong></p>
<ul>
<li>为类变量分配内存和初始化值</li>
<li>普通类变量初始化值为零值，final类变量直接赋定义的值</li>
</ul>
<p><strong>解析</strong></p>
<ul>
<li>将运行时常量池的符号引用替换为直接引用的过程，也就是获得类或者方法在内存中的指针或者偏移量</li>
</ul>
<p><strong>初始化</strong></p>
<ul>
<li>初始化就是真正执行类中定义的 Java 程序代码，初始化静态变量的值，执行静态语句块</li>
</ul>
<p><strong>初始化的时机</strong></p>
<ul>
<li>遇到new，getstatic，putstatic，invokestatic这四条指令时</li>
<li>对类进行反射调用时</li>
<li>初始化一个类时发现父类还没有初始化时</li>
<li>虚拟机启动时先初始化包含main方法的类</li>
</ul>
<hr>
<p><strong>类加载器</strong></p>
<p>Java 中内置了三个类加载器</p>
<ul>
<li><strong>BootstrapClassLoader(启动类加载器)</strong> 最顶层的加载类，负责加载 JAVA_HOME/lib 下的类和jar包</li>
<li><strong>ExtensionClassLoader(扩展类加载器)</strong> 负责加载 JAVA_HOME/lib/ext 下的类和jar包</li>
<li><strong>AppClassLoader(应用程序类加载器)</strong> 面向用户的加载器，负责加载当前路径下的所有类和jar包</li>
</ul>
<hr>
<p><strong>双亲委派</strong></p>
<p><strong>要求除了顶层启动类加载器外，其余类加载器都要有自己的父类加载器</strong>（这里的父子关系不是继承关系，而是通过<strong>组合关系</strong>来复用父类加载器的代码）</p>
<p><strong>如果一个类加载器收到了类加载请求，会先把请求委托个父类加载器执行，如果父类加载器还有父类，就继续向上委托，最终都会到达启动类加载器。如果父类加载器能够完成加载，就成功返回，如果父类无法加载，子类才会尝试加载。</strong></p>
<p>使得同名类有优先级关系，上层加载器加载的类优先级更高，使用的就都是上层加载器加载的类。一个例子就是 Object 类。</p>
<p><strong>两个类相等，需要类本身相等，并且是由同一类加载器加载</strong></p>
<hr>
<p><strong>类实例化（Java 对象创建的过程）</strong></p>
<ol>
<li>
<p><strong>类加载检查</strong></p>
<p>一般通过 new 指令来创建对象，虚拟机遇见 new 指令时先根据指令参数看是否能在常量池中定位到某个类的符号引用，并且检查这个类是否已经被加载、解析和初始化。如果没有，会进行初始化过程。类加载完成后，会在堆中划分出一块内存，然后在这块内存上进行类的实例化。</p>
</li>
<li>
<p><strong>内存分配</strong></p>
<p>内存分配有两种方式，<strong>指针碰撞</strong>和<strong>空闲列表</strong>。这两种方式取决于堆内存是否规整，取决于垃圾收集器的算法是“<strong>标记-清除</strong>”还是“<strong>标记-整理</strong>”</p>
</li>
</ol>
<ul>
<li>
<p><strong>指针碰撞</strong>：内存是规整的，用过的放一边，没用过的放另一边，只要沿着没用过的地方将指针移动一个对象的大小就行</p>
</li>
<li>
<p><strong>空闲列表</strong>：内存不规整，但是虚拟机会维护一个列表记录哪些内存块可以用。内存分配时选择一块足够大的内存分配给对象，然后更新列表</p>
<p><strong>如何保证线程安全</strong>：</p>
<ul>
<li>采用 <strong>CAS + 失败重试</strong>，采用乐观的方式，假设没有冲突去完成某项操作，如果因为冲突失败，就重试</li>
<li><strong>TLAB</strong> 为每个线程在 Eden 区先分配一块内存，如果要为对象分配内存，先在 TLAB 尝试分配，这块内存不够时再使用上面的方法</li>
</ul>
</li>
</ul>
<ol start="3">
<li>
<p><strong>初始化零值</strong></p>
<p>将分配到的内存空间都赋0值，这样对象的实例字段在 Java 中不赋初值就可以使用</p>
</li>
<li>
<p><strong>设置对象头</strong></p>
<p>将 <strong>对象是哪个类的实例、对象的哈希码、GC分代年龄</strong> 等信息放入对象头</p>
</li>
<li>
<p><strong>执行 init 方法</strong></p>
<p>内存中的值全为0，将这块内存区域按照程序员的意愿进行初始化，才是一个真正可用的对象</p>
</li>
</ol>
<hr>
<p><strong>对象访问时是如何被找到的</strong></p>
<p><strong>句柄访问</strong>：Java堆中会划分出一块内存来作为句柄池，引用变量存储的就是对象的句柄地址，其中存放了实例数据和类数据各自的具体地址，由于不是直接访问，速度较慢</p>
<p><strong>直接指针</strong>：对象引用存储的就是对象在堆内存的地址，然后指向类信息的地址存放在对象地址中</p>
<hr>
<h3 id="四种引用类型">四种引用类型</h3>
<p><strong>强引用</strong>类似 Object obj = new Object() 就是强引用，只要强引用存在，被引用对象就永远不会被GC回收。但是如果<strong>错误保持了强引用</strong>，就会导致对象一直不会被回收。例如声明了static，只要类不被回收，引用就会一直存在。</p>
<p><strong>软引用</strong>相对强引用弱一些，只有内存不足时才会回收软引用对象。JVM会在抛出OutOfMemeryError之前回收软引用对象。<strong>软引用可以加速 JVM 对垃圾内存的回收速度。防止内存溢出</strong></p>
<p><strong>弱引用</strong>比软引用弱一些，JVM进行垃圾回收时，无论内存是否充足，都会回收弱引用指向的对象。</p>
<p><strong>虚引用</strong>是最弱的一种引用关系，有无弱引用的存在不会对对象的生存周期产生影响。只是用于跟踪对象被GC回收的活动。<strong>和前几个引用的区别是，虚引用必须要和引用队列一起使用，当GC准备回收一个对象，如果发现它还有虚引用，就会在回收之前把虚引用加入到引用队列中。程序通过判断引用队列中是否有虚引用，来了解被引用的对象是否要被回收，从而采取相应措施</strong></p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Junit 单元测试</title>
    <url>/2021/04/24/Junit-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<p>Junit 单元测试学习</p>
<span id="more"></span>
<h3 id="POM-依赖">POM 依赖</h3>
<p>在使用 IDEA 新建 SpringBoot 项目时一般会自动引入此依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br></pre></td></tr></table></figure>
<h3 id="测试类基类">测试类基类</h3>
<p>测试类文件夹和项目的 main 文件夹在同一层级<br>
测试类存放的位置和项目的 Application 类在同一相对目录下<br>
自动生成的测试类名称为 XXXApplicationTests<br>
在这个类下补齐所需要的注解，之后的测试类直接继承该类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest(classes = xxxApplication.class)</span></span><br><span class="line"><span class="meta">@WebAppConfiguration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">xxxApplicationTests</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开始测试-----------------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@After</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;测试结束-----------------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h3 id="测试类">测试类</h3>
<p>测试类继承测试基类<br>
通过 @Autowired 引入想要测试的类 DAO, Service ……</p>
<h3 id="测试方法">测试方法</h3>
<p>在真正的测试方法前要加上 @Test 注解<br>
加上 @Transactional 后方法会回滚，不会在数据库中产生脏数据<br>
如果想要跳过其中一个测试方法，在方法前加上 @Ignore(message) 即可忽略该方法</p>
<h4 id="Service-单元测试">Service 单元测试</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* value 是想要测试的变量值</span></span><br><span class="line"><span class="comment">* matcher statement 接收 value 并判断是否符合条件</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Assert.assertThat([value], [matcher statement]);</span><br></pre></td></tr></table></figure>
<h4 id="Assert-断言">Assert 断言</h4>
<h5 id="字符相关匹配符">字符相关匹配符</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* equalTo匹配符断言被测的testedValue等于expectedValue，</span></span><br><span class="line"><span class="comment">* equalTo可以断言数值之间，字符串之间和对象之间是否相等，相当于Object的equals方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">assertThat(testedValue, equalTo(expectedValue));</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* equalToIgnoringCase匹配符断言被测的字符串testedString</span></span><br><span class="line"><span class="comment">* 在忽略大小写的情况下等于expectedString</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">assertThat(testedString, equalToIgnoringCase(expectedString));</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* equalToIgnoringWhiteSpace匹配符断言被测的字符串testedString</span></span><br><span class="line"><span class="comment">* 在忽略头尾的任意个空格的情况下等于expectedString，</span></span><br><span class="line"><span class="comment">* 注意：字符串中的空格不能被忽略</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">assertThat(testedString, equalToIgnoringWhiteSpace(expectedString);</span><br><span class="line"><span class="comment">/**containsString匹配符断言被测的字符串testedString包含子字符串subString**/</span></span><br><span class="line">assertThat(testedString, containsString(subString) );</span><br><span class="line"><span class="comment">/**endsWith匹配符断言被测的字符串testedString以子字符串suffix结尾*/</span></span><br><span class="line">assertThat(testedString, endsWith(suffix));</span><br><span class="line"><span class="comment">/**startsWith匹配符断言被测的字符串testedString以子字符串prefix开始*/</span></span><br><span class="line">assertThat(testedString, startsWith(prefix));</span><br></pre></td></tr></table></figure>
<h5 id="一般匹配符">一般匹配符</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**nullValue()匹配符断言被测object的值为null*/</span></span><br><span class="line">assertThat(object,nullValue());</span><br><span class="line"><span class="comment">/**notNullValue()匹配符断言被测object的值不为null*/</span></span><br><span class="line">assertThat(object,notNullValue());</span><br><span class="line"><span class="comment">/**is匹配符断言被测的object等于后面给出匹配表达式*/</span></span><br><span class="line">assertThat(testedString, is(equalTo(expectedValue)));</span><br><span class="line"><span class="comment">/**is匹配符简写应用之一，is(equalTo(x))的简写，断言testedValue等于expectedValue*/</span></span><br><span class="line">assertThat(testedValue, is(expectedValue));</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* is匹配符简写应用之二，is(instanceOf(SomeClass.class))的简写，</span></span><br><span class="line"><span class="comment">* 断言testedObject为Cheddar的实例</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">assertThat(testedObject, is(Cheddar.class));</span><br><span class="line"><span class="comment">/**not匹配符和is匹配符正好相反，断言被测的object不等于后面给出的object*/</span></span><br><span class="line">assertThat(testedString, not(expectedString));</span><br><span class="line"><span class="comment">/**allOf匹配符断言符合所有条件，相当于“与”（&amp;&amp;）*/</span></span><br><span class="line">assertThat(testedNumber, allOf( greaterThan(<span class="number">8</span>), lessThan(<span class="number">16</span>) ) );</span><br><span class="line"><span class="comment">/**anyOf匹配符断言符合条件之一，相当于“或”（||）*/</span></span><br><span class="line">assertThat(testedNumber, anyOf( greaterThan(<span class="number">16</span>), lessThan(<span class="number">8</span>) ) );</span><br></pre></td></tr></table></figure>
<h5 id="数值相关匹配符">数值相关匹配符</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**closeTo匹配符断言被测的浮点型数testedDouble在20.0¡À0.5范围之内*/</span></span><br><span class="line">assertThat(testedDouble, closeTo( <span class="number">20.0</span>, <span class="number">0.5</span> ));</span><br><span class="line"><span class="comment">/**greaterThan匹配符断言被测的数值testedNumber大于16.0*/</span></span><br><span class="line">assertThat(testedNumber, greaterThan(<span class="number">16.0</span>));</span><br><span class="line"><span class="comment">/** lessThan匹配符断言被测的数值testedNumber小于16.0*/</span></span><br><span class="line">assertThat(testedNumber, lessThan (<span class="number">16.0</span>));</span><br><span class="line"><span class="comment">/** greaterThanOrEqualTo匹配符断言被测的数值testedNumber大于等于16.0*/</span></span><br><span class="line">assertThat(testedNumber, greaterThanOrEqualTo (<span class="number">16.0</span>));</span><br><span class="line"><span class="comment">/** lessThanOrEqualTo匹配符断言被测的testedNumber小于等于16.0*/</span></span><br><span class="line">assertThat(testedNumber, lessThanOrEqualTo (<span class="number">16.0</span>));</span><br></pre></td></tr></table></figure>
<h5 id="集合相关匹配符">集合相关匹配符</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**hasEntry匹配符断言被测的Map对象mapObject含有一个键值为&quot;key&quot;对应元素值为&quot;value&quot;的Entry项*/</span></span><br><span class="line">assertThat(mapObject, hasEntry(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;value&quot;</span> ) );</span><br><span class="line"><span class="comment">/**hasItem匹配符表明被测的迭代对象iterableObject含有元素element项则测试通过*/</span></span><br><span class="line">assertThat(iterableObject, hasItem (element));</span><br><span class="line"><span class="comment">/** hasKey匹配符断言被测的Map对象mapObject含有键值“key”*/</span></span><br><span class="line">assertThat(mapObject, hasKey (<span class="string">&quot;key&quot;</span>));</span><br><span class="line"><span class="comment">/** hasValue匹配符断言被测的Map对象mapObject含有元素值value*/</span></span><br><span class="line">assertThat(mapObject, hasValue(value));</span><br></pre></td></tr></table></figure>
<h4 id="Controller-单元测试">Controller 单元测试</h4>
<p>会用到 MockMvc，MockMvc 实现了对 HTTP 请求的模拟，可以不用启动工程来测试接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">xxxControllerTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span> </span><br><span class="line">    <span class="keyword">private</span> WebApplicationContext wac;</span><br><span class="line">    <span class="keyword">private</span> MockMvc mvc;</span><br><span class="line">    <span class="keyword">private</span> MockHttpSession session; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 使用 MockMvc 时要先使用 MockMvcBuilders 构建 MockMvc 对象</span></span><br><span class="line"><span class="comment">    * 加入 session 部分代码时因为拦截器那边会判断用户是否登录，所以注入一个用户</span></span><br><span class="line"><span class="comment">    * 如果修改了拦截器取消验证，可以不需要该部分代码</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setupMockMvc</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 初始化MockMvc对象</span></span><br><span class="line">        mvc = MockMvcBuilders.webAppContextSetup(wac).build(); </span><br><span class="line">        session = <span class="keyword">new</span> MockHttpSession();</span><br><span class="line">        User user =<span class="keyword">new</span> User(<span class="string">&quot;root&quot;</span>,<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        session.setAttribute(<span class="string">&quot;user&quot;</span>,user); </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * GET方法测试用例</span></span><br><span class="line"><span class="comment">     * mockMvc.perform 负责执行一个请求</span></span><br><span class="line"><span class="comment">     *     MockMvcRequestBuilders.get(&quot;/path&quot;) 构造一个请求，根据请求类型调用相应的方法</span></span><br><span class="line"><span class="comment">     *     contentType(MediaType.APPLICATION_JSON_UTF8) 代表发送端的数据格式为 application/json;charset=UTF-8</span></span><br><span class="line"><span class="comment">     *     accept(MediaType.APPLICATION_JSON_UTF8) 代表客户端希望接受的数据格式为 accept(MediaType.APPLICATION_JSON_UTF8)</span></span><br><span class="line"><span class="comment">     *     session.(session) 注入一个 session 来通过拦截器</span></span><br><span class="line"><span class="comment">     * ResultActions.andExpect 添加执行完成后的断言</span></span><br><span class="line"><span class="comment">     *    ResultActions.andExpect(MockMvcResultMatchers.status().isOk()) 查看请求返回的状态码是否为 200，如果不是，抛出异常，测试不通过</span></span><br><span class="line"><span class="comment">     *    ResultActions.andExpect(MockMvcResultMatchers.jsonPath(&quot;$.key1&quot;).value(&quot;value1&quot;)) 查看是否得到预期的返回值，如果不是，测试不通过</span></span><br><span class="line"><span class="comment">     *    ResultActions.andDo() 添加一个结果处理器, 比如 MockMvcResultHandlers.print() 输出整个响应结果信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getTest</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        mvc.perform(MockMvcRequestBuilders.get(<span class="string">&quot;/path&quot;</span>)</span><br><span class="line">                    .contentType(MediaType.APPLICATION_JSON_UTF8)</span><br><span class="line">                    .accept(MediaType.APPLICATION_JSON_UTF8)</span><br><span class="line">                    .session(session)</span><br><span class="line">            )</span><br><span class="line">           .andExpect(MockMvcResultMatchers.status().isOk())</span><br><span class="line">           .andExpect(MockMvcResultMatchers.jsonPath(<span class="string">&quot;$.key1&quot;</span>).value(<span class="string">&quot;value1&quot;</span>))</span><br><span class="line">           .andExpect(MockMvcResultMatchers.jsonPath(<span class="string">&quot;$.key2&quot;</span>).value(<span class="string">&quot;value2&quot;</span>))</span><br><span class="line">           .andDo(MockMvcResultHandlers.print());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="打包测试">打包测试</h3>
<p>用一个 TestSuits 类整理所有测试类然后打包执行测试方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by simba</span></span><br><span class="line"><span class="comment"> * Date 2021/2/2</span></span><br><span class="line"><span class="comment"> * Description:打包测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RunWith(Suite.class)</span></span><br><span class="line"><span class="meta">@Suite</span>.SuiteClasses(&#123;xxxTest.class,xxxTest2.class&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSuits</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//不用写代码，只需要注解即可</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="参考">参考</h3>
<p><a href="https://blog.csdn.net/weixin_39800144/article/details/79241620">https://blog.csdn.net/weixin_39800144/article/details/79241620</a><br>
<a href="http://tengj.top/2017/12/28/springboot12/#Service%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95">http://tengj.top/2017/12/28/springboot12/#Service单元测试</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>@RequestParam、@RequestBody 和 @ModelAttribute 的区别</title>
    <url>/2021/05/17/RequestParam%E3%80%81-RequestBody-%E5%92%8C-ModelAttribute-%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>三种注解的区别和使用场景</p>
<h3 id="RequestParam">@RequestParam</h3>
<p>用来处理 Content-Type 为 application/x-www-form-urlencoded 编码的内容<br>
GET 和 POST 请求的参数会自动赋值给 @RequestParam 注解的变量<br>
例如，@RequestParam(value=“username”) String userName 会直接将请求中名称为 username 变量的值赋值给 userName 参数<br>
如果不加该注解，则必须保证请求中的参数名与函数的参数名一致，即 函数中的参数要是 String username</p>
<h3 id="RequestBody">@RequestBody</h3>
<p>一般用来处理 HttpEntity 传来的 Content-Type 非 application/x-www-form-urlencoded 编码的数据</p>
<p>GET 请求没有 HttpEntity，所以 @RequestBody 不适用于 GET 请求<br>
POST 请求通过 HttpEntity 传输的参数，要在请求中声明 Content-Type 类型，Spring 会解析 HttpEntity 中的数据，并绑定到相应的 bean 上</p>
<h3 id="ModelAttribute">@ModelAttribute</h3>
<p>一般用于 GET 请求，将参数和 Model 对象参数绑定，变量名要和对象的属性值相对应</p>
<hr>
<p>前端使用 GET 或 POST 方式提交数据时，数据编码格式由请求头的 Content-Type 指定，分为以下几种情况：</p>
<ol>
<li>application/x-www-form-urlencoded，这种情况的数据@RequestParam、@ModelAttribute可以处理，@RequestBody也可以处理。</li>
<li>multipart/form-data，@RequestBody不能处理这种格式的数据。（form表单里面有文件上传时，必须要指定enctype属性值为multipart/form-data，意思是以二进制流的形式传输文件。）</li>
<li>application/json、application/xml等格式的数据，必须使用@RequestBody来处理。</li>
</ol>
<h3 id="参考">参考</h3>
<p><a href="https://www.cnblogs.com/zeroingToOne/p/8992746.html">@RequestParam、@RequestBody和@ModelAttribute区别</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot AOP 入门</title>
    <url>/2021/06/08/Spring-Boot-AOP-%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>本文展示了在 Spring Boot 项目中 AOP 的简单实现</p>
<h3 id="Pom-依赖">Pom 依赖</h3>
<p>为了实现 AOP，需要在项目中引入 <code>aspectjweaver</code> 和 <code>aspectjrt</code> 两个依赖，其中 <code>aspectjweaver</code> 是 aspectj 的织入包， <code>aspectjrt</code> 是 aspectj 的运行时包</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- AOP 依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjrt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="AOP-层类">AOP 层类</h3>
<p>在类上添加 <code>@Aspect</code> 注释表明这是一个 AOP 类，<code>@Component</code> 注释表明这个类可以作为一个 JavaBean 被注入到 Spring 容器中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ziqian.yudao.aop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution( * com.ziqian.yudao.controller.*.*(..)) &amp;&amp; @annotation(Login)&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cut</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;cut()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;已经记录下操作日志@Before 方法执行前&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(&quot;cut()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">around</span><span class="params">(ProceedingJoinPoint proceedingJoinPoint)</span> <span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;已经记录下操作日志@Around 方法执行前&quot;</span>);</span><br><span class="line">        Object object = proceedingJoinPoint.proceed();</span><br><span class="line">        System.out.println(<span class="string">&quot;已经记录下操作日志@Around 方法执行后&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After(&quot;cut()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;已经记录下操作日志@After 方法执行后&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>切入 AOP 代码需要一个切入点 PointCut，代码中 <code>@Pointcut(&quot;execution( * com.ziqian.yudao.controller.*.*(..)) &amp;&amp; @annotation(Login)&quot;)</code> 声明的切入点是 <code>com.ziqian.yudao.controller</code> 下面的类中的所有带有 <code>@Login</code> 注释的方法。也就是 AOP 代码会被插入到满足上述条件的方法中。引入注解作为触发 AOP 的条件后可以更方便地在需要的地方切入代码，声明注解的方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ziqian.yudao.aop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Login &#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">loginRequired</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在切入代码时我们也需要控制代码插入的位置，为此 Spring 提供了 <code>@Before</code>，<code>@After</code>，<code>@Around</code> 三个注解来帮助控制代码插入的大致位置。其中：</p>
<ul>
<li><code>@Before</code> 在所拦截方法执行前执行一段逻辑</li>
<li><code>@After</code> 在所拦截方法执行后执行一段逻辑</li>
<li><code>@Around</code> 可以同时在所拦截方法前后执行一段逻辑<br>
同样是在拦截方法的前后，三个注解也存在优先关系。为了搞清楚三者的先后关系，实现一个 http 接口进行测试</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ziqian.yudao.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.ziqian.yudao.aop.Login;</span><br><span class="line"><span class="keyword">import</span> com.ziqian.yudao.service.UserService;</span><br><span class="line"><span class="keyword">import</span> com.ziqian.yudao.vo.UserVO;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/users&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询用户列表</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 用户列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Login</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/list&quot;)</span> <span class="comment">// URL 修改成 /list</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;UserVO&gt; <span class="title">list</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 查询列表</span></span><br><span class="line">        UserVO user1 = <span class="keyword">new</span> UserVO(); user1.setId(<span class="number">1L</span>); user1.setUserName(<span class="string">&quot;yudaoyuanma&quot;</span>);</span><br><span class="line">        UserVO user2 = <span class="keyword">new</span> UserVO(); user2.setId(<span class="number">2L</span>); user2.setUserName(<span class="string">&quot;woshiyutou&quot;</span>);</span><br><span class="line">        UserVO user3 = <span class="keyword">new</span> UserVO(); user3.setId(<span class="number">3L</span>); user3.setUserName(<span class="string">&quot;chifanshuijiao&quot;</span>);</span><br><span class="line">        List&lt;UserVO&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        result.add(user1);</span><br><span class="line">        result.add(user2);</span><br><span class="line">        result.add(user3);</span><br><span class="line">        <span class="comment">// 返回列表</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后命令行的打印结果为：</p>
<blockquote>
<p>已经记录下操作日志@Around 方法执行前<br>
已经记录下操作日志@Before 方法执行前<br>
已经记录下操作日志@After 方法执行后<br>
已经记录下操作日志@Around 方法执行后</p>
</blockquote>
<p>可见 <code>@Around</code> 中的逻辑在最外层</p>
<blockquote>
<p>需要注意的是，<code>@Around</code> 注解下的 around() 方法中，proceedingJoinPoint.proceed(); 相当于切入的 list() 方法的方法体。如果 around() 的返回值为空，list() 对应的 /list 接口的返回值也为空。所以一定要为 around() 方法设定一个返回值。其中 Object object = proceedingJoinPoint.proceed(); 中的 obejct 对象就是原接口返回的值。</p>
</blockquote>
<h3 id="参考">参考</h3>
<p><a href="https://blog.csdn.net/fuck487/article/details/52593204">spring AOP @Around @Before @After 区别</a><br>
<a href="https://www.cnblogs.com/Andya/p/12685428.html">SpringBoot—集成AOP详解（面向切面编程Aspect）</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot 使用 @Scheduled 实现定时任务</title>
    <url>/2021/10/15/Spring-Boot-%E4%BD%BF%E7%94%A8-Scheduled-%E5%AE%9E%E7%8E%B0%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</url>
    <content><![CDATA[<p>最近有一个新项目需要写一个定时任务，因为没有涉及到复杂的功能需求，所以考虑仅使用 Spring 自带的 <code>@Scheduled</code> 注解实现</p>
<h3 id="Scheduled">@Scheduled</h3>
<p>基于注解实现定时任务的方式很简单，只需要在启动类前加上 <code>@EnableScheduling</code> 注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableScheduling</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(DemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在需要执行定时任务的方法前加上 <code>@Scheduled()</code> 注解，然后在括号内添加规则即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">每隔<span class="number">5</span>秒执行一次：*/<span class="number">5</span> * * * * ?</span><br><span class="line">每隔<span class="number">1</span>分钟执行一次：<span class="number">0</span> */<span class="number">1</span> * * * ?</span><br><span class="line">每天<span class="number">23</span>点执行一次：<span class="number">0</span> <span class="number">0</span> <span class="number">23</span> * * ?</span><br><span class="line">每天凌晨<span class="number">1</span>点执行一次：<span class="number">0</span> <span class="number">0</span> <span class="number">1</span> * * ?</span><br><span class="line">每月<span class="number">1</span>号凌晨<span class="number">1</span>点执行一次：<span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> * ?</span><br><span class="line">每天的<span class="number">0</span>点、<span class="number">13</span>点、<span class="number">18</span>点、<span class="number">21</span>点都执行一次：<span class="number">0</span> <span class="number">0</span> <span class="number">0</span>,<span class="number">13</span>,<span class="number">18</span>,<span class="number">21</span> * * ?</span><br><span class="line"></span><br><span class="line"><span class="meta">@Scheduled(cron = &quot;0 0 2 * * ?&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，通过 <code>@Scheduled</code> 实现的定时任务都是在一个线程中执行的，如果出现下一个定时任务开始时前一个还没有执行完的情况，下一个定时任务会阻塞直到前面的定时任务执行完。<br>
此外， <code>@Scheduled</code> 不支持分布式的情况，如果部署到集群上，多台机器都会执行定时任务。所以如果在分布式的情况下，需要通过分布式锁来保证只有一台机器执行定时任务。</p>
<h3 id="Retryable">@Retryable</h3>
<p>考虑到定时任务可能有执行失败的情况，执行失败后需要有重试机制。重试的最简单执行方式就是代码层面使用循环，为了保证业务逻辑的整洁，考虑在框架层面实现重试功能，所以选择使用 <code>@Retryable</code> 注解。<br>
首先需要添加相关依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.retry<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-retry<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后在项目启动类前添加 <code>@EnableRetry</code> 注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableScheduling</span></span><br><span class="line"><span class="meta">@EnableRetry</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(DemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在方法前加上 <code>@Retryable</code> 注解声明重试条件，当方法抛出对应异常后会触发重试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retryable</span>参数的意思说明</span><br><span class="line">value：抛出指定异常才会重试</span><br><span class="line">include：和value一样，默认为空，当exclude也为空时，默认所以异常</span><br><span class="line">exclude：指定不处理的异常</span><br><span class="line">maxAttempts：最大重试次数，默认<span class="number">3</span>次</span><br><span class="line">backoff：重试等待策略，默认使用<span class="meta">@Backoff</span>，<span class="meta">@Backoff</span>的value默认为<span class="number">1000L</span>，我们设置为<span class="number">2000L</span>；multiplier（指定延迟倍数）默认为<span class="number">0</span>，表示固定暂停<span class="number">1</span>秒后进行重试，如果把multiplier设置为<span class="number">1.5</span>，则第一次重试为<span class="number">2</span>秒，第二次为<span class="number">3</span>秒，第三次为<span class="number">4.5</span>秒。</span><br><span class="line"></span><br><span class="line"><span class="meta">@Retryable(value = Exception.class, maxAttempts = 3, backoff = @Backoff(delay = 2000L, multiplier = 1.5))</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>如果达到最大重试次数依然抛出异常，可以通过 <code>@Recover</code> 注解来配置回调方法，可以基于此实现报警等功能</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Recover</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">alert</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：重试方法和回调方法需要写在同一个 Java 文件中</p>
</blockquote>
<h3 id="TODO">TODO</h3>
<p>基于分布式锁让 <code>@Schedule</code> 兼容分布式<br>
基于线程池让定时任务并发执行</p>
<h3 id="参考">参考</h3>
<p><a href="https://www.cnblogs.com/juncaoit/p/11398547.html">011 @Retryable的使用 - 曹军 - 博客园</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven POM</title>
    <url>/2021/06/09/maven-pom/</url>
    <content><![CDATA[<p>只要提到 Maven 就离不开 pom.xml，POM 全称为 Project Object Model，这个文件在项目中常常是被用来配置各种需要用到的依赖，也可以配置不同环境下项目的参数信息。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span> = <span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span> = <span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span> = <span class="string">&quot;http://maven.apache.org/POM/4.0.0</span></span></span><br><span class="line"><span class="string"><span class="tag">    http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!-- 模型版本 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 公司或者组织的唯一标志，并且配置时生成的路径也是由此生成， 如com.companyname.project-group，maven会将该项目打成的jar包放本地路径：/com/companyname/project-group --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.companyname.project-group<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!-- 项目的唯一ID，一个groupId下面可能多个项目，就是靠artifactId来区分的 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>project<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!-- 版本号 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="基本元素">基本元素</h3>
<ul>
<li><code>project</code> 是 pom.xml 文件描述符的根</li>
<li><code>modelVersion</code> 指定 pom.xml 符合哪个版本的描述符，maven 2 和 3 只能为 4.0.0</li>
<li><code>parent</code> 用来表示当前 pom 文件继承自的父类 pom.xml 文件</li>
</ul>
<h3 id="依赖配置">依赖配置</h3>
<p><code>groupId</code>、<code>artifactId</code>、<code>version</code> 与基本配置中的意义相同<br>
maven 根据 groupId、artifactId 和 version 组成的 groupId:artifactId:version 来唯一识别一个 jar 包<br>
其中，<code>version</code> 表示一个项目的特定版本，在使用 maven 进行版本管理的时候有几个特殊的关键字：<br>
<code>snapshot</code> 快照，<code>alpha</code> 内部测试，<code>beta</code> 公测，<code>release</code> 稳定，<code>GA</code> 正式发布<br>
Scope 有 5 种可用的限定范围：</p>
<ul>
<li><code>compile</code>: maven 的默认范围，要求编译、测试、运行阶段都需要模块对应的 jar 包在 classpath 中</li>
<li><code>provided</code>: 模块对应的 jar 包在编译、测试的 classpath 中</li>
<li><code>runtime</code>: 模块对应的 jar 包在测试、运行时的 classpath 中</li>
<li><code>test</code>: 模块对应的 jar 包在测试的 classpath 中</li>
<li><code>system</code>: 模块对应的 jar 包在编译、测试的 classpath 中，与本机系统关联，可移植性差</li>
</ul>
<h3 id="继承">继承</h3>
<p>引入 <code>parent</code> 标签可以让当前 POM 继承自一个父 POM，父 POM 中包含一些公共依赖并统一管理这些依赖。如果需要改变公共依赖的版本信息，只需要修改父 POM 包，继承了父包的子 POM 都能同步该更新。</p>
<h3 id="参考">参考</h3>
<p><a href="https://juejin.cn/post/6844903824524574734">Maven 教程之 pom.xml 详解</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 避免重复添加记录</title>
    <url>/2021/05/10/mysql-%E9%81%BF%E5%85%8D%E9%87%8D%E5%A4%8D%E6%B7%BB%E5%8A%A0%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>如果不在 Service 层进行判断而是直接使用 INSERT 语句添加时</p>
<h3 id="唯一索引">唯一索引</h3>
<h4 id="查看当前表已有索引">查看当前表已有索引</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> `<span class="keyword">table</span>`</span><br></pre></td></tr></table></figure>
<h4 id="添加唯一索引">添加唯一索引</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> `<span class="keyword">table</span>` <span class="keyword">ADD</span> <span class="keyword">UNIQUE</span>(`<span class="keyword">column</span>`)</span><br></pre></td></tr></table></figure>
<h4 id="INSERT-语句">INSERT 语句</h4>
<p>加入 ignore 字段</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> IGNORE <span class="keyword">INTO</span> <span class="keyword">table</span>(value1, value2) <span class="keyword">values</span>(<span class="string">&#x27;value1&#x27;</span>, <span class="string">&#x27;value2&#x27;</span>);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>《冰菓》8-11话解读</title>
    <url>/2019/04/01/%E3%80%8A%E5%86%B0%E8%8F%93%E3%80%8B8-11%E8%AF%9D%E8%A7%A3%E8%AF%BB/</url>
    <content><![CDATA[<p>这一话的主线内容就是古典部部员被入须学姐拜托，在剧本还未完成的情况下，推断出剧中的凶手。这一个故事的主线是入须与折木之间的故事，结论我想只要看过的人应该都清楚了，最后被证明是入须利用了折木的推理才能，来帮助她在现有影片的基础上推断出一个满意的结局。</p>
<p>这一集主要的信息量都包含在聊天室中入须与本乡以及折木姐姐的聊天，还有折木与入须所有的单独对话当中。从这些文字中我们可以得知整个事情的时间线是：</p>
<blockquote>
<p>F班的同学决定拍剧，本乡被大家邀请写剧本 —&gt; 大家商讨剧情并投票，本乡以投票结果作为参考写剧本 —&gt; 演员根据部分剧本开拍，但本乡不在场 —&gt; 本乡发现剧情走向与剧本不同，但不敢说出口来让演员重拍 —&gt; 入须学姐接手，在聊天室打听并联系上古典社 —&gt; 在学姐诱导下，折木给出推理过程 —&gt; 学姐采纳，暑假期间完成整部片子 —&gt; 古典部员给出异议 —&gt; 折木发现被骗，推断出真正剧本</p>
</blockquote>
<span id="more"></span>
<p>可以看出这一个故事是少有的折木出现有推理错误的故事。失败的根本原因是将线索限制在影片本身，没有将影片之外的因素考虑进去。除此之外，还有一个原因是暑假期间知道这一推理结果的只有入须学姐，而入须学姐只关心结下来的剧情走向和结果，至于道具的准备，入须可能本就不知道，但是她肯定知道乡所写下的结局。所以她想要的只是在当前拍摄基础上的一个精彩的后续，而不是要折木推断是本乡的本意。所以这种情况也可以说是正如入须所愿。</p>
<p>此时如果知道很多细节的古典部其他三人在折木身边，肯定会让折木意识到没有考虑到的很多情况。</p>
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://i.loli.net/2019/08/09/3UjGrQDXAbstnq7.png">
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">忽略了本乡学姐的感情</div>
</center>
<p>还有一个很直接的原因是第一次在茶馆，入须给折木灌输了一种他是有这方面才能的人，而折木在这一过程中也接受了。这一后果就是折木不像以往只是谦虚的猜测一种可能性，而是认为事实一定是他说想的那样子的。所以在这种心境下他对剧本和电影有了不少的过度解读。</p>
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://i.loli.net/2019/08/09/hGPRntxCwkXBr5j.png">
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">出现过度解读</div>
</center>
<p>因为此时他已经把这部剧本当作是自己的来写下去了，而并没有考虑很多本乡学姐的想法。</p>
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://i.loli.net/2019/08/09/KwDLRQSCtIpPfgY.png">
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">不知不觉中成为了自己的剧本</div>
</center>
<p>所以折木虽然有推理方面的才能，但心智还是一个普通人，在种种不利条件之下，他就像塔罗牌的描述一样，被入须所驾驭了，成了入须的棋子。</p>
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://i.loli.net/2019/08/09/Rb8onV695i7fIGL.png">
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">折木所象征的塔罗牌「力量」被「女帝」征服</div>
</center>
<p>在动画中还有这样一个画面，也代表折木中了入须的圈套。</p>
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://i.loli.net/2019/08/09/3fyGjTnU5zYhQtX.png">
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">小鱼象征折木</div>
</center>
<p>所以说，这像作者的一个刻意安排，让折木处在了一个最糟糕的情况下，最终作出了一个错误的推断。</p>
<p>再来看看女帝这个人物，出身名门，也属于不愿服输的性格，这种条件促使她不允许自己失败。直到很后面折木的姐姐点名了，观众才知道入须从一开始的目的就是为了让自己接受的这个企划有一个很好的结局，并不管所谓的本乡的感情。在这件事上她只是要在不用本乡的剧本的前提下不伤害到本乡罢了。</p>
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://i.loli.net/2019/08/09/yQP6gr32wkxYFfV.png">
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">聊天室记录</div>
</center>
<p>她不希望电影是一个没有人死亡的结局，只希望在目前有人死亡的情况下有一个说得过去的，并且最好精彩的后续。从这一角度来看，折木最后推断的那个本乡所写的结局就会略显无意义，演员的素质也支撑不起那种感情戏，比折木所猜想的错误的结局给观众带来的冲击差远了。</p>
<p>所以要评价入须这个角色的话，她确实一开始就欺骗了别人，不管是姐姐，还是古典部，还是本乡。从一开始的聊天室她就说谎了，在第一次见到古典部时也是。</p>
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://i.loli.net/2019/08/09/Sv52C8eVj1MwJiT.png">
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;"></div>
</center>
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://i.loli.net/2019/08/09/qQNoyseZ1nUAhPY.png">
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">目的确实是为了写后续</div>
</center>
<p>这一部分是她强势性格的原因，即使是欺骗，也要动用一切资源，为了自己，将所接手的事情做好。</p>
<p>要说的话这一集剧情还是有一些复杂的，我做不到很好的分析。女帝这个角色全剧出现的次数并不多，尽管确实是利用了别人，但并不就能说她是一个坏的人，因为她没有做出什么伤天害理，无法挽回的坏事。她是一个利己主义者，只是我们有可能遇到的形形色色的人中的一个属性而已。</p>
<p>关于折木，这次被人利用的经历，会让他正视起自己的才能，也会让他更谨慎地使用这种才能。这里可以举一个例子就是后面的直升机一集，折木心里有了猜想之后亲自去图书馆验证，因为别人的死亡是不能够随意去揣测的。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title>Linux 常用命令</title>
    <url>/2021/04/22/Linux-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>收录工作中常用的 Linux 命令</p>
<blockquote>
<p>文件操作、服务器问题排查等</p>
</blockquote>
<span id="more"></span>
<h3 id="Linux-常用命令">Linux 常用命令</h3>
<h4 id="查看服务器信息">查看服务器信息</h4>
<h5 id="top">top</h5>
<p>查看 CPU 占用率</p>
<h5 id="free">free</h5>
<p>查看内存使用情况<br>
各项指标的意义如下：</p>
<ul>
<li>total：总表示物理内存的大小;</li>
<li>used：已使用的内存大小;</li>
<li>free：可用内存大小;</li>
<li>shared：多个进程共享的内存总额;</li>
<li>buff/cached：磁盘缓存的大小;</li>
<li>available：应用程序能使用的物理内存大小。</li>
</ul>
<h5 id="ps">ps</h5>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ps -ef | grep svn     # 查看指定进程</span><br></pre></td></tr></table></figure>
<h5 id="查看磁盘使用情况">查看磁盘使用情况</h5>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">df -h</span><br></pre></td></tr></table></figure>
<h4 id="文件操作">文件操作</h4>
<h5 id="tail-查看日志">tail 查看日志</h5>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tail -fn 1000 xxx.log    # 循环实时查看最后 1000 条记录</span><br></pre></td></tr></table></figure>
<h5 id="ls">ls</h5>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls -lh    # 列出显示文件详细信息</span><br><span class="line">ls -lrS     # 按大小反序显示文件详细信息</span><br><span class="line">ls -l t*    # 列出当前目录中所有以&quot;t&quot;开头的目录的详细内容 </span><br></pre></td></tr></table></figure>
<h5 id="I-O-信息">I/O 信息</h5>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iostat -d -k 1 10       #查看TPS和吞吐量信息</span><br><span class="line">iostat -d -x -k 1 10    #查看设备使用率（%util）、响应时间（await）</span><br><span class="line">iostat -c 1 10          #查看cpu状态</span><br><span class="line"></span><br><span class="line">指标</span><br><span class="line"><span class="meta">%</span><span class="bash">iowait：每一个IO请求的处理的平均时间（单位是毫秒），这里可以理解为IO的响应时间，一般地系统IO响应时间应该低于5ms，如果大于10ms就比较大了。</span> </span><br><span class="line">kB_read/s：每秒读K字节数 </span><br><span class="line">kB_wrtn/s ：每秒写K字节数 </span><br><span class="line">r/s： 每秒完成的读 I/O 设备次数。即 delta（rio）/s </span><br><span class="line">w/s： 每秒完成的写 I/O 设备次数。即 delta（wio）/s </span><br><span class="line">rsec/s： 每秒读扇区数。即 delta（rsect）/s </span><br><span class="line">wsec/s： 每秒写扇区数。即 delta（wsect）/s </span><br><span class="line">tps：该设备每秒的传输次数 ，“一次传输”意思是“一次I/O请求”。多个逻辑请求可能会被合并为“一次I/O请求”。</span><br></pre></td></tr></table></figure>
<h5 id="du-查看文件-文件夹大小">du 查看文件/文件夹大小</h5>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">du -sh * | sort -hr # 列出文件夹下所有文件大小并降序排序</span><br><span class="line">du -b /home         # 以字节为单位显示/home 文件夹下各个子文件夹的大小</span><br><span class="line">du -h ./            # 以mb为单位显示当前 文件夹下各个子文件夹的大小</span><br><span class="line">du -ks /home        # 以千字节KB 为单位显示/home 文件夹的总大小 </span><br></pre></td></tr></table></figure>
<h5 id="找出最大的-5-个目录">找出最大的 5 个目录</h5>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">du -hm / --max-depth=1 | sort -nr | head -5 </span><br></pre></td></tr></table></figure>
<h4 id="查询操作">查询操作</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">which     # 查看可执行文件的位置。</span><br><span class="line">whereis   # 查看文件的位置。</span><br><span class="line">locate    # 配合数据库查看文件位置。</span><br><span class="line">find      # 实际搜寻硬盘查询文件名称。</span><br></pre></td></tr></table></figure>
<h5 id="which">which</h5>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">which     # 搜索某个 系统命令/可执行文件 的路径</span><br></pre></td></tr></table></figure>
<h5 id="whereis">whereis</h5>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 只能用于程序名的搜索</span></span><br><span class="line">-b   # 定位可执行文件。</span><br><span class="line">-m   # 定位帮助文件。</span><br><span class="line">-s   # 定位源代码文件。</span><br><span class="line">-u   # 搜索默认路径下除可执行文件、源代码文件、帮助文件以外的其它文件。</span><br></pre></td></tr></table></figure>
<h5 id="find">find</h5>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find -atime -2         # 查找 48 小时内修改过的文件</span><br><span class="line">find ./ -name &#x27;*.log&#x27;  # 在当前目录查找 以 .log 结尾的文件。 . 代表当前目录</span><br><span class="line">find -size +1000c      # 查找大于 1K 的文件</span><br></pre></td></tr></table></figure>
<h4 id="用户操作">用户操作</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo -s                # 切换到 root 用户</span><br><span class="line">sudo su username       # 切换用户</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>效率</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>《高并发架构设计入门》笔记</title>
    <url>/2021/08/10/%E3%80%8A%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%85%A5%E9%97%A8%E3%80%8B%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="高性能的5大设计思想">高性能的5大设计思想</h3>
<h5 id="扩展">扩展</h5>
<p><strong>垂直扩展-针对单台机器</strong></p>
<ul>
<li>扩容机器，增加配置</li>
<li>分表，减少数据量</li>
<li>无锁，减少锁竞争</li>
</ul>
<p><strong>水平扩展-多机器均衡</strong></p>
<ul>
<li>nginx 负载均衡</li>
<li>无状态</li>
<li>分布式</li>
</ul>
<h5 id="缓存">缓存</h5>
<p>数据前置，开辟新的数据交换区，解决原始数据获取代价太大的问题</p>
<p>常用缓存策略：CDN 静态数据、热点数据缓存、服务缓存 Redis、内存缓存、数据库缓存、分布式缓存</p>
<p>缓存不一致：捕捉更新结果，如果失败就重试；</p>
<h5 id="分离">分离</h5>
<p>动静分离、读写分离、主从主备、冷热分离</p>
<h5 id="异步">异步</h5>
<p>消息队列，削峰填谷，解耦</p>
<h5 id="复用">复用</h5>
<p>线程池、连接池复用，减少资源创建销毁的时间</p>
<h3 id="高可用的5大设计思想">高可用的5大设计思想</h3>
<h5 id="隔离">隔离</h5>
<ul>
<li>核心/非核心服务隔离部署</li>
<li>机房隔离</li>
<li>读写隔离</li>
</ul>
<h5 id="限流">限流</h5>
<p>识别恶意流量</p>
<ul>
<li>接入层限流：nginx</li>
<li>应用层限流：队列满后丢弃后续数据</li>
<li>分布式限流</li>
</ul>
<h5 id="降级">降级</h5>
<ul>
<li>有损服务：系统繁忙页面</li>
<li>熔断</li>
<li>保底：出现异常时的保底策略</li>
</ul>
<h5 id="超时和失败重试">超时和失败重试</h5>
<h5 id="可回滚">可回滚</h5>
<p>事务、版本、数据的可回滚，保证及时解决数据问题</p>
<h5 id="保障手段">*保障手段</h5>
<p>压测、应急预案演练（多机房容灾等）、线上监控报警</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>架构</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>使用ShardingSphere需要注意的问题</title>
    <url>/2021/06/24/%E4%BD%BF%E7%94%A8ShardingSphere%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="问题1">问题1</h3>
<p>在配置文件中 datasource 的数据源名称设置为 yudao_orders_0 时出现如下错误</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Caused by: org.springframework.boot.context.properties.source.InvalidConfigurationPropertyNameException: Configuration property name &#x27;spring.shardingsphere.datasource.yudao_orders_0&#x27; is not valid</span><br></pre></td></tr></table></figure>
<p>原因是配置文件中的 datasource 的命名中不能带下划线，改为 yudao-orders-0 即可</p>
<h3 id="问题2">问题2</h3>
<p>在 application.yaml 中配置 type 字段，即连接池类型时，如果选择的是 Druid，要注意 maven 依赖<br>
pom.xml 文件中 druid-spring-boot-starter  和 sharding-jdbc-spring-boot-starter 不能同时出现</p>
<ol>
<li>因为数据连接池的starter（比如druid）可能会先加载并且其创建一个默认数据源，这将会使得ShardingSphere-JDBC创建数据源时发生冲突。<br>
解决方法有2种：</li>
<li>在启动类中排除 Druid 自动配置类<code>@SpringBootApplication(exclude = &#123;DruidDataSourceAutoConfigure.class&#125;)</code></li>
<li>将 druid-spring-boot-starter 依赖替换为纯 Druid，如下</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.22<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="问题3">问题3</h3>
<p>读写分离配置时注意配置的名称，其中的 <code>slave-data-source-names</code>最后有个<code>s</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">shardingsphere:</span></span><br><span class="line">        <span class="attr">masterslave:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">ms</span> <span class="comment"># 名字，任意，需要保证唯一</span></span><br><span class="line">        <span class="attr">master-data-source-name:</span> <span class="string">ds-master</span> <span class="comment"># 主库数据源</span></span><br><span class="line">        <span class="attr">slave-data-source-names:</span> <span class="string">ds-slave-1,</span> <span class="string">ds-slave-2</span> <span class="comment"># 从库数据源</span></span><br></pre></td></tr></table></figure>
<h3 id="问题4">问题4</h3>
<p>Shardingsphere 4.1.1 和 Swagger 2.9.2 存在冲突<br>
Swagger 2.9.2 依赖于 Guava 20.0 以上的版本，但是 Shardingsphere 4.1.1 中引入的是 Guava 18.0 版本，所以启动项目时会导致以下错误</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Caused by: org.springframework.context.ApplicationContextException: Failed to start bean &#x27;documentationPluginsBootstrapper&#x27;; nested exception is com.google.common.util.concurrent.ExecutionError: java.lang.NoSuchMethodError: com.google.common.collect.FluentIterable.concat(Ljava/lang/Iterable;Ljava/lang/Iterable;)Lcom/google/common/collect/FluentIterable;</span><br><span class="line">        at org.springframework.context.support.DefaultLifecycleProcessor.doStart(DefaultLifecycleProcessor.java:176)</span><br><span class="line">        at org.springframework.context.support.DefaultLifecycleProcessor.access$200(DefaultLifecycleProcessor.java:50)</span><br><span class="line">        at org.springframework.context.support.DefaultLifecycleProcessor$LifecycleGroup.start(DefaultLifecycleProcessor.java:346)</span><br><span class="line">        at org.springframework.context.support.DefaultLifecycleProcessor.startBeans(DefaultLifecycleProcessor.java:149)</span><br><span class="line">        at org.springframework.context.support.DefaultLifecycleProcessor.onRefresh(DefaultLifecycleProcessor.java:112)</span><br><span class="line">        at org.springframework.context.support.AbstractApplicationContext.finishRefresh(AbstractApplicationContext.java:880)</span><br><span class="line">        at org.springframework.boot.context.embedded.EmbeddedWebApplicationContext.finishRefresh(EmbeddedWebApplicationContext.java:144)</span><br><span class="line">        at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:546)</span><br><span class="line">        at org.springframework.boot.context.embedded.EmbeddedWebApplicationContext.refresh(EmbeddedWebApplicationContext.java:122)</span><br><span class="line">        at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:693)</span><br><span class="line">        at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:360)</span><br><span class="line">        at org.springframework.boot.SpringApplication.run(SpringApplication.java:303)</span><br><span class="line">        at org.springframework.boot.test.context.SpringBootContextLoader.loadContext(SpringBootContextLoader.java:120)</span><br><span class="line">        at org.springframework.test.context.cache.DefaultCacheAwareContextLoaderDelegate.loadContextInternal(DefaultCacheAwareContextLoaderDelegate.java:98)</span><br><span class="line">        at org.springframework.test.context.cache.DefaultCacheAwareContextLoaderDelegate.loadContext(DefaultCacheAwareContextLoaderDelegate.java:116)</span><br><span class="line">        ... 25 more</span><br></pre></td></tr></table></figure>
<p>手动引入 20.0 版本的 Guava 后可以解决该问题</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 主要因为 shardingsphere 中默认的 guava 依赖版本是 18.0 和 swagger 2.9.2 冲突，所以手动引入 20.0 版本的 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.guava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>guava<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>20.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="参考">参考</h3>
<p><a href="https://shardingsphere.apache.org/document/current/cn/faq/#20-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%85%8D%E7%BD%AE%E4%BA%86%E6%9F%90%E4%B8%AA%E6%95%B0%E6%8D%AE%E8%BF%9E%E6%8E%A5%E6%B1%A0%E7%9A%84spring-boot-starter%E6%AF%94%E5%A6%82druid%E5%92%8Cshardingsphere-jdbc-spring-boot-starter%E6%97%B6%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E4%BC%9A%E6%8A%A5%E9%94%99">FAQ :: ShardingSphere</a><br>
<a href="https://my.oschina.net/u/1046143/blog/3216500">【ShardingSphere】2. Spring Boot整合Sharding-JDBC实现读写分离 - 贺小康的个人空间 - OSCHINA - 中文开源技术交流社区</a><br>
<a href="https://juejin.cn/post/6844903857835737095">SpringBoot 2.x ShardingSphere读写分离实战</a></p>
]]></content>
      <categories>
        <category>问题</category>
      </categories>
      <tags>
        <tag>Sharding</tag>
        <tag>读写分离</tag>
      </tags>
  </entry>
  <entry>
    <title>基于 rsync 实现文件远程同步</title>
    <url>/2021/10/18/%E4%BD%BF%E7%94%A8rsync%E4%BC%A0%E8%BE%93%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<p>两台机器之间同步文件常用的方式有 <code>scp</code> 和 <code>rsync</code> 两种，两者的主要区别在于：</p>
<ul>
<li><code>scp</code> 会将整个文件进行传输；<code>rsync</code> 只对差异文件做更新（通过比较最后修改时间和文件的大小），支持分块传输，可以只传输修改的部分</li>
<li><code>scp</code> 是加密传输；<code>rsync</code> 不是加密传输</li>
</ul>
<p>在项目中我使用的是 <code>rsync --daemon</code> 的方式进行文件同步，这种方式需要在目标同步机器上的 <code>rsyncd.conf</code> 配置文件中配置模块名，存储路径等信息。具体配置方法参考：<a href="https://blog.csdn.net/imliuqun123/article/details/85232769">参考</a></p>
<p>我的测试用例中使用的配置项是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uid = 0 </span><br><span class="line">gid = 0</span><br><span class="line">pid file = /var/run/rsyncd.pid</span><br><span class="line">log file = /var/log/rsyncd.log </span><br><span class="line"></span><br><span class="line">[user]</span><br><span class="line">path=/data</span><br><span class="line">ignore errors = yes # 忽略IO问题</span><br><span class="line">read only = no </span><br><span class="line">use chroot = no # 连接时可以不需要root权限</span><br><span class="line">list = yes #当客户请求列出可以使用的模块列表时，该模块可以被列出</span><br></pre></td></tr></table></figure>
<p>模块名称为 <code>user</code> ，文件的默认保存路径为 <code>/data</code><br>
服务器通过 <code>rsync --daemon</code> 启动守护进程</p>
<p>在另一台机器上通过指令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rsync -avz [local_path] [server_address]::user</span><br></pre></td></tr></table></figure>
<p>可以将<code>local_path</code>目录下的文件增量写入到目标服务器的<code>/data</code>目录下</p>
<h3 id="参考">参考</h3>
<p><a href="https://blog.csdn.net/imliuqun123/article/details/85232769">【Linux】rsync 守护进程的配置</a><br>
<a href="https://www.cnblogs.com/kevingrace/p/8529792.html">SCP和Rsync远程拷贝的几个技巧</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Rsync</tag>
      </tags>
  </entry>
  <entry>
    <title>基于 Canel 数据实时同步到 Redis</title>
    <url>/2021/06/22/%E5%9F%BA%E4%BA%8E-Canel-%E6%95%B0%E6%8D%AE%E5%AE%9E%E6%97%B6%E5%90%8C%E6%AD%A5%E5%88%B0-Redis/</url>
    <content><![CDATA[<h3 id="简介">简介</h3>
<p>最近一个业务中，要求 Redis 中的数据和 MySQL 中的数据保持较高的一致性，如果缓存和数据库内容不一致，就会导致客户端出现一些问题。针对这个问题，该项目打算使用的解决办法是通过读取 binlog 并进行解析，将解析后的信息放入 MQ 中，然后专门提供一个服务消费 MQ 中的信息，将更新操作同步到 Redis，实现 Redis 和 MySQL 数据的一致性。<br>
阿里刚好提供了开源工具 canal 能够实现读取 binlog 并解析的功能，这篇文章记录了使用 Canal 实现两个数据库消息同步的简单 demo，消息队列中间件使用的是 Kafka。</p>
<h3 id="前期配置">前期配置</h3>
<h4 id="MySQL-开启-binlog-日志主从同步">MySQL 开启 binlog 日志主从同步</h4>
<p>因为 Canal 是伪装成从服务来监听 MySQL 的 binlog，所以首先需要让 MySQL 允许 binlog 日志主从同步</p>
<ol>
<li>本机上的 MySQL 是以 Docker 容器的方式运行的，通过以下命令打开并编辑 MySQL 的配置文件</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec -it 71cd220d1f8eef6df43ece34b6b38fe480791c82f3ac434b903fc25b06933384 /bin/sh</span><br><span class="line">vim etc/mysql/mysql.conf.d/mysqld.cnf</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>在 <code>[mysqld]</code>标签下添加以下内容</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">log-bin         = /var/lib/mysql/mysql-bin #日志记录到指定位置</span><br><span class="line">binlog-format   = ROW #记录只要数据发生修改,就记录到日志中</span><br><span class="line">server_id       = 1 #mysql主从复制的唯一id,不允许重复</span><br></pre></td></tr></table></figure>
<p>重启 MySQL 后可以进入 MySQL 输入以下语句查看 binlog 日志主从同步是否生效</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%log_bin%&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; show variables like &#x27;%log_bin%&#x27;;</span><br><span class="line">+---------------------------------+--------------------------------+</span><br><span class="line">| Variable_name                   | Value                          |</span><br><span class="line">+---------------------------------+--------------------------------+</span><br><span class="line">| log_bin                         | ON                             |</span><br><span class="line">| log_bin_basename                | /var/lib/mysql/mysql-bin       |</span><br><span class="line">| log_bin_index                   | /var/lib/mysql/mysql-bin.index |</span><br><span class="line">| log_bin_trust_function_creators | OFF                            |</span><br><span class="line">| log_bin_use_v1_row_events       | OFF                            |</span><br><span class="line">| sql_log_bin                     | ON                             |</span><br><span class="line">+---------------------------------+--------------------------------+</span><br><span class="line">6 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure>
<p>可以看到 log_bin 为 ON 就是成功开启<br>
3. 最后，还要为 MySQL 添加一个 canal 用户并授予相应权限，canal 才能监听日志</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;canal&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;canal&#x27;</span>;</span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">all</span> privileges <span class="keyword">on</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">to</span> <span class="string">&#x27;canal&#x27;</span>@<span class="string">&#x27;%&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;canal&#x27;</span>;</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure>
<h4 id="Canal-配置并运行">Canal 配置并运行</h4>
<blockquote>
<p>Canal 仓库的 Github 地址为：<a href="https://github.com/alibaba/canal">https://github.com/alibaba/canal</a><br>
最初尝试直接 docker 拉取镜像运行容器，但是尝试了很多次，能监听到 canal-server 服务，但是服务无法监听到 binlog，最后还是改为宿主机本地运行 canal-server 服务。</p>
</blockquote>
<ol>
<li>下载 canal-deployer 代码，此处是使用的最新的 1.1.5 版本</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://github.com/alibaba/canal/releases/download/canal-1.1.5/canal.deployer-1.1.5.tar.gz</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>创建文件夹</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir canal-server</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>解压到新建文件夹下</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -zxvf canal.deployer-1.1.5.tar.gz -C canal-server/</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>修改 instance.properties 配置</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim conf/example/instance.properties</span><br></pre></td></tr></table></figure>
<p>需要修改的内容为</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#################################################</span></span><br><span class="line"><span class="comment">## mysql serverId , v1.0.26+ will autoGen</span></span><br><span class="line"><span class="comment"># canal.instance.mysql.slaveId=0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># enable gtid use true/false</span></span><br><span class="line"><span class="string">canal.instance.gtidon=false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># position info</span></span><br><span class="line"><span class="string">canal.instance.master.address=127.0.0.1:3306</span>    <span class="comment"># 此处为运行 MySQL 的 IP 地址</span></span><br><span class="line"><span class="string">canal.instance.master.journal.name=</span></span><br><span class="line"><span class="string">canal.instance.master.position=</span></span><br><span class="line"><span class="string">canal.instance.master.timestamp=</span></span><br><span class="line"><span class="string">canal.instance.master.gtid=</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># rds oss binlog</span></span><br><span class="line"><span class="string">canal.instance.rds.accesskey=</span></span><br><span class="line"><span class="string">canal.instance.rds.secretkey=</span></span><br><span class="line"><span class="string">canal.instance.rds.instanceId=</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># table meta tsdb info</span></span><br><span class="line"><span class="string">canal.instance.tsdb.enable=true</span></span><br><span class="line"><span class="comment">#canal.instance.tsdb.url=jdbc:mysql://127.0.0.1:3306/canal_tsdb</span></span><br><span class="line"><span class="comment">#canal.instance.tsdb.dbUsername=canal</span></span><br><span class="line"><span class="comment">#canal.instance.tsdb.dbPassword=canal</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#canal.instance.standby.address =</span></span><br><span class="line"><span class="comment">#canal.instance.standby.journal.name =</span></span><br><span class="line"><span class="comment">#canal.instance.standby.position =</span></span><br><span class="line"><span class="comment">#canal.instance.standby.timestamp =</span></span><br><span class="line"><span class="comment">#canal.instance.standby.gtid=</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># username/password</span></span><br><span class="line"><span class="string">canal.instance.dbUsername=canal</span>     <span class="comment"># 数据库 canal 的用户名，可以监听 binlog 日志</span></span><br><span class="line"><span class="string">canal.instance.dbPassword=canal</span>     <span class="comment"># 数据库 canal 的密码</span></span><br><span class="line"><span class="string">canal.instance.connectionCharset</span> <span class="string">=</span> <span class="string">UTF-8</span></span><br><span class="line"><span class="comment"># enable druid Decrypt database password</span></span><br><span class="line"><span class="string">canal.instance.enableDruid=false</span></span><br><span class="line"><span class="comment">#canal.instance.pwdPublicKey=MFwwDQYJKoZIhvcNAQEBBQADSwAwSAJBALK4BUxdDltRRE5/zXpVEVPUgunvscYFtEip3pmLlhrWpacX7y7GCMo2/JM6LeHmiiNdH1FWgGCpUfircSwlWKUCAwEAAQ==</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># table regex</span></span><br><span class="line"><span class="string">canal.instance.filter.regex=.*\\..*</span> <span class="comment"># 监听所有数据库</span></span><br><span class="line"><span class="comment"># table black regex</span></span><br><span class="line"><span class="string">canal.instance.filter.black.regex=mysql\\.slave_.*</span></span><br><span class="line"><span class="comment"># table field filter(format: schema1.tableName1:field1/field2,schema2.tableName2:field1/field2)</span></span><br><span class="line"><span class="comment">#canal.instance.filter.field=test1.t_product:id/subject/keywords,test2.t_company:id/name/contact/ch</span></span><br><span class="line"><span class="comment"># table field black filter(format: schema1.tableName1:field1/field2,schema2.tableName2:field1/field2)</span></span><br><span class="line"><span class="comment">#canal.instance.filter.black.field=test1.t_product:subject/product_image,test2.t_company:id/name/contact/ch</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># mq config</span></span><br><span class="line"><span class="string">canal.mq.topic=canaltopic</span>   <span class="comment"># 监听的 kafka topic 名称</span></span><br><span class="line"><span class="comment"># dynamic topic route by schema or table regex</span></span><br><span class="line"><span class="comment">#canal.mq.dynamicTopic=mytest1.user,mytest2\\..*,.*\\..*</span></span><br><span class="line"><span class="string">canal.mq.partition=0</span></span><br><span class="line"><span class="comment"># hash partition config</span></span><br><span class="line"><span class="comment">#canal.mq.partitionsNum=3</span></span><br><span class="line"><span class="comment">#canal.mq.partitionHash=test.table:id^name,.*\\..*</span></span><br><span class="line"><span class="comment">#canal.mq.dynamicTopicPartitionNum=test.*:4,mycanal:6</span></span><br><span class="line"><span class="comment">#################################################</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol start="5">
<li>修改完成后进入 bin 目录，启动服务</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd ../../bin</span><br><span class="line">./startup.sh</span><br></pre></td></tr></table></figure>
<h4 id="Kafka-安装并运行">Kafka 安装并运行</h4>
<ol>
<li>Mac 上直接使用 Homebrew 进行 ZooKeeper 和 Kafka 的安装</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">brew install kafka</span><br><span class="line">brew install zookeeper</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>以服务的方式启动 kafka</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">brew services start kafka</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>创建一个 topic 来接收 canal 生产的信息，名称为  <code>canaltopic</code></li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kafka-topics --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic canaltopic</span><br></pre></td></tr></table></figure>
<p>然后要对 canal 进行 MQ 相关功能的配置<br>
4. canal.properties</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># tcp, kafka, RocketMQ 这里选择kafka模式</span></span><br><span class="line"><span class="string">canal.serverMode</span> <span class="string">=</span> <span class="string">kafka</span></span><br><span class="line"><span class="comment"># 解析器的线程数，打开此配置，不打开则会出现阻塞或者不进行解析的情况</span></span><br><span class="line"><span class="string">canal.instance.parser.parallelThreadSize</span> <span class="string">=</span> <span class="number">16</span></span><br><span class="line"><span class="comment"># 配置MQ的服务地址，这里配置的是kafka对应的地址和端口</span></span><br><span class="line"><span class="string">canal.mq.servers</span> <span class="string">=</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:9092</span></span><br><span class="line"><span class="comment"># 配置instance，在conf目录下要有example同名的目录，可以配置多个</span></span><br><span class="line"><span class="string">canal.destinations</span> <span class="string">=</span> <span class="string">example</span></span><br></pre></td></tr></table></figure>
<ol start="5">
<li>instance.properties</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#MQ队列名称</span></span><br><span class="line"><span class="string">canal.mq.topic=canaltopic</span></span><br></pre></td></tr></table></figure>
<ol start="6">
<li>重启 canal-server<br>
配置完成后到 <code>bin</code> 目录下执行 <code>./restart.sh</code> 重启 canal-server 服务</li>
</ol>
<h3 id="整合测试">整合测试</h3>
<p>测试 canal 是否能够顺利读取和解析 MySQL 的 binlog 并将信息发送到对应 topic</p>
<ol>
<li>启动一个消费者来监听 canaltopic</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kafka-console-consumer --bootstrap-server 127.0.0.1:9092 --from-beginning --topic canaltopic</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>执行 DML 语句</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">insert</span> <span class="keyword">into</span> xdual <span class="keyword">value</span>(<span class="keyword">null</span>,now());</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">delete</span> <span class="keyword">from</span> xdual <span class="keyword">where</span> id<span class="operator">=</span><span class="number">23</span>;</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>消费者端输出</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(base) Simbas-MacBook-Pro:~ simba$ kafka-console-consumer --bootstrap-server 127.0.0.1:9092 --from-beginning --topic canaltopic</span><br><span class="line">&#123;&quot;data&quot;:[&#123;&quot;ID&quot;:&quot;23&quot;,&quot;X&quot;:&quot;2021-06-22 15:37:59&quot;&#125;],&quot;database&quot;:&quot;test&quot;,&quot;es&quot;:1624347479000,&quot;id&quot;:10,&quot;isDdl&quot;:false,&quot;mysqlType&quot;:&#123;&quot;ID&quot;:&quot;int(11)&quot;,&quot;X&quot;:&quot;timestamp(0)&quot;&#125;,&quot;old&quot;:null,&quot;pkNames&quot;:[&quot;ID&quot;],&quot;sql&quot;:&quot;&quot;,&quot;sqlType&quot;:&#123;&quot;ID&quot;:4,&quot;X&quot;:93&#125;,&quot;table&quot;:&quot;xdual&quot;,&quot;ts&quot;:1624347479906,&quot;type&quot;:&quot;INSERT&quot;&#125;</span><br><span class="line">&#123;&quot;data&quot;:[&#123;&quot;ID&quot;:&quot;23&quot;,&quot;X&quot;:&quot;2021-06-22 15:37:59&quot;&#125;],&quot;database&quot;:&quot;test&quot;,&quot;es&quot;:1624347492000,&quot;id&quot;:11,&quot;isDdl&quot;:false,&quot;mysqlType&quot;:&#123;&quot;ID&quot;:&quot;int(11)&quot;,&quot;X&quot;:&quot;timestamp(0)&quot;&#125;,&quot;old&quot;:null,&quot;pkNames&quot;:[&quot;ID&quot;],&quot;sql&quot;:&quot;&quot;,&quot;sqlType&quot;:&#123;&quot;ID&quot;:4,&quot;X&quot;:93&#125;,&quot;table&quot;:&quot;xdual&quot;,&quot;ts&quot;:1624347493103,&quot;type&quot;:&quot;DELETE&quot;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Canal-Redis-和-Kafka-整合项目">Canal, Redis 和 Kafka 整合项目</h3>
<ol>
<li>引入所需的依赖</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 所用的 Spring Boot 版本为 2.2.1 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 引入 Spring-Kafka 依赖 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 已经内置 kafka-clients 依赖，所以无需重复引入 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.kafka<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-kafka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.3.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 实现对 Spring Data Redis 的自动化配置 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 去掉对 Lettuce 的依赖，因为 Spring Boot 优先使用 Lettuce 作为 Redis 客户端 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.lettuce<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lettuce-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 引入 Jedis 的依赖，这样 Spring Boot 实现对 Jedis 的自动化配置 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 使用 fastjson 作为 JSON 序列化的工具 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.61<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.otter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>canal.client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.20<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>在 application.yaml 中添加配置信息</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="comment"># 对应 RedisProperties 类</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">root123</span> <span class="comment"># Redis 服务器密码，默认为空。生产中，一定要设置 Redis 密码！</span></span><br><span class="line">    <span class="attr">database:</span> <span class="number">0</span> <span class="comment"># Redis 数据库号，默认为 0 。</span></span><br><span class="line">    <span class="attr">timeout:</span> <span class="number">0</span> <span class="comment"># Redis 连接超时时间，单位：毫秒。</span></span><br><span class="line">    <span class="comment"># 对应 RedisProperties.Jedis 内部类</span></span><br><span class="line">    <span class="attr">jedis:</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">        <span class="attr">max-active:</span> <span class="number">8</span> <span class="comment"># 连接池最大连接数，默认为 8 。使用负数表示没有限制。</span></span><br><span class="line">        <span class="attr">max-idle:</span> <span class="number">8</span> <span class="comment"># 默认连接数最小空闲的连接数，默认为 8 。使用负数表示没有限制。</span></span><br><span class="line">        <span class="attr">min-idle:</span> <span class="number">0</span> <span class="comment"># 默认连接池最小空闲的连接数，默认为 0 。允许设置 0 和 正数。</span></span><br><span class="line">        <span class="attr">max-wait:</span> <span class="number">-1</span> <span class="comment"># 连接池最大阻塞等待时间，单位：毫秒。默认为 -1 ，表示不限制。</span></span><br><span class="line">  <span class="comment"># Kafka 配置项，对应 KafkaProperties 配置类</span></span><br><span class="line">  <span class="attr">kafka:</span></span><br><span class="line">    <span class="attr">bootstrap-servers:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:9092</span> <span class="comment"># 指定 Kafka Broker 地址，可以设置多个，以逗号分隔</span></span><br><span class="line">    <span class="comment"># Kafka Producer 配置项</span></span><br><span class="line">    <span class="attr">producer:</span></span><br><span class="line">      <span class="attr">acks:</span> <span class="number">1</span> <span class="comment"># 0-不应答。1-leader 应答。all-所有 leader 和 follower 应答。</span></span><br><span class="line">      <span class="attr">retries:</span> <span class="number">3</span> <span class="comment"># 发送失败时，重试发送的次数</span></span><br><span class="line">      <span class="attr">key-serializer:</span> <span class="string">org.apache.kafka.common.serialization.StringSerializer</span> <span class="comment"># 消息的 key 的序列化</span></span><br><span class="line">      <span class="attr">value-serializer:</span> <span class="string">org.apache.kafka.common.serialization.StringSerializer</span> <span class="comment"># 消息的 value 的序列化</span></span><br><span class="line">      <span class="attr">batch-size:</span> <span class="number">65536</span> <span class="comment"># 每次批量发送消息的最大数量</span></span><br><span class="line">      <span class="attr">buffer-memory:</span> <span class="number">524288</span> <span class="comment"># 每次批量发送消息的最大内存</span></span><br><span class="line">    <span class="comment"># Kafka Consumer 配置项</span></span><br><span class="line">    <span class="attr">consumer:</span></span><br><span class="line">      <span class="comment"># 指定一个默认的组名</span></span><br><span class="line">      <span class="attr">group-id:</span> <span class="string">consumer-group1</span></span><br><span class="line">      <span class="comment">#auto-offset-reset: earliest # 设置消费者分组最初的消费进度为 earliest 。可参考博客 https://blog.csdn.net/lishuangzhe7047/article/details/74530417 理解</span></span><br><span class="line">      <span class="attr">key-deserializer:</span> <span class="string">org.apache.kafka.common.serialization.StringDeserializer</span> <span class="comment"># 消息的 key 的反序列化</span></span><br><span class="line">      <span class="attr">value-deserializer:</span> <span class="string">org.apache.kafka.common.serialization.StringDeserializer</span> <span class="comment"># 消息的 value 的反序列化</span></span><br><span class="line">    <span class="comment"># Kafka Consumer Listener 监听器配置</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">missing-topics-fatal:</span> <span class="literal">false</span> <span class="comment"># 消费监听接口监听的主题不存在时，默认会报错。所以通过设置为 false ，解决报错</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>封装一个操作 Redis 的工具类</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.simba.canalkafkaredis.redis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置redis的key-value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setString</span><span class="params">(String key, String value)</span> </span>&#123;</span><br><span class="line">        setString(key, value, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置redis的key-value，带过期时间</span></span><br><span class="line"><span class="comment">     * 时间单位：秒</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setString</span><span class="params">(String key, String value, Long timeOut)</span> </span>&#123;</span><br><span class="line">        stringRedisTemplate.opsForValue().set(key, value);</span><br><span class="line">        <span class="keyword">if</span> (timeOut != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stringRedisTemplate.expire(key, timeOut, TimeUnit.SECONDS);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取redis中key对应的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getString</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除redis中key对应的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">deleteKey</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stringRedisTemplate.delete(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>新建一个 model 对象来保存 Xdual 表的数据</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.simba.canalkafkaredis.model;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Xdual</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer ID;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String X;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol start="5">
<li>根据 Canal 发送给 Kafka 的 json 数据格式，创建一个 CanalBean 来接收数据</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.simba.canalkafkaredis.canal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.simba.canalkafkaredis.model.Xdual;</span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CanalBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Xdual&gt; data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String database;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long es;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Boolean isDdl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MysqlType mysqlType;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String old;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; pkNames;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String sql;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SqlType sqlType;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String table;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long ts; <span class="comment">//(新增)INSERT、(更新)UPDATE、(删除)DELETE、(删除表)ERASE等等</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String type;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol start="6">
<li>对应的 MysqlType 和 SqlType 类</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.simba.canalkafkaredis.canal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MysqlType</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String ID;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String X;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.simba.canalkafkaredis.canal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SqlType</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer ID;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer X;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="7">
<li>创建消费者类来消费信息</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.simba.canalkafkaredis.consumer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSONObject;</span><br><span class="line"><span class="keyword">import</span> com.simba.canalkafkaredis.canal.CanalBean;</span><br><span class="line"><span class="keyword">import</span> com.simba.canalkafkaredis.model.Xdual;</span><br><span class="line"><span class="keyword">import</span> com.simba.canalkafkaredis.redis.RedisClient;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.consumer.ConsumerRecord;</span><br><span class="line"><span class="keyword">import</span> org.springframework.kafka.annotation.KafkaListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CanalConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Long TIME_OUT = <span class="number">600L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RedisClient redisClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@KafkaListener(topics = &quot;canaltopic&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(ConsumerRecord&lt;?,?&gt; consumer)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String value = (String)consumer.value();</span><br><span class="line">        log.info(<span class="string">&quot;topic名称:&#123;&#125;,key:&#123;&#125;,分区位置:&#123;&#125;,下标:&#123;&#125;,value:&#123;&#125;&quot;</span>, consumer.topic(), consumer.key(),consumer.partition(), consumer.offset(), value);</span><br><span class="line">        <span class="comment">// 转换为 javabean</span></span><br><span class="line">        CanalBean canalBean = JSONObject.parseObject(value, CanalBean.class);</span><br><span class="line">        <span class="comment">// 是否是 DDL 语句</span></span><br><span class="line">        Boolean isDdl = canalBean.getIsDdl();</span><br><span class="line">        <span class="comment">// 获取语句类型</span></span><br><span class="line">        String type = canalBean.getType();</span><br><span class="line">        <span class="keyword">if</span> (!isDdl) &#123;</span><br><span class="line">            List&lt;Xdual&gt; items = canalBean.getData();</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;INSERT&quot;</span>.equals(type)) &#123;</span><br><span class="line">                <span class="comment">//新增语句</span></span><br><span class="line">                <span class="keyword">for</span> (Xdual item : items) &#123;</span><br><span class="line">                    Integer id = item.getID();</span><br><span class="line">                    <span class="comment">//新增到redis中,过期时间是10分钟</span></span><br><span class="line">                    redisClient.setString(String.valueOf(id), JSONObject.toJSONString(item), TIME_OUT);</span><br><span class="line">                    log.info(<span class="string">&quot;插入---id号:&#123;&#125;,值:&#123;&#125;&quot;</span>, id, item);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;UPDATE&quot;</span>.equals(type)) &#123;</span><br><span class="line">                <span class="comment">//更新语句</span></span><br><span class="line">                <span class="keyword">for</span> (Xdual item : items) &#123;</span><br><span class="line">                    Integer id = item.getID();</span><br><span class="line">                    <span class="comment">//更新到redis中,过期时间是10分钟</span></span><br><span class="line">                    redisClient.setString(String.valueOf(id), JSONObject.toJSONString(item), TIME_OUT);</span><br><span class="line">                    log.info(<span class="string">&quot;更新---id号:&#123;&#125;,值:&#123;&#125;&quot;</span>, id, item);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;DELETE&quot;</span>.equals(type))&#123;</span><br><span class="line">                <span class="comment">//删除语句</span></span><br><span class="line">                <span class="keyword">for</span> (Xdual item : items) &#123;</span><br><span class="line">                    Integer id = item.getID();</span><br><span class="line">                    <span class="comment">//从redis中删除</span></span><br><span class="line">                    redisClient.deleteKey(String.valueOf(id));</span><br><span class="line">                    log.info(<span class="string">&quot;删除---id号:&#123;&#125;,值:&#123;&#125;&quot;</span>, id, item);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                log.error(<span class="string">&quot;Unsupported type!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="启动项目并测试">启动项目并测试</h3>
<ol>
<li>添加数据
<ol>
<li>SQL</li>
</ol>
</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">insert</span> <span class="keyword">into</span> xdual <span class="keyword">value</span>(<span class="keyword">null</span>,now());</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>日志</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2021-06-22 15:57:01.301  INFO 91336 --- [ntainer#0-0-C-1] c.s.c.consumer.CanalConsumer             : topic名称:canaltopic,key:null,分区位置:0,下标:10,value:&#123;&quot;data&quot;:[&#123;&quot;ID&quot;:&quot;24&quot;,&quot;X&quot;:&quot;2021-06-22 15:57:01&quot;&#125;],&quot;database&quot;:&quot;test&quot;,&quot;es&quot;:1624348621000,&quot;id&quot;:12,&quot;isDdl&quot;:false,&quot;mysqlType&quot;:&#123;&quot;ID&quot;:&quot;int(11)&quot;,&quot;X&quot;:&quot;timestamp(0)&quot;&#125;,&quot;old&quot;:null,&quot;pkNames&quot;:[&quot;ID&quot;],&quot;sql&quot;:&quot;&quot;,&quot;sqlType&quot;:&#123;&quot;ID&quot;:4,&quot;X&quot;:93&#125;,&quot;table&quot;:&quot;xdual&quot;,&quot;ts&quot;:1624348621294,&quot;type&quot;:&quot;INSERT&quot;&#125;</span><br><span class="line">2021-06-22 15:57:01.307  INFO 91336 --- [ntainer#0-0-C-1] c.s.c.consumer.CanalConsumer             : 插入---id号:24,值:Xdual(ID=24, X=2021-06-22 15:57:01)</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>Redis</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; get 24</span><br><span class="line">&quot;&#123;\&quot;iD\&quot;:24,\&quot;x\&quot;:\&quot;2021-06-22 15:57:01\&quot;&#125;&quot;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>修改数据
<ol>
<li>SQL</li>
</ol>
</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> update xdual <span class="keyword">set</span> X<span class="operator">=</span>now() <span class="keyword">where</span> id<span class="operator">=</span><span class="number">24</span>;</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line"><span class="keyword">Rows</span> matched: <span class="number">1</span>  Changed: <span class="number">1</span>  Warnings: <span class="number">0</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>日志</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2021-06-22 15:59:24.315  INFO 91336 --- [ntainer#0-0-C-1] c.s.c.consumer.CanalConsumer             : topic名称:canaltopic,key:null,分区位置:0,下标:11,value:&#123;&quot;data&quot;:[&#123;&quot;ID&quot;:&quot;24&quot;,&quot;X&quot;:&quot;2021-06-22 15:59:24&quot;&#125;],&quot;database&quot;:&quot;test&quot;,&quot;es&quot;:1624348764000,&quot;id&quot;:13,&quot;isDdl&quot;:false,&quot;mysqlType&quot;:&#123;&quot;ID&quot;:&quot;int(11)&quot;,&quot;X&quot;:&quot;timestamp(0)&quot;&#125;,&quot;old&quot;:[&#123;&quot;X&quot;:&quot;2021-06-22 15:57:01&quot;&#125;],&quot;pkNames&quot;:[&quot;ID&quot;],&quot;sql&quot;:&quot;&quot;,&quot;sqlType&quot;:&#123;&quot;ID&quot;:4,&quot;X&quot;:93&#125;,&quot;table&quot;:&quot;xdual&quot;,&quot;ts&quot;:1624348764309,&quot;type&quot;:&quot;UPDATE&quot;&#125;</span><br><span class="line">2021-06-22 15:59:24.332  INFO 91336 --- [ntainer#0-0-C-1] c.s.c.consumer.CanalConsumer             : 更新---id号:24,值:Xdual(ID=24, X=2021-06-22 15:59:24)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>Redis</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; get 24</span><br><span class="line">&quot;&#123;\&quot;iD\&quot;:24,\&quot;x\&quot;:\&quot;2021-06-22 15:59:24\&quot;&#125;&quot;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>删除数据
<ol>
<li>SQL</li>
</ol>
</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">delete</span> <span class="keyword">from</span> xdual <span class="keyword">where</span> id<span class="operator">=</span><span class="number">24</span>;</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>日志</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2021-06-22 16:01:48.637  INFO 91336 --- [ntainer#0-0-C-1] c.s.c.consumer.CanalConsumer             : topic名称:canaltopic,key:null,分区位置:0,下标:12,value:&#123;&quot;data&quot;:[&#123;&quot;ID&quot;:&quot;24&quot;,&quot;X&quot;:&quot;2021-06-22 15:59:24&quot;&#125;],&quot;database&quot;:&quot;test&quot;,&quot;es&quot;:1624348908000,&quot;id&quot;:14,&quot;isDdl&quot;:false,&quot;mysqlType&quot;:&#123;&quot;ID&quot;:&quot;int(11)&quot;,&quot;X&quot;:&quot;timestamp(0)&quot;&#125;,&quot;old&quot;:null,&quot;pkNames&quot;:[&quot;ID&quot;],&quot;sql&quot;:&quot;&quot;,&quot;sqlType&quot;:&#123;&quot;ID&quot;:4,&quot;X&quot;:93&#125;,&quot;table&quot;:&quot;xdual&quot;,&quot;ts&quot;:1624348908632,&quot;type&quot;:&quot;DELETE&quot;&#125;</span><br><span class="line">2021-06-22 16:01:48.646  INFO 91336 --- [ntainer#0-0-C-1] c.s.c.consumer.CanalConsumer             : 删除---id号:24,值:Xdual(ID=24, X=2021-06-22 15:59:24)</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>Redis</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; get 24</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure>
<h3 id="总结">总结</h3>
<p>以上就是一个试验成功的简单 demo</p>
<h3 id="参考">参考</h3>
<p><a href="https://www.codenong.com/js4176de1c6337/">基于阿里巴巴Canal框架,TCP协议实现监听Mysql数据变化</a><br>
<a href="https://developer.aliyun.com/article/770659?spm=a2c6h.13262185.0.0.6c8a3b3fqkfa0y">详细讲解！Canal+Kafka实现MySQL与Redis数据同步！</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>MySQL</tag>
        <tag>Canal</tag>
        <tag>Kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统相关子问题</title>
    <url>/2021/04/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E5%AD%90%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="进程相关">进程相关</h3>
<h4 id="僵尸进程"><a href="https://www.cnblogs.com/anker/p/3271773.html">僵尸进程</a></h4>
<p>一个进程使用fork创建子进程，子进程结束后 父进程并没有调用wait或者waitpid方法获取子进程的终止状态，子进程的描述符依然保存在操作系统的进程表中，这样的进程就是一个僵尸进程。</p>
<p>僵尸进程是一个已经死亡的进程，但是没有被完全销毁。它几乎不占用任何内存资源，没有什么可执行的代码，只是在进程表中保留了一个位置，占用了一个进程id。</p>
<p><strong>任何子进程在结束之后都会经历僵尸进程的阶段，状态为Z，直到被父进程处理。</strong></p>
<span id="more"></span>
<h5 id="产生原因">产生原因</h5>
<p><strong>Unix的机制来保证父进程可以知道子进程结束时的状态信息</strong>：就是子进程<strong>结束后释放它占有的资源，包括打开的文件，内存等</strong>。但是<strong>还保留了一定信息，包括进程号，退出状态等</strong>，这些信息会直到父进程调用wait或者waitpid方法时才释放。其中<strong>wait会使父进程暂停执行，waitpid则可以加入wait-no-hang选项，如果没有结束的进程会立即返回，不回阻塞进程</strong></p>
<h5 id="危害">危害</h5>
<p>如果父进程没有调用上述方法，就会产生僵尸进程，保留的那些信息不会被释放，而进程号是有限的，有可能因此而不能产生新的进程</p>
<h5 id="问题和解决方法">问题和解决方法</h5>
<p><strong>问题</strong>：可能会有一个进程定期产生一个子进程，做了一些工作后就结束，但是没有被父进程处理，这样一段时间后就会产生大量僵尸进程。</p>
<p><strong>方法</strong>：解决产生僵尸进程的进程，这样那些僵尸进程就会变成孤儿进程，由init来处理</p>
<p>具体方法：</p>
<p>通过信号机制：子进程结束时发送SIGCHILD信号给父进程，父进程处理信号，在信号处理函数中调用wait方法处理僵尸进程。</p>
<h4 id="孤儿进程">孤儿进程</h4>
<p>一个父进程已经退出，但是它的子进程还在运行当中，这些进程就成了孤儿进程。孤儿进程将被init进程（id号1）收养，并由init进程完成状态收集工作。<strong>孤儿进程并不会有什么危害</strong>。</p>
<hr>
<h3 id="几种常见的IO方式">几种常见的IO方式</h3>
<h4 id="阻塞式IO">阻塞式IO</h4>
<p>当用户进程调用IO操作，应用程序被阻塞，直到数据从内核缓冲区复制到进程缓冲区才恢复。进行拷贝过程时继续阻塞。所以IO的两个阶段：等待和拷贝，都处于阻塞状态</p>
<p>但是阻塞期间其他进程还可以执行，所以CPU利用率挺高。</p>
<h4 id="非阻塞式IO">非阻塞式IO</h4>
<p>进程执行系统调用后，如果数据还没准备好，内核会返回一个错误码，进程可以继续执行。但是进程会定期执行系统调用来询问内核有没有准备好，如果准备好了并且收到了系统调用，就进行拷贝。第二阶段拷贝依然是阻塞的。</p>
<p>不断主动询问占用了很多CPU资源</p>
<h4 id="IO多路复用">IO多路复用</h4>
<p><a href="https://www.cnblogs.com/aspirant/p/9166944.html">select/poll/epoll</a></p>
<h4 id="异步IO">异步IO</h4>
<p>进程执行IO操作后可以立即返回，并继续执行，不会被阻塞，内核会在所有操作完成之后发送信号。比如说要进行读操作，内核会在把读取的数据放到用户指定的缓冲区内后通知进程。</p>
<h3 id="用户态和内核态">用户态和内核态</h3>
<p>是系统的两个权限等级，代表了不同的访问能力，先说内核态，内核态可以访问内存的所有数据以及外围设备，例如硬盘网卡，但是用户态只能受限访问内存，并且不能访问外围设备，不能占用CPU。</p>
<p>所有应用程序都运行在用户态，需要进行一些内核操作，例如读取硬盘数据时就要进行系统调用，CPU切换到内核态，执行完服务之后切换回用户态并返回系统调用的结果。</p>
<h4 id="为什么要分">为什么要分</h4>
<ul>
<li>安全性：防止用户程序执行一些危险指令，恶意或无意破坏系统、内存、硬盘资源</li>
<li>封装性：把系统层面的操作封装起来，通过操作系统来调用，操作系统可以检验一些操作的安全性</li>
</ul>
<h4 id="如何从用户态切换到内核态">如何从用户态切换到内核态</h4>
<ul>
<li>系统调用：</li>
<li>异常：如果用户进程出现了某些异常，需要切换到内核态来通过某些程序处理该异常</li>
<li>外设中断：当外设完成某些用户请求的操作后会发出一个中断请求，CPU会转而处理该请求。如果CPU正在处理用户态的程序，就会转而切换到内核态执行相关的处理方法。</li>
</ul>
<hr>
<h3 id="死锁">死锁</h3>
<p>死锁就是两个或者多个并发进程，都持有一定的资源，并且都等待其他进程释放他们持有的资源，进度无法推进，就发生了死锁</p>
<h4 id="死锁产生的必要条件">死锁产生的必要条件</h4>
<ul>
<li>互斥：一个资源同一时间只能被一个进程使用</li>
<li>占有等待：一个进程至少占有一个资源，并且在等待其他进程释放资源</li>
<li>非抢占：一个进程一旦占有某样资源就不能被抢夺，只能等待它主动释放该资源</li>
<li>循环等待：若干进程形成一个头尾相接的环形等待关系，每一个进程都在等待下一个进程释放资源</li>
</ul>
<h4 id="死锁的处理办法">死锁的处理办法</h4>
<ul>
<li>鸵鸟策略：直接忽视死锁 - 指发生死锁不会产生很严重的后果，或者死锁发生的概率很低</li>
<li>死锁预防
<ul>
<li>破坏互斥：资源可以被多个进程访问，但是某些资源不具备这个属性，所以无法操作</li>
<li>破坏占有等待
<ul>
<li>一次性申请所有需要的资源，否则不运行</li>
<li>申请资源之前先释放自己占有的资源</li>
<li>但是很多时候不知道一个进程需要的所有资源，降低系统并发性</li>
</ul>
</li>
<li>破坏不可抢占：允许进程抢占别的已占有资源</li>
<li>破坏循环等待：给资源同一编号，进程只能按照编号顺序来请求资源，只有占用小号资源才能申请大号资源</li>
</ul>
</li>
<li>死锁避免
<ul>
<li>动态检测资源分配，确保系统处于安全状态，只有处于安全状态时才会进行资源分配。安全状态是指：即使所有进程突然请求所需要的资源，也有某种资源分配的顺序使得每一个进程执行完毕</li>
<li>银行家算法</li>
</ul>
</li>
<li>死锁解除
<ul>
<li>利用抢占，挂起某些进程然后占有它的资源</li>
<li>回滚：让某些进程回滚到之前的状态，自愿释放资源到解除死锁的阶段</li>
<li>杀死进程：按照优先级杀死进程直到解除死锁</li>
</ul>
</li>
</ul>
<hr>
<h3 id="内存相关">内存相关</h3>
<h4 id="分页和分段">分页和分段</h4>
<p>页式存储：页是对虚拟地址空间的划分，页框是对物理内存空间的划分。内存管理单元MMU管理着地址空间和物理内存的转换。其中的页表存储着页（地址空间）和页框（物理内存空间）的映射表。虚拟地址分成两部分，一部分存储页面号，一部分存储偏移量。</p>
<p>按进程需要的页数分配，逻辑上相邻的页物理上不一定相邻</p>
<p>段式存储：将进程自己的地址空间按照逻辑划分成若干个段，如代码段、数据段等。内存空间页被动态划分成不同长度的区域，分配时以段为基本单位。</p>
<p>段页式：用户进程的地址空间先按段划分，段内再按页划分，内存空间按照页来划分</p>
<h5 id="区别是什么">区别是什么</h5>
<p>目的：分页是为了管理内存，通过虚拟内存获得更大的地址空间。分段是为了满足用户需要，程序和数据可以被划分为逻辑上独立的地址空间</p>
<p>大小：段的大小不固定，由其所完成的功能决定；页的大小固定，由系统决定</p>
<p>地址空间维度：页是一维的，给定一个虚拟地址，页号和页偏移可以被计算出来；段是二维的，需要通过段号加段内偏移来确定。</p>
<h4 id="虚拟内存">虚拟内存</h4>
<p>每个程序都有自己的地址空间，地址空间被划分为大小相等的页，页映射到物理内存空间。但不需要所有页都在物理内存中，有一部分被存储在磁盘上。当程序需要用到某些不在物理内存空间中的页时，需要由操作系统把它从磁盘置换到内存中。这样，逻辑上有很大的内存空间，其实有一部分时存储在磁盘上的</p>
<h5 id="地址空间到物理空间的映射">地址空间到物理空间的映射</h5>
<p>由MMU内存管理单元实现，其中的页表存储了页到页框的映射表，其中还包含有效位（是在内存还是磁盘中）、访问位（是否被访问过）、修改位（是否被修改过）等</p>
<h4 id="页面置换算法">页面置换算法</h4>
<p>最佳页面置换算法：把未来很长一段时间内不会被用到的页面置换掉-理论算法</p>
<p>最近未使用LRU：将最近最久未使用的页面置换出去。实现方式是链表，每次一个页面被访问，把它移动到链表头，置换时候置换掉链表尾部的页面</p>
<p>先进先出FIFO：置换掉在内存中停留时间最长的页面-会把常用的页面置换出去</p>
<p>第二次机会算法：相当于优化FIFO，解决了常用页面被置换的问题。为每一个页面设置一个R位，被读和写时置为1，需要置换链表头部的页时，检查R位，如果是0就置换，如果是1，就将R置0，放入链表尾部。</p>
<p>时钟：省去第二次机会算法在链表中移动的开销，将页面首尾相连，指针指向最老的那个页面</p>
<h5 id="局部性原理">局部性原理</h5>
<p>时间上：最近被访问的页在不久的将来还会被访问</p>
<p>空间上：内存中被访问的页周围的页也很可能被访问</p>
<h5 id="颠簸">颠簸</h5>
<p>指频繁的页调度，置换掉一个页，那个页有马上被需要，又置换回来，频繁发生缺页中断。</p>
<p>解决方法（根本原因就是内存不足）</p>
<ul>
<li>降低运行的程序量（释放内存）</li>
<li>增加物理内存（增加内存）</li>
<li>修改页面置换算法</li>
</ul>
<h3 id="磁盘调度">磁盘调度</h3>
<p>磁盘</p>
<ul>
<li>盘面（找到对应的盘面）</li>
<li>磁道（盘面上的同心圆 - 寻道时间）</li>
<li>扇区（旋转时间）</li>
</ul>
<h4 id="磁盘调度算法">磁盘调度算法</h4>
<p>寻道时间最长，磁盘调度是使磁盘的平均寻道时间最短</p>
<ul>
<li>
<p>先来先服务FCFS</p>
<p>公平简单，但是不做任何优化，平均寻道时间较长</p>
</li>
<li>
<p>最短寻道时间优先</p>
<p>优先调度与所在磁道最近的磁道。平均时间较短，但是会出现饥饿</p>
</li>
<li>
<p>电梯算法</p>
<p>按照一个方向来进行磁盘调度，等到该方向没有未完成的请求，改变方向</p>
</li>
</ul>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统面试重点</title>
    <url>/2021/04/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E9%87%8D%E7%82%B9/</url>
    <content><![CDATA[<h3 id="进程和线程的区别-16">进程和线程的区别 16</h3>
<ol>
<li>进程的状态、协程、和虚拟内存的关系</li>
<li>开多个java进程和多个线程的区别</li>
<li>一个进程能否访问到另一个进程的内存</li>
<li>Java线程和系统线程的区别</li>
</ol>
<span id="more"></span>
<p><strong>区别</strong></p>
<ul>
<li>进程是系统进行资源分配和调度的基本单位；线程是 CPU 资源分配和调度的基本单位</li>
<li>线程依赖于进程，一个进程至少有一个线程</li>
<li>进程有自己独立的地址空间，线程共享进程所属的地址空间</li>
<li>上下文切换时，进程涉及到当前 CPU 环境的保存和新进程 CPU 环境的设置；线程只涉及少量寄存器内容的保存和设置 前者开销更大</li>
</ul>
<p><strong>协程</strong></p>
<ul>
<li>协程是<strong>用户态</strong>轻量级线程，完全由程序控制而不被内核管理，内核不知道协程的存在</li>
<li>一个线程可以有多个协程，一个进程也可以有多个协程</li>
<li>进程和线程都是同步机制，协程是异步</li>
</ul>
<p><strong>Java线程和系统线程的区别</strong></p>
<ul>
<li>底层数据结构不同， Java 是 JVM 中的实现，系统中的线程根据需求会有不同的实现</li>
<li>状态不同， Java 线程有 New Terminated 等状态，操作系统只有ready running 和waiting 三种状态</li>
<li>Java 线程都是在用户态的，但是系统内核线程都是在内核态下，用户是通过系统调用来调用的</li>
</ul>
<hr>
<h3 id="内存模型-7">内存模型 7</h3>
<p>虚拟内存的理解和作用（段页式、缺页中断、页面置换、内存颠簸）</p>
<p>逻辑地址和物理地址转化</p>
<hr>
<p><strong>虚拟内存</strong></p>
<p>地址空间被按页划分，每页地址被映射到对应的物理内存。但不是所有页都在内存中，一些不常用的页存在磁盘上，当程序引用到不存在于物理内存中的页时，操作系统将缺失的部分装入物理内存。逻辑上内存大于物理上的内存，但其中一部分其实存储在磁盘上（磁盘上会有一个 swap 分区用来实现置换，当内存不足时会将暂时不用的一部分取出放到 swap 分区中来为当前的程序腾出足够的内存空间），所以叫虚拟内存。优点是<strong>让程序获得更多的可用内存</strong></p>
<p>它让程序认为它拥有一块连续的可用内存，但其实这些内存往往离散的分布在不同的物理空间</p>
<hr>
<p><strong>虚拟内存和常规存储</strong></p>
<p>常规存储有两个问题</p>
<ul>
<li>问题一：作业运行前要一次性装入内存，如果作业大小超出内存，就无法执行</li>
<li>问题二：作业装入内存后就一直在内存中，直到作业运行结束。期间其他作业只能等待</li>
</ul>
<p>针对这两个问题，虚拟内存的解决办法是</p>
<p>针对问题一</p>
<ul>
<li>
<p>根据<strong>局部性原理</strong></p>
<p>时间上：最近被访问的页在不久的将来还会被访问</p>
<p>空间上：内存中被访问的页周围的页也很可能被访问</p>
</li>
<li>
<p>程序在运行时只将当前需要的页装入内存</p>
</li>
<li>
<p>如果所需要的页都在内存中就正常运行，如果发生缺页，就申请将需要的页从磁盘调入内存</p>
</li>
</ul>
<p>针对问题二</p>
<ul>
<li>如果内存已满，就根据页面置换算法将需要的页与当前内存中的页进行置换</li>
</ul>
<hr>
<p><strong>页式存储</strong></p>
<ul>
<li>将内存抽象成地址空间</li>
<li>地址空间被分成很多大小相等的块，每一块称为<strong>页</strong></li>
<li>内存空间也按照同样的大小被划分，每一块称为<strong>页框</strong></li>
<li><strong>页表</strong>存储着页和页框的映射表</li>
<li>逻辑上相邻的页，对应的物理地址不一定相邻</li>
<li>虚拟地址分为两部分，一部分为页面号，一部分为偏移量</li>
</ul>
<p>页太小会导致页表过大，降低对换效率，但是可以减少内碎片</p>
<p>页太大可以提高对换速度，但是内碎片过大，降低内存利用率</p>
<p><strong>段式存储</strong></p>
<ul>
<li>将进程自己的地址空间按照逻辑划分成若干段，如代码段，数据段等。内存空间页被<strong>动态</strong>地划分成长度不同的区域（段可以应付动态增长的情况），每段从 0 开始编址</li>
<li>段式管理通过段表对应逻辑地址和物理地址</li>
</ul>
<p>分页主要是用于实现虚拟内存，获得更大的地址空间；分段是为了使程序和数据可以被划分为逻辑上独立的地址空间，有助于共享和保护</p>
<p>要实现<strong>动态链接</strong>也需要段式存储。动态链接是在程序运行之前，先不把几个目标程序段连起来，而是只把主程序对应的程序段装入内存中，运行期间如果需要调用其他程序段，再把程序段装入内存并进行连接</p>
<p><strong>段页式管理</strong></p>
<ul>
<li>用户进程先分段，每个段内部再分页，实现了对内存的划分以及段内存的按页分配</li>
<li>寻址：先通过段号找到该段对应的页表；再在页表中根据页号在物理地址中找到对应的物理块号，并根据页内偏移找到数据的物理地址；第三次再根据物理地址访问数据。<strong>一共三次访问主存</strong>。</li>
</ul>
<p><strong>分页和分段的区别</strong></p>
<ul>
<li>目的不同：分页的目的是管理内存，用于虚拟内存以获得更大的地址空间；分段的目的是满足用户的需要，使程序和数据可以被划分为逻辑上独立的地址空间；</li>
<li>大小不同：段的大小不固定，由其所完成的功能决定；页的大小固定，由系统决定；</li>
<li>地址空间维度不同：
<ul>
<li>分段是二维地址空间（段号+段内偏移），因为段和段之间没有关系，段号连续的两个段，地址并不一定连续；需要给出段号和段内偏移才能确定物理地址</li>
<li>分页是一维地址空间，页和页之间逻辑上连续，第一个页的最后一个地址和第二个页的第一个地址数值上是连续的；只需要给出一个逻辑地址就能计算出页号和页内偏移，从而确定物理地址，因为页号大小是确定的。</li>
</ul>
</li>
<li>分段便于信息的保护和共享，对于可重入代码，可以专门划分一个段，其他进程的段表加入该段就可以实现代码共享；分页的共享受到限制，一个页中可能只需要共享一部分代码，但是共享的时候只能整个页一起共享；</li>
<li>碎片：分段没有内碎片，但会产生外碎片；分页没有外碎片，但会产生内碎片（一个页填不满）
<ul>
<li>内碎片是占用分区内未被利用的空间</li>
<li>外碎片是占用分区之间难以利用的空闲分区</li>
</ul>
</li>
</ul>
<hr>
<p><strong>缺页中断</strong></p>
<p>如果需要的页不在物理内存中，就发生缺页中断，需要将该页从磁盘掉入内存中。如果此时内存已满，就需要从内存中挑出一个与之进行置换</p>
<hr>
<p><strong>页面置换算法</strong></p>
<p>页面置换算法是为了让缺页率最低</p>
<p><strong>最佳页面置换算法</strong>：把未来很长一段时间内不会被用到的页面置换掉-理论算法</p>
<p><strong>最近最久未使用LRU</strong>：将最近最久未使用的页面置换出去。实现方式是链表，每次一个页面被访问，把它移动到链表头，置换时候置换掉链表尾部的页面</p>
<p><strong>先进先出FIFO</strong>：置换掉在内存中停留时间最长的页面-会把常用的页面置换出去</p>
<p><strong>第二次机会算法</strong>：相当于优化FIFO，解决了常用页面被置换的问题。为每一个页面设置一个R位，被读和写时置为1，需要置换链表头部的页时，检查R位，如果是0就置换，如果是1，就将R置0，放入链表尾部。</p>
<p><strong>时钟</strong>：省去第二次机会算法在链表中移动的开销，将页面首尾相连，指针指向最老的那个页面。需要置换时，判断R位是否为1，如果为1，重置为0，指针移向下一页；如果为0，把页面置换出</p>
<hr>
<p><strong>内存颠簸</strong></p>
<p>本质就是频繁的页面调度。进程发生缺页中断，必须置换某一页。但是所有页都在使用，置换页面之后马上又发生缺页中断，导致系统效率急剧下降。解决策略包括：</p>
<ul>
<li>增加物理内存</li>
<li>修改页面置换算法</li>
<li>减少运行的程序数量</li>
</ul>
<hr>
<h3 id="死锁-5">死锁 5</h3>
<p>死锁的条件，说一个死锁情况，如何避免，尽量破坏哪一个来避免死锁</p>
<p><strong>死锁的起因</strong>是互相等待对方释放占有的资源而处于永远暂停的状态</p>
<p><strong>死锁产生的必要条件</strong></p>
<ul>
<li><strong>资源互斥</strong>：资源每次只能被一个线程占有</li>
<li><strong>请求与保持</strong>：线程因请求资源而被阻塞时，对已获得的资源保持不放</li>
<li><strong>不可抢占</strong>：线程已获得的资源，在未使用完之前不能强行剥夺</li>
<li><strong>循环等待</strong>：若干线程形成一种头尾相接循环等待资源的关系</li>
</ul>
<p><strong>死锁预防</strong></p>
<p>思想是破坏产生死锁的四个条件</p>
<ul>
<li>破坏互斥：某些资源不具备这个条件</li>
<li>破坏请求与保持：一次性申请所需要的所有资源；请求资源前先释放自己拥有的资源</li>
<li>破坏不可抢占：允许进程抢占资源</li>
<li>破坏循环等待：<strong>锁排序法</strong>，通过指定锁的获取顺序。一个线程只有获得A锁和B锁才能对某资源进行操作，在多线程下，可以指定只有获得A锁的线程才能获得B锁，按顺序获取锁就能避免两个线程同时持有A锁和B锁出现循环等待</li>
</ul>
<p><strong>死锁避免</strong></p>
<ul>
<li>银行家算法 - 动态监测资源分配，确保处于安全状态下才进行资源分配。安全状态是指当前所有进程突然请求所有需要的资源时，有一种分配顺序能够满足所有进程</li>
</ul>
<p><strong>死锁解除</strong></p>
<ul>
<li>回滚到之前的状态</li>
<li>杀死进程 - 按照优先级杀死进程直到死锁解除</li>
</ul>
<hr>
<h3 id="IO方法-4">IO方法 4</h3>
<p><strong>阻塞式 IO</strong></p>
<p>调用 IO 操作时，应用进程被阻塞，直到数据从内核缓冲区被复制到进程缓冲区才恢复，进行拷贝时继续阻塞。所以等待和拷贝两个阶段都处于阻塞状态</p>
<hr>
<p><strong>非阻塞式 IO</strong></p>
<p>进程调用 IO 操作，如果数据还没准备好，系统会返回一个错误码，期间应用进程可以继续执行，期间会定期询问内核有没有准备好数据，如果准备好就进行拷贝。拷贝的过程依然是阻塞的</p>
<hr>
<p><strong>IO多路复用</strong></p>
<p>select / poll / epoll 都是多路复用，多路复用就是通过一种机制，可以监听多个描述符，一旦某个描述符就绪，就可以通知程序进行响应的读写操作</p>
<p>区别：</p>
<ul>
<li>支持的最大连接数</li>
<li>文件描述符是否从内核空间到用户空间来回复制</li>
<li>触发方式</li>
<li>查询描述符的效率，是否轮询</li>
</ul>
<p><strong>select</strong></p>
<ul>
<li>将文件描述符放入<strong>集合</strong>中</li>
<li>每次调用时将集合从用户空间拷贝到内核空间（每次都要复制，开销大）内核根据就绪状态修改集合内容</li>
<li><strong>集合大小有限制</strong>（32位机默认只有1024），采用<strong>水平触发</strong></li>
<li>select函数返回后，需要通过遍历集合找到就绪的文件描述符（<strong>轮询效率低</strong>），文件描述符越多，效率越低</li>
</ul>
<p><strong>poll</strong></p>
<ul>
<li>用<strong>链表</strong>存储文件描述符，所以大小没有限制</li>
<li>其他和select一样</li>
</ul>
<p><strong>epoll</strong></p>
<ul>
<li>用红黑树来存储被监听的描述符</li>
<li>用户空间和内核空间共享内存，避免了来回复制的开销</li>
<li>支持的最大连接数很大，1G 可以支持 10W 左右的连接数</li>
<li>文件描述符就绪时会调用回调函数，将描述符添加到一个链表，之后返回这个链表</li>
<li>支持<strong>水平触发</strong>和<strong>边缘触发</strong></li>
<li>采用<strong>边缘触发</strong>时只有活跃的描述符才会触发回调函数。所谓<strong>活跃</strong>，就是指缓冲区的状态发生变化：从不可读到可读；从不可写到可写；缓冲区的内容增多或减少</li>
<li>采用<strong>水平触发</strong>时如果一次没有将缓冲区中的内容全部读完，下次即使缓冲区内容没有变化，还会再通知</li>
</ul>
<p>连接数多并且很多不活跃时使用 epoll；连接数少且多数活跃时使用前两者，因为 epoll 需要回调，性能会稍差</p>
<hr>
<p><strong>水平触发</strong></p>
<p>只要一个文件描述符就绪，就会发送通知，如果用户程序没有一次性把数据读写完，再次还会通知</p>
<p><strong>边缘触发</strong></p>
<p>描述符从为就绪变为就绪时通知一次，如果没读完之后也不会再通知</p>
<p>区别：边缘触发效率更高，减少了被重复触发的次数。水平触发可能会导致用户程序收到大量不需要的文件描述符</p>
<hr>
<p><strong>异步 IO</strong></p>
<p>执行 IO 调用后可以立即返回，继续执行原来的操作。内核会在操作完成后通知进程。比如读操作，会在把数据放到用户指定的缓冲区后通知进程。<strong>等待和拷贝过程都不是阻塞的。</strong></p>
<hr>
<h3 id="进程调度算法-3">进程调度算法 3</h3>
<p><strong>批处理系统</strong></p>
<p>目的是保证吞吐量和周转时间</p>
<ul>
<li>先来先服务
<ul>
<li>非抢占，按照请求顺序调度，有利于长作业，不利于短作业，短作业可能需要等待很久来让长作业执行完</li>
</ul>
</li>
<li>短作业优先
<ul>
<li>非抢占，长作业可能被饿死</li>
</ul>
</li>
<li>最短剩余时间优先
<ul>
<li>短作业优先的抢占式版本，长作业还是可能会饥饿</li>
</ul>
</li>
<li>最高响应比优先
<ul>
<li>计算响应比 = 1 + 等待时间 / 处理时间，平衡了长短进程，非抢占，但是开销大</li>
</ul>
</li>
</ul>
<p><strong>交互式系统</strong></p>
<p>保证快速响应</p>
<ul>
<li>时间片轮转
<ul>
<li>所有进程按 FCFS 拍成队列，每个进程分配一个 CPU 时间片，用完后排到队尾部</li>
<li>效率取决于时间片长短，太短会导致切换过频繁，太长实时性不能保证</li>
</ul>
</li>
<li>优先级调度
<ul>
<li>为每个进程分配一个优先级，按优先级调度</li>
<li>为保证低优先级等不到调度，随着等待时间的增加提高优先级</li>
</ul>
</li>
<li>多级反馈队列调度
<ul>
<li>前两种方法的结合</li>
<li>设置多个队列，从前到后时间片大小增加，优先级减小</li>
<li>如果在前一个没有执行完就移到下一个队列，只有上一个队列没有进程，才执行下一个队列</li>
</ul>
</li>
</ul>
<hr>
<h3 id="进程间通信-3"><a href="https://mp.weixin.qq.com/s/KU2tdFbL3PSltYZQbfX_Iw">进程间通信 3</a></h3>
<p>机制，什么时候用什么，哪个最优（共享内存？）</p>
<p><strong>管道</strong>：传输信息量大，只适用于亲缘进程 - 半双工，数据只能单向流动。如果要双向流动需要建立两个管道。<strong>只能用于亲缘进程</strong>是因为管道没有实体，只能通过 fork 来复制父进程的文件描述符来达到通信的目的。</p>
<p><strong>命名管道</strong>：传输信息量大，适用任何场景。<strong>可以用于不相关的进程间</strong>，因为命名管道创建了一个类型为管道的设备文件，在进程里只要使用这个设备文件就能进行通信。</p>
<blockquote>
<p><strong>管道其实就是内核中的一串缓存</strong>，管道一端写入的数据放到缓存中，另一端从缓存中取出数据。一端把数据放入管道后，只有等到另一端把数据取出，这一端才能正常返回。在这里理解为同步阻塞的，通信效率低</p>
</blockquote>
<p><strong>共享内存</strong>：传输信息量大，可适用于多个进程间通信 - <strong>允许多个进程共享一段物理内存</strong>，不同进程可以将这个内存映射到自己的地址空间，然后<strong>像访问正常内存一样访问它</strong>。进程可以通过向共享内存区域读写数据来交换信息。<strong>优点</strong>：速度快，就像使用自己的内存区域一样，不需要系统调用，不存在用户态和内核态之间的数据拷贝 <strong>缺点</strong>：存在并发问题，一般和信号量一起使用解决并发问题</p>
<p><strong>套接字</strong>：传输信息量大，适用于不同主机间进程的通信。服务端有一个专门用于监听的 socket，当收到客户端的连接请求时，会返回一个专门用于传输数据的 socket。</p>
<p><strong>消息队列</strong>：消息队列是保存在内核中的消息链表，每一个消息都是一个数据块，具有固定的数据类型和大小。（管道是无格式的字节流数据）局限是因为数据块大小限制，不能上传过大文件</p>
<p><strong>信号</strong>：传输少量信息，适用任何场景</p>
<p><strong>信号量</strong>：主要用于互斥同步，是进程通信中唯一的异步通信机制</p>
<hr>
<h3 id="线程间通信机制-3">线程间通信机制 3</h3>
<p>线程间通信的目的主要是用于线程同步，没有像进程通信中用于数据交换的通信机制</p>
<ul>
<li>锁机制：互斥锁、读写锁</li>
<li>可以读写同一进程中的数据进行通信，全局变量 - 因为多个线程可能更改全局变量，所以把它声明为 volatile</li>
<li>信号量机制 semaphore</li>
<li>信号机制 signal</li>
</ul>
<hr>
<h3 id="TLB-2">TLB 2</h3>
<p>是什么，有什么作用</p>
<p>又被称为快表，相当于页表的cache，存储了当前最可能被访问到的页表项。提高了虚拟地址到物理地址的转换速度。在没有快表时，读写内存数据时要访问两次主存，有了快表之后就可能只要访问一次高速缓存和一次主存，提高查找速度。</p>
<hr>
<h3 id="线程同步机制-2">线程同步机制 2</h3>
<ul>
<li><strong>互斥量</strong>，是内核对象，只有拥有互斥对象才能访问互斥资源。互斥对象只有一个，所以同一时刻互斥资源只能被同一对象访问。当前线程处理完后要将互斥对象交出</li>
<li><strong>信号量</strong>，是内核对象，允许同一时刻多个线程访问同一资源，每增加一个线程访问资源，信号量就减1</li>
<li><strong>事件</strong>，允许线程在处理完一个任务后主动唤醒另外一个线程执行任务</li>
<li><strong>临界区</strong>，任意时刻只允许一个线程访问临界区</li>
</ul>
<p><strong>互斥量和临界区的区别</strong></p>
<p>互斥量是可以命名的，<strong>可以用于不同进程间同步</strong>；<strong>临界区只能用于同一进程中线程的同步</strong>。创建互斥量需要的资源更多，所以临界区优势是速度快，节省资源。</p>
<hr>
<h3 id="进程状态">进程状态</h3>
<p>进程有三种状态：<strong>就绪态，运行态，阻塞态</strong></p>
<p><strong>运行态和就绪态可相互转换</strong>，就绪态获得CPU资源进入运行态，运行态用完CPU资源进入就绪态</p>
<p><strong>运行态可以转为阻塞态</strong>，当运行中的进程缺失某个资源无法进行下去时会进入阻塞态</p>
<p><strong>阻塞态可以转化为就绪态</strong>，当阻塞态的进程获取到想要的资源时，转变为就绪态</p>
<p>综上：就绪态和阻塞态不能相互转化</p>
<hr>
<h3 id="进程间socket通信和网络间socket通信的区别">进程间socket通信和网络间socket通信的区别</h3>
<p><strong>网络间socket</strong></p>
<ul>
<li>建立 socket 需要一对套接字，一个运行于客户端，一个运行于服务端</li>
<li>连接过程分为三个步骤：服务器监听，客户端请求，连接确认</li>
<li><strong>服务器监听</strong>：服务器端套接字处于等待连接状态，等待客户端的连接请求</li>
<li><strong>客户端请求</strong>：客户端提出连接请求，指出服务端套接字的地址和端口号，然后向服务端套接字提出连接请求</li>
<li><strong>连接确认</strong>：服务端套接字接收到客户端的连接请求后，就响应客户端的连接请求，建立一个新的线程，把服务端套接字的描述发送给客户端，一旦客户端确认，双方就正式建立连接。</li>
</ul>
<hr>
<h3 id="用户态和内核态">用户态和内核态</h3>
<p>是系统的两个权限等级，代表不同的访问能力</p>
<ul>
<li>内核态可以访问内存的所有数据以及外围设备，例如硬盘网卡</li>
<li>用户态只能受限访问内存，不能访问外围设备，不能占用 CPU</li>
</ul>
<p>所有应用程序都运行在用户态，需要进行一些内核操作，例如读取硬盘数据时就要进行系统调用，切换到内核态，执行完服务之后再返回用户态，并返回调用结果</p>
<p><strong>从用户态切换到内核态的方法</strong></p>
<ul>
<li>系统调用</li>
<li>异常：一些异常需要在内核态进行处理</li>
</ul>
<hr>
<h3 id="磁盘寻道">磁盘寻道</h3>
<p><strong>过程</strong></p>
<ul>
<li>磁头先找到对应的盘面</li>
<li>磁头移动到对应的磁道（寻道时间）</li>
<li>磁盘旋转到对应的扇区（旋转时间）</li>
</ul>
<p><strong>调度算法</strong></p>
<p>先来先服务：公平简单，但是平均寻道时间长</p>
<p>最短寻道优先：平均时间较短，但是会饥饿</p>
<p>电梯算法：按照一个方向进行磁盘调度，等到该方向没有未完成请求后，改变方向</p>
<hr>
<h3 id="fork">fork()</h3>
<p>创建一个与原来进程几乎完全相同的进程</p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库面试重点</title>
    <url>/2021/04/24/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9D%A2%E8%AF%95%E9%87%8D%E7%82%B9/</url>
    <content><![CDATA[<h2 id="MySQL">MySQL</h2>
<hr>
<h3 id="隔离级别-7">隔离级别 7</h3>
<p><strong>并发一致性问题</strong></p>
<ul>
<li>丢失修改：一个事务对数据的修改被另一个事务对数据的修改覆盖</li>
<li>脏读：一个事务读取了被另一个事务修改，但是未提交的数据。如果修改被撤销，那么此次读到的就是脏数据</li>
<li>不可重复读：是指一个事务在执行期间多次读取某一行数据。这期间如果有另一个事务对这个数据进行了修改（更新或删除），会导致两次读取的数据结果不同。</li>
<li>幻读：同一查询多次执行时，由于其他事务在这个数据范围内执行了插入操作，会导致每次返回不同结果</li>
</ul>
<span id="more"></span>
<p><strong>隔离级别</strong></p>
<ul>
<li><strong>未提交读</strong>：其他事务可以读取到一个事务还未提交的数据，会导致脏读、不可重复读和幻读</li>
<li><strong>提交读</strong>：事务只能看见已提交的事务对数据库进行的修改，避免脏读，但是会有不可重复读和幻读</li>
<li><strong>可重复读（MySQL默认隔离级别）</strong>：一个事务在多次读取同一个数据时读取到的都是相同的结果，可以避免不可重复读</li>
<li><strong>可串行化</strong>：强制事务串行执行，不可能发生冲突，从而解决幻读</li>
</ul>
<p><strong>不可重复读和幻读的区别</strong></p>
<p>不可重复度针对的是一个数据整体（对单个学生的信息进行修改），而幻读针对的是一个数据范围，并且需要是<strong>插入操作</strong>（就比如查询成绩在某个范围内的学生，在此期间不断进行插入操作）</p>
<hr>
<h3 id="索引-6">索引 6</h3>
<hr>
<p><strong>为什么要索引</strong></p>
<p><strong>优点</strong></p>
<ul>
<li>加快数据的检索速度</li>
<li>创建唯一性索引可以保证表中每一行数据的唯一性</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li><strong>创建和维护索引消耗很大</strong>，对数据进行增删时，如果数据有索引，对应的索引也需要修改，降低 SQL 的执行效率</li>
<li><strong>占用物理内存</strong>，索引也需要物理文件进行存储</li>
</ul>
<hr>
<p><strong>聚簇索引</strong>的索引树叶子节点存放的是<strong>整行数据</strong>，表中行内容在物理存储中的顺序和索引顺序一致。一个表只能包含一个聚簇索引，因为索引只能按照一种方法进行排列</p>
<p><strong>优点</strong>是查询速度快，定位到索引的节点就相当于定位到数据；<strong>缺点</strong>是修改代价大，修改数据就相当于修改了索引</p>
<p><strong>非聚簇索引</strong>的叶子节点内容是<strong>主键的值</strong>，不存储数据。在 InnoDB 中非主键索引也被称为二级索引，因为根据定位到的主键再用主键索引树查一遍数据，这个过程叫做<strong>回表</strong></p>
<p><strong>优点</strong>是更新代价相比聚簇索引小，因为叶子节点不存放数据，<strong>缺点</strong>是会需要<strong>回表（二次查询）</strong>，这样查找速度会慢些</p>
<hr>
<p><strong>覆盖索引</strong>是指在普通索引树上的查询已经提供了结果，不需要回表操作。覆盖索引可以显著提高查询效率。是常见的 MySQL 优化手段，所以可以对经常作为查询条件的列加索引</p>
<blockquote>
<p>非主键索引 叶子节点存储的是 <strong>列值 + 主键</strong></p>
</blockquote>
<p><strong>联合索引</strong>是由多列组成的索引，需要遵循<strong>最左前缀原则</strong></p>
<p>假设创建的联合索引由三个字段组成:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE table ADD INDEX index_name (num,name,age)</span><br></pre></td></tr></table></figure>
<p>那么当查询的条件有为:num / (num AND name) / (num AND name AND age)时，索引才生效。所以在创建联合索引时，尽量把查询最频繁的那个字段作为最左(第一个)字段。查询的时候也尽量以这个字段为第一条件。</p>
<hr>
<p><strong>适合作为索引的字段</strong>：经常被查询的字段、经常被作为查询条件的字段、频繁用于连接的字段、经常出现在 ORDER BY / GROUP BY 后面的字段</p>
<p><strong>索引失效的场景</strong>：以 % 开头的 LIKE 语句（表示匹配任意个字符）、OR 语句前后没有同时使用索引、数据出现隐式转换（例如 varchar 不加单引号可能会转为 int）</p>
<hr>
<h3 id="ACID-5">ACID 5</h3>
<ul>
<li><strong>原子性</strong>，一个事务不可分割，要么全部成功提交，要么全部失败回滚</li>
<li><strong><a href="https://www.zhihu.com/question/31346392">一致性</a></strong>，是基于AID的，保证事务只能把数据库从一个正确的状态转移到另一个正确的状态。所谓<strong>正确的状态</strong>就是要满足数据库提前定义的一些规则：例如值不能小于0等。因为数据库只保证一个 transaction 是否符合定义的规则，不保证它在逻辑上是否正确，逻辑上的正确性要由使用者决定。</li>
<li><strong>隔离性</strong>，多个事务并发执行时，一个事务的执行不影响其他事务的执行，保证数据库的执行结果和每个事务先后单独执行的结果一致</li>
<li><strong>持久性</strong>，一个事务一旦提交，对数据库的修改应该永久保存</li>
</ul>
<hr>
<h3 id="索引的数据结构-4">索引的数据结构 4</h3>
<hr>
<p><strong>B树 / B+树</strong></p>
<ul>
<li>B+树和B树都不是二叉树，<strong>一个节点可以存放多个值</strong>，并且指向多个子节点，指向子节点的值在节点左边的 key 和右边的 key 范围之间</li>
<li>因为可以容纳更多子节点，并且节点容纳的信息更多，所以树更加矮胖，树的高度增长也很慢</li>
<li>适合于数据库是因为较低的树高，如果每读取一个节点就要进行一次磁盘IO（将节点大小设置为磁盘页大小），那么高度越少，进行磁盘IO的次数也越少。因为磁盘读写速度远低于内存读写速度，所以宁可读取一个节点后在内存中进行多次比较，也不多次进行磁盘IO</li>
</ul>
<p><strong>区别</strong></p>
<p>主要在于节点中存储的信息，<strong>B+树</strong>中间节点只存放索引，数据都在叶子节点；<strong>B树</strong>中间节点既存放数据又存放索引，叶子节点不携带任何信息</p>
<p><strong>B+树相对于B树的好处</strong></p>
<ul>
<li><strong>IO次数更少</strong>：中间节点只存放索引，数据都在叶子节点，中间节点可以存放更多的索引数据，数结构可以更矮胖，访问子节点次数少了，进行磁盘IO次数也少了</li>
<li><strong>查询效率更高稳定</strong>：因为每次查询从根节点到叶子节点的路径长度都相同，查询时间都差不多</li>
<li><strong>范围查询更高效</strong>：因为数据都在叶子节点，所以只需要遍历叶子节点的链表；而B树因为每个子节点都存在数据，所以要遍历的节点更多</li>
<li><strong>遍历更高效</strong>：B+树只需要遍历叶子节点，B树需要层次遍历整棵树</li>
</ul>
<hr>
<p><strong>B+树索引 和 哈希索引 的区别</strong></p>
<p><strong>B+树索引</strong></p>
<ul>
<li>有序，除了查找还可以进行排序分组</li>
</ul>
<p><strong>哈希索引</strong></p>
<ul>
<li>哈希索引时间为O(1)</li>
<li>失去有序性，无法用于排序分组</li>
<li>只能进行精确查找，不能用于范围查找</li>
</ul>
<p>InnoDB有一个自适应哈希索引，当某个索引值使用很频繁，会在B+Tree索引之上在创建一个哈希索引，让原来的索引具有哈希索引的快速查找功能。</p>
<hr>
<p><strong>红黑树</strong>和<strong>AVL树</strong>因为本质上都是二叉树，树的高度远高于 B树，所以需要进行 磁盘IO 的次数过多，不适合作为索引</p>
<hr>
<h3 id="事务-3">事务 3</h3>
<p>事务是一个操作序列，其中的操作要么都执行，要么都不执行，以 BEGIN TRANSACTION 开始， 以 ROLLBACK/COMMIT 结束</p>
<p><strong>实现原理</strong></p>
<ul>
<li>日志文件 - redo log / undo log</li>
<li>锁技术</li>
<li>MVCC</li>
</ul>
<p>原子性通过 undo log 实现</p>
<p>持久性通过 redo log 实现</p>
<p>隔离性通过 读写锁 + MVCC 实现</p>
<p>一致性 通过 原子性、持久性、隔离性 来实现</p>
<hr>
<h3 id="数据库引擎-3">数据库引擎 3</h3>
<p><strong>InnoDB和MyISAM区别</strong></p>
<ul>
<li><strong>事务</strong>：MyISAM 不支事务；lnnoDB 是事务类存储引擎</li>
<li><strong>并发</strong>：MyISAM 只支持表级锁；InnoDB 支持表级锁和行级锁，默认为行级锁</li>
<li><strong>外键</strong>：MyISAM 不支持外键；InnoDB 支持外键</li>
<li><strong>备份</strong>：MyISAM 不支持在线热备份；InnoDB 支持在线热备份；</li>
<li><strong>崩溃恢复</strong>：MyISAM 崩溃后发生损坏的概率比 InnoDB 高，而且恢复速度也慢</li>
<li><strong>其他</strong>：MyISAM 支持空间数据索引（地理信息）和压缩表（减小所占空间）；InnoDB 相对的要占用更多磁盘空间</li>
</ul>
<p><strong>InnoDB 内部做了很多优化</strong></p>
<ul>
<li>从磁盘读数据时采用<strong>可预测读</strong>（将用户很可能用到的数据预先加载到缓存池）</li>
<li>会创建<strong>自适应哈希索引</strong>，加快读的速度</li>
<li>有<strong>插入缓冲区</strong>（主要是针对非聚集索引，叶子节点的插入不再是顺序的了）来加速插入操作</li>
</ul>
<hr>
<h3 id="Redo、Undo-Log-3"><a href="https://www.cnblogs.com/xinysu/p/6555082.html">Redo、Undo Log 3</a></h3>
<p><strong>Undo Log</strong></p>
<p>Undo Log 用于存放数据被修改前的值，如果修改出现异常，可以通过 undo log 实现回滚操作，因为要实现回滚，所以 undo log 也是逻辑日志。Undo Log 也是实现 MVCC 的关键</p>
<p><strong>Redo Log</strong></p>
<p>Redo Log 用于记录事务对数据页的修改，是物理日志</p>
<p>对数据库中数据进行 UPDATE 操作时，需要将数据从磁盘读取到 buffer pool，然后在 buffer pool 中修改数据， redo log 中就记录了这些修改操作。如果更新的数据还没有同步到磁盘但是发生 crash 了，可以通过 redo log 中的记录恢复之前的修改操作（重做），保证了事务的持久性</p>
<p>redo log 和 binary log 的主要区别在于</p>
<ul>
<li>redo log 是物理日志，用于记录对数据页做了什么修改； binary log 是逻辑日志，记录的是 sql 语句的原始逻辑</li>
<li>redo log 是存储引擎层产生的，用来实现事务的持久性，binary log 是数据库层产生的，用于恢复数据库和实现主从复制</li>
<li>redo log 是循环写，空间用完后会覆盖之前的记录；binary log 是追加写，文件到达一定大小会换一个文件，不会覆盖之前的记录</li>
<li>在事务开始后，修改操作就开始写在 redo log 中。事务提交之前，所执行的操作记录才会被写到 binary log 中，然后事务被提交。</li>
</ul>
<hr>
<h3 id="锁相关-2">锁相关 2</h3>
<p>乐观锁、悲观锁、行锁、表锁、意向锁</p>
<hr>
<p><strong>乐观锁和悲观锁</strong></p>
<ul>
<li><strong>悲观锁</strong>：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。<strong>应用于数据更新比较频繁的场景</strong>，ReentrantLock sychronized 这些独占锁就是悲观锁的实现。</li>
<li><strong>乐观锁</strong>：总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。<strong>应用于读多写少的场景</strong></li>
</ul>
<p><strong>ABA 问题</strong></p>
<p>当前事务读取的数据值是 A ，在此期间数据被改成 B 后又被改成 A。在此期间数据被修改过，但是系统认为它没有被修改过。<strong>解决办法</strong>是添加一个版本号，在比较数据时通过比较版本号来确认数据是否被修改</p>
<hr>
<p><strong>封锁粒度</strong></p>
<p>MySQL提供两种封锁粒度：<strong>表级锁</strong>和<strong>行级锁</strong></p>
<p><strong>好处</strong>：封锁粒度越细，发生锁争用的可能性就越小，系统并发性就越高</p>
<p><strong>坏处</strong>：系统开销大，因为加锁、释放锁、检查锁的状态都要消耗资源</p>
<hr>
<p><strong>互斥锁 X 锁</strong>：对数据加上 X 锁之后只允许该事务对数据进行读和修改，其他事务不能对该数据加任何锁</p>
<p><strong>共享锁 S 锁</strong>：对数据加 S 锁之后事务能对数据进行读操作但是不能进行修改，其他事务只能对该数据加 S 锁</p>
<p><strong>意向锁</strong></p>
<ul>
<li>一个事务在获取某一行对象的S锁之前必须要获得整个表的IS锁或更强的锁</li>
<li>一个事务在获得某一行对象的X锁之前，必须先获得整个表的IX锁</li>
<li><strong>锁的兼容关系</strong>：X 锁不兼容任何锁，S 锁和 IX 锁不兼容，其余均兼容</li>
</ul>
<p>在存在行级锁的情况下，如果没有意向锁，一个事务要对表加X锁就要检查是否有其他事务对表中任意一行加了X锁。有意向锁之后，要对表加X锁只需要检查有没有其他事务对表加了X/IS/IX/S锁。如果有，表示其他事务正在使用这个表，加X锁失败</p>
<p>InnoDB 对 INSERT、UPDATE、UPDATE 语句会自动加 X 锁。对于普通 SELECT 语句不会加任何锁。显式加锁方法为：</p>
<p><strong>加S锁</strong>：SELECT * FROM table_name WHERE … <strong>LOCK IN SHARE MODE</strong></p>
<p><strong>加X锁</strong>：SELECT * FROM table_name WHERE … <strong>FOR UPDATE</strong></p>
<p>InnoDB的行锁是<strong>基于索引</strong>实现的，如果不通过索引访问数据，InnoDB会使用表锁。</p>
<p>（２）InnoDB<strong>间隙锁机制</strong>，以及InnoDB使用间隙锁的原因。</p>
<p>（３）在不同的<strong>隔离级别</strong>下，InnoDB的锁机制和<strong>一致性</strong>读策略不同。</p>
<p>（４）ＭySQL的恢复和复制对InnoDB锁机制和一致性读策略也有较大影响。</p>
<p>（５）锁冲突甚至死锁很难完全避免。</p>
<hr>
<h3 id="MVCC-2">MVCC 2</h3>
<p>多版本并发控制，用于实现 <strong>读提交</strong> 和 <strong>可重复读</strong> 两种隔离级别，<strong>通过一份数据临时保留多个版本的方法来实现并发控制</strong></p>
<p>MVCC 的做法是让每个事务读到的是当前数据库的一个快照。 MVCC 更新一条数据时，不是用新数据覆盖旧数据，旧数据只会被标记为过时，然后在别处增加新数据。这样就会存储多个版本的数据，但是只有一个是最新的</p>
<p>数据库每个表中有两列关于 MVCC 的隐藏记录</p>
<ul>
<li><strong>数据行版本号</strong> (TRX_ID)：表示该行数据的版本</li>
<li><strong>回滚指针</strong> (ROLL_PTR)：指向上一个 Undo log</li>
</ul>
<p>通过控制读取数据的版本来实现并发控制：</p>
<ul>
<li><strong>读提交</strong>：事务总是读这个数据最近一次被 commit 的版本</li>
<li><strong>可重复读</strong>：事务只读取当前事务开始前最后一次被 commit 的版本</li>
</ul>
<p>通过加锁来实现并发的效率可能会非常差，一旦表被加上互斥锁，其他事务就不能进行读操作了。<strong>通过版本号减少了锁的争用，提高了系统性能</strong></p>
<hr>
<p><strong>Undo Log</strong></p>
<p>InnoDB 通过 Undo log 实现 MVCC。当对数据进行修改操作后，会生成一个 Undo log，Undo 中存储的是老版本的数据(被修改之前的值)，然后新数据行的回滚指针指向该 Undo log，当一个旧事务需要读取数据，需要通过回滚指针在undo链找到<strong>满足其可见性的记录</strong></p>
<p>其中 INSERT 生成的日志在提交后会被删除，DELETE 作为一种特殊的 UPDATE，还会将 DEL 位改为1</p>
<hr>
<p><strong>Read View</strong></p>
<p>在InnoDB中，创建一个新事务的时候还会将<strong>当前活跃着的事务</strong>列表创建一个 Read View</p>
<p><strong>可见性算法比较</strong></p>
<p>就是当前知道了读的数据行版本号，还有一个还活跃着的事务的一个数组。然后判断当前数据行在当前隔离级别下是否可读</p>
<p>假设当前正在读的数据行的版本号为 trx_id</p>
<p>read view中最老的事务id为trx_ id_min，最新的事务为 trx_id_max</p>
<ul>
<li>如果 trx_id &lt; trx_ id_min，说明这个数据在当前事务开始之前已经被提交，是可见的</li>
<li>如果 trx_id_current &gt; trx_id_max ，说明该行数据在当前事务创建后才被创建并提交，不应该被看见。</li>
<li>如果trx_ id_min &lt;= trx_id &lt;= trx_id_max
<ul>
<li>如果trx_id在表中，表示对应的事务还没有提交，快照不可用</li>
<li>反之表示已经提交，可以读</li>
</ul>
</li>
</ul>
<p>如果不可读，会通过回滚指针查找undo log，返回一条可见的记录。</p>
<p><strong>根据隔离级别</strong></p>
<ul>
<li>提交读会在事务每次进行 SELECT 操作的时候创建一个 READ VIEW</li>
<li>重复读只会在第一次读的时候创建一个 READ VIEW ，以后都是复用之前的 READ VIEW</li>
</ul>
<hr>
<p><strong>快照读和当前读</strong></p>
<p>只有 SELECT 操作是快照读，读取的快照数据</p>
<p>修改操作都是当前读，对数据进行加锁确保读取到的是最新的数据</p>
<p>MVCC 只是避免了 SELECT 操作的锁争用</p>
<hr>
<p><strong>MySQL 如何解决幻读</strong></p>
<p>MVCC 在可重复读隔离级别下加上 Next-Key Lock 可以避免幻读</p>
<p>Next-Key Lock 是由 Record Lock 和 Gap Lock 组成</p>
<p><strong>两者结合后，在搜索的区域内，InnoDB首先会给区域内的索引项加锁（Record Lock），还会给键值在范围内但不存在的记录加锁（Gap Lock），这样就实现了整个区域的上锁。</strong></p>
<p>举例来说，假如user表中只有101条记录，其empid的值分别是 1,2,…,100,101，下面的SQL：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from  user where user_id &gt; 100 for update;</span><br></pre></td></tr></table></figure>
<p>是一个范围条件的检索，InnoDB不仅会对符合条件的user_id值为101的记录加锁，也会对user_id大于101（这些记录并不存在）的“间隙”加锁。</p>
<p>产生幻读的原因是，行锁只能锁住行，但是新插入记录这个动作，要更新的是记录之间的“间隙”。因此，为了解决幻读问题，InnoDB 只好引入新的锁，也就是间隙锁 (Gap Lock)。</p>
<hr>
<h3 id="连接表-2">连接表 2</h3>
<p>inner join/left join/right join区别</p>
<ul>
<li>只返回两张表匹配的记录，这叫内连接（inner join）</li>
<li>返回匹配的记录，以及表 A 多余的记录，这叫左连接（left join）</li>
<li>返回匹配的记录，以及表 B 多余的记录，这叫右连接（right join）</li>
<li>返回匹配的记录，以及表 A 和表 B 各自的多余记录，这叫全连接（full join）</li>
</ul>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//连接语句</span><br><span class="line">select * from tableA inner join tableB on tableA.id = tableB.id;</span><br></pre></td></tr></table></figure>
<p>inner join 不加条件的结果和 cross join 一样；cross join 加上条件的结果和 inner join 一样</p>
<p>inner join 属于内连接；left join / right join / full join 属于外连接；cross join 属于交叉连接</p>
<hr>
<h3 id="主从复制">主从复制</h3>
<p>主从复制就是指把数据从一个MySQL主服务器复制到多个从服务器。从服务器可以复制主服务的所有数据或特定的表，采用异步方式。</p>
<p><strong>实现原理</strong></p>
<ul>
<li>主服务器 <strong>binary log dump</strong>：将主服务器中数据增删改日志写到binary log中</li>
<li>从服务器<strong>IO线程</strong>：将主服务器binary log中的信息读取并写入到到自己的relay log中</li>
<li>从服务器<strong>SQL线程</strong>：读取relay log，解析出主服务器进行的数据修改并在从服务器重新执行，来保证数据的一致性</li>
</ul>
<p><strong>实现了读写分离</strong>，主服务器用来写，从服务器用来读</p>
<ul>
<li>缓解了锁的争用，即使主服务器被锁，从服务器依然可以读数据</li>
<li>从服务器可以使用MyISAM，提升查询性能并节省系统开销</li>
<li>增加冗余，提高可靠性</li>
<li>降低单个服务器磁盘IO访问频率，提高单个机器IO性能</li>
</ul>
<hr>
<h3 id="三大范式">三大范式</h3>
<ul>
<li><strong>1NF</strong>：属性不可分割
<ul>
<li>根据<strong>实际需求</strong>来定，以地址为例</li>
</ul>
</li>
<li><strong>2NF</strong>：非主属性完全依赖于主属性
<ul>
<li>B 完全依赖于 A ，就是指 A 中的所有属性<strong>唯一</strong>决定 B ，少了不能唯一决定，多了会冗余。不满足这个规则会导致出现冗余数据</li>
<li><strong>依赖</strong>是指主属性确定的情况下可以唯一确定非主属性，不可能寻在两条记录，主属性相同但是非主属性不一致</li>
<li><strong>完全依赖</strong>是指一旦主属性少一个值，依赖关系就不存在</li>
</ul>
</li>
<li><strong>3NF</strong>：非主属性不传递依赖于主属性
<ul>
<li>例如：学生 -&gt; 所在学院 -&gt; 学院院长</li>
</ul>
</li>
</ul>
<h3 id="视图">视图</h3>
<p>是从一张或多张表中导出的虚拟的表，其中的内容由查询语句定义，视图中不存储数据，其中的数据还是从实际的表中查询得来</p>
<ul>
<li><strong>单表视图</strong>一般用于查询和修改，会改变基本表的数据</li>
<li><strong>多表视图</strong>一般用于查询，不会改变基本表的数据</li>
</ul>
<hr>
<h2 id="Redis">Redis</h2>
<hr>
<h3 id="数据结构-9">数据结构 9</h3>
<p>几种数据结构和底层实现，用来做什么，<strong>zset底层原理</strong></p>
<hr>
<p><strong>String</strong></p>
<ul>
<li>普通的 key/value 存储都可以归结为 string 类型</li>
<li>value 不仅是 string， 也可以是数字</li>
<li>是动态字符串，可以被修改，底层类似于 ArrayList，是一个字符数组</li>
<li>有三种编码：int 保存整数值；raw 保存长字符串；embstr 保存短字符串</li>
</ul>
<p><strong>应用场景</strong></p>
<ul>
<li>因为是二进制安全的，可以存放图片</li>
<li>可以作为计数器，统计在线人数，关注者人数</li>
<li>实现分布式 session</li>
</ul>
<hr>
<p><strong>List</strong></p>
<ul>
<li>简单的字符串列表</li>
<li>底层是双向链表 linkedlist，并不是数组，所以插入删除很快，定位很慢</li>
<li>可以实现 栈、队列、阻塞队列 的功能</li>
</ul>
<p><strong>应用场景</strong></p>
<ul>
<li>实现消息列表或者简单的消息队列</li>
<li>利用 lrange 实现分页功能</li>
</ul>
<hr>
<p><strong>Set</strong></p>
<ul>
<li>String 类型的<strong>无序</strong>集合，集合中的元素没有重复，相当于 Java 中的 HashSet</li>
<li>整数也会转为 String 类型进行存储</li>
<li>内部实现是 hashtable 相当于一个特殊字典，每个 key 都是一个字符串对象，value 都为 NULL</li>
</ul>
<p><strong>应用场景</strong></p>
<ul>
<li>利用交集操作实现共同关注者的查询</li>
<li>根据 set 的特性可以进行全局去重</li>
</ul>
<hr>
<p><strong>Zset（重点）</strong></p>
<p><a href="https://zsr.github.io/2017/07/03/redis-zset%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0/">https://zsr.github.io/2017/07/03/redis-zset%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0/</a></p>
<ul>
<li>和 set 相比， zset 中的对象是有序的，每个元素有一个 score 属性，以此作为排序依据</li>
<li>同时包含一个<strong>字典 hash</strong>  和一个<strong>跳跃表 skiplist</strong></li>
<li><strong>跳跃表</strong>按 score 大小从小到大保存所有集合元素，根据 score 查 member</li>
<li><strong>字典</strong>保存 member 到 score 的映射，根据 member 查找 score 的复杂度 O(1)</li>
<li>两个数据结构通过指针来共享相同元素，不会浪费额外内存</li>
</ul>
<p><strong>跳跃表 skiplist 底层实现</strong></p>
<p>理想的跳跃表是上下两层链表的节点数有严格对应，查找过程就类似于二分查找，复杂度为 O(logN)，但是插入节点会破坏这种关系，维持这种关系要调整后面所有的节点，时间复杂度又会退化到O(n)，<strong>为了避免这一情况，Redis 的 skiplist 采用的实现方法是</strong></p>
<ul>
<li>上下两层节点没有严格对应关系</li>
<li>每个节点随机出一个层数 n，在第一层到第 n 层都插入这个节点</li>
<li>最大层数为 32</li>
<li>score 允许重复，score 相同的情况下根据数据内容进行字典排序</li>
<li>第一层是一个双向链表，可以以倒序获取一个范围的元素</li>
<li>每一个 forward 指针还有一个 <strong>span 变量</strong>，表示当前指针跨过多少节点，该变量用于<strong>计算元素排名</strong></li>
</ul>
<p><strong>skiplist 和 平衡树 的比较</strong></p>
<ul>
<li>skiplist 插入和删除操作只要修改相邻节点指针；平衡树会引发树结构的改变</li>
<li>skiplist 范围查找更简单，找到最小值之后对第一层进行若干遍历即可；平衡树还要通过中序遍历查找</li>
<li>实现相对来说更简单</li>
</ul>
<p><strong>应用场景</strong></p>
<ul>
<li>范围查找，TOP N 排行榜应用</li>
</ul>
<hr>
<p><strong>Hash</strong></p>
<ul>
<li>key 是一个字符串类型，value 是键值对集合</li>
<li>相当于 Java 中的 HashMap，也是通过 数组 + 链表 解决哈希冲突</li>
</ul>
<p><strong>应用场景</strong></p>
<ul>
<li>存储用户信息、商品信息等</li>
</ul>
<hr>
<h3 id="持久化机制-5">持久化机制 5</h3>
<hr>
<p><strong>快照 RDB 持久化</strong></p>
<p>通过创建快照来获取内存中的数据在某个时间点上的副本</p>
<p>生成快照时，程序会对数据库中的键进行检查，已过期的键不会被保存到新建的 RDB 文件中</p>
<p>Redis 使用操作系统的多进程**写时复制技术（Copy On Write）**来实现快照持久化，保证在子线程生成 RDB 快照的同时，主线程依然可以写入数据，具体步骤为：</p>
<ul>
<li>持久化时， Redis 使用 bgsave 命令调用 glibc 函数 fork 一个子进程，快照持久化完全交给子进程处理，继续处理客户端请求。子进程刚产生时和父进程共享内存中的代码段和数据段，所以子进程刚刚被创建时，内存的增长几乎没有明显变化</li>
<li>bgsave 的子进程可以共享主进程的所有内存数据，读取主线程的数据并写入到 RDB 快照中</li>
<li>主线程执行写指令修改数据时，会生成一个修改后的数据的副本，子进程直接读取这个副本数据写入到 RDB 快照中，所以不会出现数据不一致的情况</li>
</ul>
<p>可以把这个快照复制到其他服务器中来创建具有相同数据副本（主从结构）</p>
<p>系统发生故障会丢失最后一次创建快照后的数据</p>
<p>频繁生成 RDB 快照的问题：</p>
<ul>
<li>频繁对磁盘进行写入操作，磁盘压力过大</li>
<li>使用 bgsave 来 fork 子进程的过程会阻塞主线程，</li>
</ul>
<p>默认配置是：</p>
<ul>
<li>15分钟后有1个key发生变化就创建快照</li>
<li>5分钟后有10个key发生变化就创建快照</li>
<li>1分钟后有10000个key发生变化就创建快照</li>
</ul>
<hr>
<p><strong>AOF 持久化</strong></p>
<p>将写命令添加到AOF文件中</p>
<p>可以设置同步频率，每秒将写入操作同步到磁盘中，这样系统崩溃时只会丢失1秒的数据</p>
<p><strong>问题是</strong>，随着写请求越来越多，AOF文件会越来越大。Redis提供了将AOF<strong>重写</strong>的特性来去除冗余的写命令。新的 AOF 文件和旧 AOF 文件保存的数据库状态完全一致，但是体积小的多。通过精简指令，（例如，原 AOF 对数据进行了一系列增删，新 AOF 只保留创建最终结果的那一句语句）</p>
<ul>
<li>重写的时候 fork 一个子进程，主进程仍然接收新的命令，子进程对原 AOF 文件扫描并把新的写命令追加到新创建的 AOF 文件中。子进程执行期间，主进程接收到的新写命令会存入到<strong>重写缓冲区</strong>，子进程完成重写之后，会先把缓冲区的命令追加到新的 AOF 文件，然后用新 AOF 文件替换旧 AOF 文件</li>
</ul>
<p>Redis4.0有一个混合持久化，AOF重写的时候直接把内存副本以 RDB 的方式写到 AOF 文件的开头，然后再将重写缓冲区的写命令以 AOF 方式写入到文件，然后用新 AOF 替换旧 AOF。兼顾了 RDB 的快速加载特性和 AOF 的特性来避免丢失过多数据。</p>
<hr>
<h3 id="主从复制-3"><a href="https://www.cnblogs.com/yangming1996/p/12594991.html">主从复制 3</a></h3>
<p><strong>复制过程</strong></p>
<ul>
<li>从服务器向主服务器发送 SYNC 命令</li>
<li>主服务器创建快照文件，发送给从服务器，期间在缓冲区中记录写命令，快照发送完成之后，服务器先执行缓冲区的写命令，并向从服务器发送缓冲区中的写命令</li>
<li>从服务器丢弃所有旧数据并阻塞自己，载入主服务器发来的快照文件，然后接收主服务器发来的写命令</li>
<li>主服务器每执行一次写命令，就向从服务器发送一次写命令</li>
</ul>
<p>主服务器中的复制缓冲区是一个 FIFO 的队列，大小默认 1M，存储了最近的一些写命令，存储形式是 偏移量 + 字节值。每次加入新的写操作都会更新偏移量值，从服务器收到传输的命令后也会更新自己的偏移量值。</p>
<ul>
<li>主从节点的偏移量相同说明数据是同步的</li>
<li>缓冲区中新命令写入后旧命令就会出队列</li>
<li>某个从服务器断线重连之后发送同步命令给主服务器并带上自己的偏移量
<ul>
<li>如果偏移量在缓冲区中，就把偏移量之后的所有命令发送给从服务器</li>
<li>如果不在缓冲区，就要进行一次全量复制（此时主服务器进行 <strong>全量备份</strong> 时可能会造成毫秒级卡顿）</li>
</ul>
</li>
</ul>
<p>从服务器不会主动淘汰过期 key，主服务器处理掉过期的 key 后会向从服务器发送 del 命令来同步淘汰数据</p>
<p>主从复制可能存在的问题：</p>
<ul>
<li>一旦<strong>主节点宕机</strong>，<strong>从节点</strong>晋升<strong>主节点</strong>，同时需要修改<strong>应用方</strong>的<strong>主节点地址</strong>，还需要命令所有<strong>从节点</strong>去<strong>复制</strong>新的主节点，整个过程需要<strong>人工干预</strong>。</li>
<li>如果<strong>从节点发生中断</strong>之后发起重新同步不成功，需要进行全量同步，此时主服务器进行<strong>全量备份</strong>时可能会造成<strong>毫秒级卡顿</strong></li>
</ul>
<p><strong>主从链</strong></p>
<p>随着负载上升，主服务器可能无法很快更新所有从服务器，主从链通过中间加入一层服务器来分担主服务器的复制工作。中间层服务器是主服务器的从服务器，又是下层服务器的主服务器。</p>
<hr>
<p><strong>实现 Redis 集群高可用</strong></p>
<p>哨兵机制，是一个管理多个 Redis 实例的工具</p>
<ul>
<li><strong>集群监控</strong>：监控 主从 服务器的 Redis 是否正常工作</li>
<li><strong>消息通知</strong>：如果有 Redis 实例有故障，会发送消息给管理员</li>
<li><strong>故障转移</strong>：如果主节点不能正常工作，，会自动将其中一个从节点升级为新的主节点，然后将其他从节点指向新的主节点</li>
</ul>
<p><strong><a href="https://www.cnblogs.com/kevingrace/p/9004460.html">哨兵节点工作方式</a></strong></p>
<ul>
<li>每个哨兵节点以<strong>每秒一次</strong>的频率向<strong>主服务器、从服务器和其他哨兵节点</strong>发送 PING 命令</li>
<li>如果一个<strong>实例</strong>距离最后一次回复 PING 的事件超过了限定值，这个实例就会被哨兵标记为<strong>主观下线</strong></li>
<li>如果主服务器被标记为<strong>主观下线</strong>，其他正在监视该服务器的哨兵节点要以每秒一次的频率确认主服务器进入了主观下线状态</li>
<li>如果一个主服务器被判定为主观下线，并且有一定数量的哨兵节点在指定时间范围内同意该判断，这个主服务器就被标记为<strong>客观下线</strong>，进入客观下线后才可以进行<strong>故障转移</strong>操作，实施故障转移还需要获得大多数哨兵的授权。</li>
<li>一般情况下哨兵会每10秒向主服务器和从服务器发送 INFO 命令。当主服务器被标记为客观下线，哨兵向所有从服务器发送 INFO 命令的频率从 10 秒一次改为 每秒一次</li>
<li>如果没有足够数量的哨兵同意主节点下线，<strong>客观下线状态就被移除</strong>；如果主节点重新向哨兵返回 PING 的有效回复，<strong>主观下线会被解除</strong></li>
</ul>
<hr>
<h3 id="Redis为什么速度快-2"><a href="https://zhuanlan.zhihu.com/p/81195864">Redis为什么速度快 2</a></h3>
<ul>
<li>纯内存操作，不需要进行磁盘 IO</li>
<li>单线程，保证了系统没有上下文切换的开销
<ul>
<li>单线程只是只有一个线程来处理网络请求</li>
<li>为了发挥多核 CPU 优势，可以创建多个 Redis 实例来处理网络请求</li>
</ul>
</li>
<li>数据结构简单，对数据的操作也简单</li>
<li>采用 IO多路复用机制来同时监听多个 socket，非阻塞 IO</li>
</ul>
<hr>
<p>Redis 是单线程是因为内部使用<strong>文件事件处理器</strong>，这个处理器是单线程的</p>
<p>Redis采用<strong>IO多路复用机制来同时监听多个socket</strong>，根据socket的事件选择对应的事件处理器进行处理。</p>
<p>文件处理器包括4个结构：</p>
<ul>
<li>多个socket</li>
<li>IO多路复用程序</li>
<li>文件事件分派器</li>
<li>事件处理器</li>
</ul>
<p><strong>多个socket可能会并发产生不同的操作，每个操作对应不同的文件事件；IO多路复用程序会监听多个socket，将socket产生的事件放入队列中排队；事件分派器每次从队列中取出一个事件，把它交给对应的事件处理器处理。</strong></p>
<hr>
<h3 id="跳表-2">跳表 2</h3>
<p>构造方法，为什么不用红黑树</p>
<ul>
<li>是一个多层结构，最下层是双向链表，按序存储所有的元素，上层是逐渐稀疏的链表</li>
<li>上层的节点记录了 forward 指针指向的下一个节点地址</li>
<li>查找的时候从上往下快速找到对应区间，然后找到对应位置</li>
</ul>
<p><strong>和红黑树相比</strong></p>
<ul>
<li>实现更加简单</li>
<li>插入删除节点只涉及前后节点指针的改变；平衡树则会涉及到旋转，子树结构的改变</li>
<li>范围查找时跳表只要找到端点值然后在底层链表遍历即可；平衡树还要通过一定中序遍历算法</li>
</ul>
<hr>
<h3 id="热点缓存">热点缓存</h3>
<p><strong>MySQL 里有 2000w 数据，Redis 中只存 20w 的数据，如何保证 Redis 中的数据都是热点数据?</strong></p>
<ol>
<li>volatile-lru：从设置过期时间的数据集中挑选最近最少使用的数据淘汰</li>
<li>volatile-ttl：从设置过期时间的数据集中挑选将要过期的数据淘汰</li>
<li>volatile-random：从设置过期时间的数据集中任意选择数据淘汰</li>
<li>allkeys-lru：内存不足时，从所有键中淘汰最近最少使用的key</li>
<li>allkeys-random：内存不足时，选择任意的键淘汰</li>
<li>volatile-lfu：从设置过期时间的数据集中选择访问频率最低的淘汰</li>
<li>allkeys-lfu：从所有键中选择访问频率最低的淘汰</li>
</ol>
<p>lfu（Least Frequently Used）统计的是访问频率，将一定时间内被访问次数最少的键淘汰</p>
<hr>
<h3 id="缓存穿透、缓存击穿、缓存雪崩概念和解决办法">缓存穿透、缓存击穿、缓存雪崩概念和解决办法</h3>
<hr>
<p><strong>缓存穿透</strong></p>
<p>客户端大量请求一些根本不存在于缓存中的 key，导致这些请求穿过缓存直接落到数据库上</p>
<p><strong>解决办法</strong></p>
<ul>
<li>将所有可能的请求值放入布隆过滤器，收到的请求如果不在过滤器中直接拦截</li>
<li>如果一个 key 的查询结果为 null，将 key-null 键值对也加入缓存，并设置一个过期时间</li>
</ul>
<hr>
<p><strong>缓存击穿</strong></p>
<p>某个热点缓存突然失效，大量请求落到服务器上（和缓存雪崩的区别是<strong>针对某一个 key 的缓存</strong>）</p>
<p><strong>解决办法</strong></p>
<ul>
<li>设置热点数据不过期</li>
<li>如果有多个线程向服务器查询该数据，就用一个互斥锁锁住该数据，等到查询到了数据并存入缓存，其他线程直接从缓存中取数据</li>
</ul>
<hr>
<p><strong>缓存雪崩</strong></p>
<p>缓存在同一时间内大面积失效，所有请求都落到数据库上，导致数据库短时间受到大量请求</p>
<ul>
<li>缓存集体到了过期时间</li>
<li>服务器突然宕机，Redis 服务不可用</li>
</ul>
<p><strong>解决办法</strong></p>
<ul>
<li>随机设置缓存的过期时间，可以在原来过期时间的基础上加上一个随机值</li>
<li>使用 redis 集群并将热点数据分布在不同的 redis 服务器上</li>
</ul>
<hr>
<h3 id="布隆过滤器">布隆过滤器</h3>
<p><strong>为什么不用 HashMap</strong></p>
<ul>
<li>HashMap 存储容量占比更高，而且负载因子的存在导致空间不能被用满</li>
<li>布隆过滤器的数据结构占用空间少，但是返回结果是概率性</li>
</ul>
<p><strong>原理</strong></p>
<ul>
<li>初始是一个 m 位的列表，每一位都置 0</li>
<li>添加数据时
<ul>
<li>使用多个 hash 函数对 key 进行计算得到一个索引值</li>
<li>然后对列表长度 m 进行取模运算得到一个位置</li>
<li>每个 hash 函数都会计算得到不同的位置</li>
<li>将这些位置的值都置 1</li>
</ul>
</li>
<li>查询时
<ul>
<li>也对 key 使用多个 hash 函数计算最后得到位置</li>
<li>查看每个位置是否都为 1</li>
<li>如果有一个不为 1，就肯定不存在这个 key</li>
<li>如果都为 1，这个 key 可能存在，因为这个位置的 1 也有可能是其他 key 导致的</li>
</ul>
</li>
<li>性能需要在 <strong>hash 函数数量</strong> 和 <strong>布隆过滤器长度</strong> 之间做权衡</li>
</ul>
<p><strong>应用场景</strong></p>
<ul>
<li>解决 redis 的缓存穿透问题</li>
<li>业务中判断用户是否读过某文章，看过某视频。会有一定误判率，可能实际没读过但被判定为读过</li>
</ul>
<hr>
<h3 id="事务相关">事务相关</h3>
<p>Redis 中的事务</p>
<ul>
<li>是一组命令的集合</li>
<li>是一个单独的隔离操作
<ul>
<li>其中所有的命令都会按顺序执行，执行过程中不会其他请求打断</li>
</ul>
</li>
<li>事务是一个原子操作，其中命令要么全部执行，要么全部不执行</li>
<li>操作无法回滚</li>
</ul>
<p><strong>开启事务的步骤</strong></p>
<ul>
<li>用 <strong>MULTI</strong> 命令开启一个事务</li>
<li>输入要执行的指令，这些指令会被放到队列中</li>
<li>调用 <strong>EXEC</strong> 命令会让队列中的所有命令被执行</li>
<li>调用 <strong>DISCARD</strong> 命令会清空事务队列，并放弃执行事务</li>
<li>如果发送 EXEC 命令前用户掉线， redis 也会清空事务队列</li>
<li><strong>WATCH</strong> 命令可以监控一个或多个键，一旦其中有一个键被修改或删除，之后的事务就不会被执行
<ul>
<li>类似于 乐观锁 CAS 的机制</li>
<li>对键的监视从执行 WATCH 开始，到 EXEC 结束，保证事务在所监视的键没有被修改的前提下被执行</li>
</ul>
</li>
</ul>
<p><strong>报错机制</strong></p>
<ul>
<li>命令有<strong>语法错误</strong>，执行 EXEC 会直接报错，任何指令都不会执行</li>
<li>命令出现<strong>运行错误</strong>，错误的命令不会执行，但是事务中的其他命令仍然会被执行</li>
</ul>
<hr>
<p><strong>Redis 分布式锁</strong></p>
<p><strong>SETNX 指令</strong></p>
<p>使用 SETNX 指令插入一个键值对，如果 Key 存在，就会返回 False，说明对象正处于锁定状态，获取锁失败；否则插入成功，返回 True。可以使用 EXPIRE 指令为一个键值对设置一个过期时间，避免锁释放失败的问题</p>
<p><strong>RedLock算法</strong></p>
<p>使用多个 Redis 实例来实现分布式锁，保证发生单点故障时仍然可用</p>
<ul>
<li>尝试从 N 个互相独立的 Redis 实例获取锁</li>
<li>只有当获取锁消耗的时间小于锁过期的时间，并且获取超过半数的锁时，才认为锁获取成功</li>
<li>如果获取失败，就释放每个实例上的锁</li>
</ul>
<hr>
<h3 id="其他问题">其他问题</h3>
<p><strong>加入主服务器写入新的数据，但是从服务器没有来得及复制，该如何查询</strong></p>
<hr>
<p><strong>10亿个用户点赞 判断是否点过赞</strong></p>
<ul>
<li>布隆过滤器，但是不一定精确，可能用户没有点过赞但被判定为点过</li>
</ul>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>数据库</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统补充</title>
    <url>/2021/04/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%A1%A5%E5%85%85/</url>
    <content><![CDATA[<h3 id="操作系统">操作系统</h3>
<p>操作系统是一个管理软硬件资源，调度各类作业从而方便用户使用的软件</p>
<p>管理 处理机、存储器、设备和文件</p>
<span id="more"></span>
<hr>
<h3 id="进程间通信">进程间通信</h3>
<p><strong>IPC 是什么</strong></p>
<p>每个进程有自己的地址空间，进程的全局变量在另一个进程中是看不到的。所以进程间交换数据必须通过内核，通过在内核中开辟一块缓冲区，A进程把数据放进去，B进程把数据取走，这种机制叫 IPC</p>
<h4 id="信号">信号</h4>
<p>一般用来通知进程发生了异步事件，任何进程都不需要监听信号是否到来。信号例如键盘发来中断信号</p>
<h4 id="消息队列">消息队列</h4>
<p>是消息的链表，存放在内核中，可以向另一个进程发送数据块，每个数据块都有对应的类型。和管道一样，队列大小有限制，不过克服了管道只能承载无格式字节流的缺点，并且可以双向通信</p>
<h4 id="共享内存">共享内存</h4>
<p>两个进程中不同的虚拟地址空间映射到同一个物理地址，指向的这块区域就是共享内存</p>
<h4 id="信号量">信号量</h4>
<p>主要用来解决互斥同步的问题</p>
<h4 id="管道">管道</h4>
<h4 id="命名管道">命名管道</h4>
<h4 id="socket">socket</h4>
<h4 id="总结">总结</h4>
<p>共享内存效率最高，但是不能跨主机通信</p>
<hr>
<h3 id="子进程">子进程</h3>
<p>调用 fork ，根据现有的进程复制出一个新进程，是原进程的子进程，相当于克隆了自己。复制时，在虚拟地址空间中，子进程会复制父进程的代码段和数据段；在物理空间，子进程会先和父进程共享物理空间，等到父子进程涉及对物理空间修改时，再给子进程分配物理空间</p>
<hr>
<h3 id="进程上下文切换">进程上下文切换</h3>
<p><strong>上下文</strong>就是指 CPU 寄存器和程序计数器，这些就是所谓的 CPU 环境</p>
<ul>
<li><strong>指令寄存器</strong>存储了当前要执行的指令</li>
<li><strong>程序计数器</strong>存储下一条指令的地址</li>
</ul>
<p><strong>上下文分为</strong>用户级上下文、寄存器上下文和系统级上下文</p>
<p>在进程开始运行前，要先设定好 CPU 寄存器 和 程序计数器</p>
<p>进程在 用户态 和 内核态 进行切换时，也会发生上下文切换</p>
<hr>
<h3 id="进程组">进程组</h3>
<p>进程组就是一些进程的组合，他们之间存在父子、兄弟之间的关系。进程组方便对进程进行批量管理</p>
<hr>
<h3 id="守护进程">守护进程</h3>
<p>进程和一个会话关联，而会话又和一个控制中断关联。中断关闭后，对应的会话中的所有进程会被关闭。为了让进程可以不受终端的掌控，引入了<strong>守护进程</strong>，这种进程可以在后台服务，有较长的生命周期。</p>
<p>大致步骤是：创建子进程，父进程退出，所有工作在子进程中进行，形式上脱离了终端；在子进程中创建新的会话，让进程完全独立</p>
<hr>
<h3 id="PCB-进程控制块">PCB 进程控制块</h3>
<p>PCB 是系统为了描述和控制进程的运行而定义的一个数据结构，其中存储了操作系统所需的关于进程的全部信息，<strong>是进程存在的唯一标志</strong>。有不同的组织形式，索引表或者链表</p>
<hr>
<h3 id="进程到线程">进程到线程</h3>
<ul>
<li>最早的 CPU <strong>一次只能执行一个程序</strong></li>
<li><strong>引入进程</strong>后可以支持多任务，但是也产生了新的问题
<ul>
<li>为每个进程分配资源开销较大</li>
<li>进程频繁切换开销较大</li>
<li>进程间通信复杂</li>
</ul>
</li>
<li>之后就引入在进程中开辟“小进程”来实现多任务，也就是<strong>线程</strong>
<ul>
<li>线程在进程内部共享很多进程的资源，分配资源开销不大</li>
<li>上下文切换只涉及寄存器内容的设置和保存</li>
<li>线程可以共享进程的部分地址空间，通信也不麻烦</li>
</ul>
</li>
</ul>
<p>操作系统中每个线程一般都会有 线程ID，一组寄存器值，栈，线程私有数据等</p>
<hr>
<h3 id="用户态和内核态的线程">用户态和内核态的线程</h3>
<p>现代的操作系统主要是，用户态实现线程在非阻塞时的切换，内核态实现内存阻塞时的切换</p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>读 Ray Dalio 的《To Help Put Recent Economic &amp; Market Moves in Perspective》</title>
    <url>/2018/12/28/%E8%AF%BBRay%20Dalio%E7%9A%84%E3%80%8ATo%20Help%20Put%20Recent%20Economic%20&amp;%20Market%20Moves%20in%20Perspective%E3%80%8B/</url>
    <content><![CDATA[<p>写这篇文章的目的是总结一下 Ray Dalio 文章的内容，并穿插一些自己的思考，以帮助自己更好的消化内容。</p>
<span id="more"></span>
<blockquote>
<p>Ray Dalio的这篇文章是发在美股大跌的时候，有许多人问到他现在的经济是怎么回事。他的做法是介绍他使用的分析经济的框架，目的是在知道了这个框架之后，人们有能力凭自己的思考明白经济在发生什么变化。所谓<strong>授人以渔</strong>。</p>
</blockquote>
<p>他总结了影响市场和经济状况的三个因素，分别是：</p>
<ol>
<li>生产力增长</li>
<li>短债务周期（5～10年）</li>
<li>长债务周期（50～75年）</li>
</ol>
<h3 id="生产力增长">生产力增长</h3>
<p>影响一个国家生产力增长的是竞争力和文化因素。竞争力基于与其它国家受良好教育的人的成本下的人的价值。</p>
<p><em>（the value of people as measured by the cost of comparably educated people in other countries）</em></p>
<p>我的理解是一个国家可以用更低的成本培养出优质人才，即有更高的人才产出效率时，这个国家的竞争力就优于其他国家。文化因素更为重要，是划分国家与国家区别的主要因素。它影响人对工作、存款、贪污、可靠性等决策。而这些决策与后续年份的增长呈高关联性。发达国家的生产力增长情况是增速变缓，该状况主要集中在人口的减少和自动化程度较高领域的工人减少。</p>
<h3 id="借贷周期">借贷周期</h3>
<p>借贷周期可以用来理解进几十年来的经济和市场变化。道理其实很简单，中央银行贷出钱流通到市场，提高了购买力，进而刺激了经济活动产出效益，促进经济增长；但是借出的钱是要还的，市场上的钱再被收回后，用在商品、服务和投资资产上的钱就减少了，由此经济活动减缓，经济出现负增长。</p>
<p>中央银行所做的就是对经济的调节作用：当经济松弛时，向市场贷出钱促进经济活动；当经济持续增长过后，适当踩刹车，以提高利息的方式适当回收流动资金。在经济增长时收紧货币政策是为了抑制通货膨胀，经济增长快但是产能有限最后带来的物价上涨。</p>
<p>Ray Dalio指出现在的美国就是在这一循环的末端，就是美联储通过加息的方式收回流动在市场上的钱，最终导致了股价下跌。具体过程为，加息变相降低了人们从其他投资渠道获得的收益，因为资金的时间价值因此变高，股市就是一例渠道。</p>
<h3 id="三大平衡">三大平衡</h3>
<p>市场是不断变化的，一系列经济行为的作用就是维持市场的几处保持平衡。在文章中一共提到的三类大平衡和政府促进这三大平衡的两类手段。</p>
<blockquote>
<h4 id="第一类平衡">第一类平衡</h4>
</blockquote>
<p>债务增长与偿债所需的收入和货币增长一致。借到的钱款被用来产生更多的现金流，带来收益，那么这种行为是可持续的。如果获得的现金流还不足以偿还债务利率，那么这种模式就是有问题的，会发生重大改变。</p>
<blockquote>
<h4 id="第二类平衡">第二类平衡</h4>
</blockquote>
<p>产能的利用率不能过高或过低。产能闲置导致工人失业，不利于经济发展；产能闲置过少会导致不良的通货膨胀，刺激央行实行货币紧缩政策。</p>
<blockquote>
<h4 id="第三类平衡">第三类平衡</h4>
</blockquote>
<p>预期现金回报率 &lt; 债券回报率 &lt; 股票回报率。这三类回报利差促进市场和经济的健康运作，因为他们创造了借款、贷款和生产，从而促进资金的健康流动。</p>
<h3 id="两类政策">两类政策</h3>
<p>为了维持这三类平衡，政府拥有两类政策。</p>
<blockquote>
<h4 id="货币政策">货币政策</h4>
</blockquote>
<p>货币政策是指央行通过改变货币的数量和价值来影响经济活动。当债务增长缓慢且产能过低时，央行增加金融系统中的货币数量，促进短期利率和国债利率相比与股票收益的下降。所以促使人们购买更多股票，推动股价上升。股价上升就意味着许多人手上的资产价值升高，从而有更多的钱进行借贷和消费。当债务过快且产能利用紧张时（意味着通货膨胀率上升），央行的措施和产生的影响就与之相反。央行所使用的三类货币政策为利率政策、量化宽松和针对消费者的货币刺激政策。当货币的短期利率降到零时，央行就采取量化宽松政策，即加印货币。</p>
<blockquote>
<h4 id="财政政策">财政政策</h4>
</blockquote>
<p>财政政策是指政府来管理信贷和货币的分布状况。政府可以通过消费和征税两种途径来影响经济，如果消费多，征税少，这就刺激经济发展；反过来就抑制经济发展。</p>
<p>总而言之，政策制定者通过这两种杠杆来打破这三类平衡以促进经济发展，又或者帮助调整这三类平衡来调节经济。Ray Dalio想传达的就是以上这些思想。通过这些思想，我以后可以观察市场的情况，并分析宏观上的原因，弄清楚这时候经济发生了什么事。</p>
<p><strong>原文链接：</strong><blockquote><footer><strong>Ray Dalio</strong><cite><a href="https://www.linkedin.com/pulse/help-put-recent-economic-market-moves-perspective-ray-dalio/">To Help Put Recent Economic & Market Moves in Perspective</a></cite></footer></blockquote></p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title>hexo command not found 的解决方法</title>
    <url>/2019/08/10/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>2019-9-26更新</p>
<p>来到英国后第一次写博客，又出现了这个问题。这次在.bash_profile里面已经配置了环境变量，所以想到可能是路径改变了。进入blog对应的目录输入</p>
<blockquote>
<p>npm install -g hexo-cli</p>
</blockquote>
<p>重新安装后，命令行显示了一条新的路径</p>
<blockquote>
<p>PATH=$PATH:/Users/simba/.npm-global/lib/node_modules/hexo-cli/bin</p>
</blockquote>
<p>将环境变量替换为这个路径后，能够成功使用hexo命令</p>
<span id="more"></span>
<hr>
<p>昨天版本1.0的博客初步施工完毕了，开开心心部署到了Github上后把终端关了就跑去玩了。今早想着再做些小改动于是重新打开终端输入hexo命令，结果发现…</p>
<blockquote>
<p>-bash: hexo: command not found</p>
</blockquote>
<p>首先想到的是重新安装hexo，在终端输入命令</p>
<blockquote>
<p>npm install -g hexo-cli</p>
</blockquote>
<p>结果仍然是command not found</p>
<p>在谷歌上搜索关键词，得到的回复有说是Node.js版本，我按照方法更新了之后还是没有解决问题。</p>
<p>最后通过添加环境变量解决了问题</p>
<p><small>把这个方法放到最后是因为最初安装的时候不需要配置环境变量就能使用，所以最先排除的就是这个可能</small></p>
<p>步骤很简单，找到hexo的安装路径，定位到其中的bin文件夹，我的路径是</p>
<blockquote>
<p>/Users/simba/Desktop/blog/blog/node_modules/hexo/node_modules/hexo-cli/bin</p>
</blockquote>
<p>然后在终端输入</p>
<blockquote>
<p>open .bash_profile</p>
</blockquote>
<p>在文件最后加入</p>
<blockquote>
<p>export PATH=$PATH:/Users/simba/Desktop/blog/blog/node_modules/hexo/node_modules/hexo-cli/bin</p>
</blockquote>
<p>保存后在终端输入</p>
<blockquote>
<p>source ~/.bash_profile</p>
</blockquote>
<p>重启终端后在博客所在文件夹内输入hexo</p>
<blockquote>
<p>Usage: hexo <command></p>
</blockquote>
<blockquote>
<p>Commands:</p>
</blockquote>
<blockquote>
<p>help     Get help on a command.  init     Create a new Hexo folder.  version  Display version information.</p>
</blockquote>
<blockquote>
<p>Global Options:</p>
</blockquote>
<blockquote>
<p>–config  Specify config file instead of using _config.yml  --cwd     Specify the CWD  --debug   Display all verbose messages in the terminal  --draft   Display draft posts  --safe    Disable all plugins and scripts  --silent  Hide output on console</p>
</blockquote>
<blockquote>
<p>For more help, you can use ‘hexo help [command]’ for the detailed information<br>
or you can check the docs: <a href="http://hexo.io/docs/">http://hexo.io/docs/</a></p>
</blockquote>
<p>成功运行hexo</p>
]]></content>
      <categories>
        <category>问题</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络面试重点</title>
    <url>/2021/04/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%87%8D%E7%82%B9/</url>
    <content><![CDATA[<h3 id="TCP三次握手-四次挥手-13"><a href="https://github.com/wolverinn/Waking-Up/blob/master/Computer%20Network.md">TCP三次握手/四次挥手 13</a></h3>
<p><strong>忽略握手过程中序列号和确认号的传输</strong>：发送的时候会随机生成一个序列号，另一段回复的时候需要回复确认号为收到的序列号加1，并且带上自己的序列号</p>
<p>初始序列号是用来给发送的数据包编号的，如果另一段发来了一个确认号，说明这个号之前的数据包都被接受了</p>
<p><strong>三次握手建立连接</strong></p>
<p><strong>第一次握手</strong>：客户端发送一个SYN为1的数据包给服务端</p>
<p><strong>第二次握手</strong>：发送一个SYN/ACK都为1的数据包给客户端</p>
<p><strong>第三次握手</strong>：客户端发送一个ACK为1的数据包给服务端</p>
<p><strong>可以两次握手吗？</strong></p>
<span id="more"></span>
<p>不可以，</p>
<p>首先，两次握手无法保证客户端正确接收到了第二次握手的报文，这样无法完成初始序列号的互换，双方无法确认自己发送的信息能被对方接收到。</p>
<p>其次，如果客户端之前发送过一次连接请求，但是阻塞在网络中，过一段时间后到达服务端了，服务端会以为是客户端又要建立一条连接。如果没有三次握手，server发送了确认报文就建立了连接，但客户端因为并没有发送请求，所以不会理会，这条连接并不会有数据传输；但是三次握手如果服务端发送后没有收到客户端的确认报文，就知道 client 没有要求建立连接，这条连接不会被建立。</p>
<p><strong>可以四次握手吗？</strong></p>
<p>可以，但没必要。四次握手就是把第二次握手的 ACK 和 SYN 分开发，这样降低传输效率</p>
<p><strong>如果客户端的ACK没有送达服务器？</strong></p>
<p>服务器会以为客户端没有收到第二次发送的报文，所以会重新发送报文（默认重发五次，之后连接关闭），客户端收到后会重新发送确认报文给服务端</p>
<p><strong>四次挥手释放连接</strong></p>
<p>看链接吧 [<a href="https://github.com/wolverinn/Waking-Up/blob/master/Computer%20Network.md">https://github.com/wolverinn/Waking-Up/blob/master/Computer Network.md</a>](<a href="https://github.com/wolverinn/Waking-Up/blob/master/Computer">https://github.com/wolverinn/Waking-Up/blob/master/Computer</a> <a href="http://Network.md">Network.md</a>)</p>
<p><strong>为什么要等待2MSL</strong></p>
<ul>
<li>让TCP两端发出的报文都在网络中消失，保证下一次TCP连接不会受这些残留报文干扰</li>
<li>防止ACK没有送达，2MSL是发出去的ACK报文存活时间加上服务端重发FIN的存活时间的和。如果在这个时间内都没有重新收到FIN，就当作ACK被成功接收</li>
</ul>
<hr>
<h3 id="HTTPS握手过程-12"><a href="https://juejin.im/post/6844904046063517704">HTTPS握手过程 12</a></h3>
<blockquote>
<p><strong>数字签名</strong>：对信息先用哈希算法计算得到一个摘要，再用密钥加密，放到要发送的信息后面，一起发给客户端。客户端收到后，先用公钥机密得到摘要，然后对信息使用哈希算法也计算一个摘要，比较两个摘要是否相同，如果相同就说明没有被篡改</p>
<p><strong>数字证书</strong>：<strong>为公钥做认证</strong>。用CA私钥进行加密的文件，其中包含了<strong>网站公钥、网站域名、证书颁发机构、有效期</strong>等信息</p>
</blockquote>
<p><strong>握手过程</strong></p>
<ol>
<li>客户端发送一个 client hello 消息向服务器发起握手请求，其中包含了客户端支持的TLS版本和密码组合，还有一个 client random 随机字符串</li>
<li>服务器发送 server hello 进行回应，其中包含了服务器选择的密码组合，数字证书和 server random 随机字符串，其中数字证书包含了<strong>加密公钥</strong>、网站域名、证书颁发机构、有效期等信息</li>
<li>客户端认证证书，包括证书是否过期，CA是否可靠，验证数字签名，其中的域名是否和网站真实域名相符</li>
<li>客户端向服务端发送发送另一个随机字符串 premaster secret，这个字符串使用服务器公钥进行加密</li>
<li>服务器用私钥解密得到 premaster secret</li>
<li>客户端和服务端使用 client random，server random，premaster key通过相同算法计算得到 key，用于后面的对称加密</li>
<li>客户端就绪，发送用密钥加密的 finished 信号</li>
<li>服务端就绪，发送用密钥加密的 finished 信号</li>
<li>握手完成，双方用对称加密进行通信</li>
</ol>
<hr>
<p><strong>认证证书</strong></p>
<p><strong>认证证书</strong></p>
<p>为防止<strong>中间人攻击</strong></p>
<ol>
<li>验证证书的颁发机构是否可靠，来源是否可靠</li>
<li>域名是否匹配，是否还在有效期</li>
<li>判断证书是否被篡改</li>
<li>判断证书是否被吊销</li>
</ol>
<hr>
<p><strong>中间人攻击</strong></p>
<ul>
<li>中间人拦截客户端的请求，返回自己的证书，让客户端以为自己在和正规网站通信，其中是在和中间人服务器通信</li>
<li>中间人获取客户端的通信信息，假装是客户端，与正规网站进行通信</li>
<li>中间人同时肩负两个身份，对于（真）客户端来说，它是（假）正规网站；对于（真）正规网站来说，它是（假）客户端。它同时与（真）客户端和（真）正规网站建立起两条不同的对称加密通道</li>
</ul>
<p><strong>主要原因是证书的伪造</strong>，所以需要CA来认证，让客户端浏览器能检测到伪造的证书</p>
<hr>
<p><strong>对称加密和非对称加密优缺点</strong></p>
<ul>
<li><strong>对称加密</strong>：加密解密采用同一份密钥</li>
<li><strong>非对称加密</strong>：需要两个密钥，一个公钥一个密钥，如果用公钥加密，只能用私钥解密</li>
<li><strong>区别</strong>：对称加密速度快，常用语大规模数据的加密；非对称加密更安全（没有传输私钥的风险）</li>
</ul>
<hr>
<h3 id="DNS解析-10">DNS解析 10</h3>
<p>过程 为什么用UDP</p>
<p>DNS 是作为因特网上 域名和IP地址互相映射的一个分布式数据库</p>
<p><strong>解析过程</strong></p>
<ul>
<li>输入一个域名，电脑发送DNS请求到本地域名服务器</li>
<li>本地域名服务器先查询缓存，如果有记录就直接返回</li>
<li>如果没有，就直接向根域名服务器发送查询请求，然后根域名服务器返回给本地域名服务器一个所查询域的主域名服务器地址</li>
<li>本地域名服务器再向上一步返回的域名服务器发送请求，然后对应的域名服务器查询自己的缓存，如果没有相关记录，就返回下一级的域名服务器地址</li>
<li>重复上一步，直到找到记录</li>
<li>本地域名服务器把返回的结果存入缓存，并将结果返回给主机</li>
</ul>
<p>主机向本地域名服务器查询一般都是 <strong>递归查询</strong></p>
<p>本地域名服务器向根域名服务器的查询是 <strong>迭代查询</strong></p>
<p><strong>为什么用UDP</strong></p>
<p>访问网站的响应时间也包括了 DNS解析时间 ，要尽可能减少解析花费的时间，也要减少对 DNS 服务器的压力</p>
<p>一次 UDP 名字服务器交换可以短到两个报：一个查询包、一个响应包</p>
<p>一次TCP交换则至少包含9个包：三次握手、四次挥手加上查询包和响应包</p>
<p>考虑到效率原因，TCP连接开销大，所以用UDP</p>
<hr>
<h3 id="HTTP-HTTPS区别-9">HTTP/HTTPS区别 9</h3>
<ul>
<li><strong>端口号</strong>：HTTP是80端口，HTTPS是443端口</li>
<li><strong>安全性</strong>：HTTP是明文传输，有中间人攻击、信息篡改、伪装等安全隐患，HTTPS建立在SSL之上，有加密和认证机制，更安全</li>
<li>HTTPS由于加密解密会带来额外开销；通信需要证书要向CA购买</li>
</ul>
<hr>
<h3 id="TCP-UDP区别-9">TCP/UDP区别 9</h3>
<ul>
<li>如果把UDP加上建立连接断开连接机制和报文序号，它是否就变成了TCP （还有差错检验、流量控制、阻塞控制）</li>
<li>TCP传输过程中丢包怎么办</li>
<li>TCP是面向连接的，UDP是无连接的（UDP发送前不需要建立连接）</li>
<li>TCP是可靠的，UDP不可靠（收到UDP报文后不需要给出任何确认）</li>
<li>TCP只支持点对点；UDP支持一对一、一对多、多对一、一对多</li>
<li>TCP是面向字节流的，发送数据时以字节为单位，一个数据包可以拆分成若干组发送；UDP是面向报文的，一个报文只能一次发完</li>
<li>TCP有拥塞控制，UDP没有，所以网络拥塞不会造成源主机发送率降低，对实时应用更友好</li>
<li>TCP 还有确认、窗口、重传等功能，UDP没有的，只是单纯地发送数据包</li>
<li>报文头部大小，TCP为20字节，UDP为8字节</li>
</ul>
<p>UDP一般用于即时通讯，语音，视频，直播等；TCP用于文件传输，邮件传输</p>
<hr>
<h3 id="输入URL到显示页面的过程-7">输入URL到显示页面的过程 7</h3>
<ol>
<li>浏览器查询DNS，获取域名对应的IP地址，具体过程包括
<ul>
<li>搜索浏览器自身DNS缓存、操作系统DNS缓存、读取本地Host文件、向本地DNS服务器进行查询</li>
<li>对于向本地DNS服务器进行查询，如果要查找的域名在本地可以被解析，就将解析结果返回，否则就发起递归查询或者迭代查询</li>
</ul>
</li>
<li>浏览器获得域名的IP地址后，向服务器请求建立连接，发起三次握手</li>
<li>TCP/IP链接建立起来以后，浏览器向服务器发送HTTP请求</li>
<li>服务器接收到HTTP请求，根据路径参数映射到特定的处理器进行处理，并将结果和视图返回给浏览器</li>
<li>浏览器解析并渲染视图，若遇到对 JS/CSS 等静态资源的应用，就重复上述步骤向浏览器请求资源</li>
<li>浏览器根据请求到的资源渲染页面，最终呈现一个完整的页面</li>
</ol>
<hr>
<h3 id="五层-七层模型-TCP-IP四层-7">五层/七层模型/ TCP/IP四层 7</h3>
<p>哪几层，每一层有哪些协议</p>
<p>对四层、五层的理解</p>
<p>主机A向服务器B传输数据包的完整过程，越详细越好</p>
<p><strong>OSI七层</strong>：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层</p>
<p><strong>五层结构</strong>：物理层、数据链路层、网络层、传输层、应用层（会话层、表示层、应用层）</p>
<p><strong>TCP/IP四层</strong>：网络接口层（物理层、数据链路层）、网际层（网络层）、传输层、应用层（会话层、表示层、应用层）</p>
<p><strong>应用层协议</strong></p>
<blockquote>
<p>定义了应用进程间的通信和交互规则</p>
<p>HTTP STMP 都有各自不同的通信规则，数据构成不一样</p>
<p>应用层交互的数据单元称为<strong>报文</strong></p>
</blockquote>
<ul>
<li>HTTP 80端口</li>
<li>FTP 20/21端口  20是数据连接，传输文件；21是控制连接，用来建立连接</li>
<li>SSH 22端口 远程连接</li>
<li>TELNET 23端口 远程连接</li>
<li>STMP 25端口 发送邮件</li>
<li>POP3 110端口 接收邮件</li>
<li>DNS 53端口 域名解析</li>
</ul>
<p><strong>传输层协议</strong></p>
<blockquote>
<p>负责向两台主机之间的通信提供通用的数据传输服务</p>
<p>不管应用层的通信规则如何，最终信息都要用一种方式传输，这种通用方式就是传输层的两个协议决定的</p>
<p>传输报文段</p>
</blockquote>
<ul>
<li>TCP</li>
<li>UDP</li>
</ul>
<p><strong>网络层协议</strong></p>
<blockquote>
<p>两个计算机之间可能会经过很多数据链路和通信子网，网络层就是要选择合适的网间路由和交换节点，把数据在子网之间传送，因为网络层使用IP，所以数据格式是 <strong>IP数据报</strong></p>
</blockquote>
<ul>
<li>IP</li>
<li>ARP</li>
<li>ICMP</li>
</ul>
<p><strong>数据链路层</strong></p>
<blockquote>
<p>两台主机之间数据的传输，是在一段一段的链路上传送的</p>
<p>将网络层下来的 IP数据报 封装成 <strong>帧</strong></p>
</blockquote>
<p><strong>物理层</strong></p>
<blockquote>
<p>物理层是实现相邻计算机节点之间比特流的透明传输，避免传输介质和物理设备的差异</p>
<p>传输的是比特流</p>
</blockquote>
<hr>
<p><strong>主机A向服务器B传输数据包的完整过程</strong></p>
<ul>
<li><strong>应用层</strong>：主机A向主机B发送一个HTTP请求报文</li>
<li><strong>传输层</strong>：HTTP使用的TCP协议，所以HTTP请求报文按序号被封为多个报文段，并对每个报文段进行封装。A主机使用本地一个大于1024的随机TCP源端口，建立到目的服务器80端口的连接，添加TCP源端口和目的端口到报文中</li>
<li><strong>网络层</strong>：到达网络层后，封装网络层头部，加上源IP地址和目的IP地址，封装成IP数据报，用户通常使用域名来访问服务器，这时候就需要DNS服务来查找IP地址</li>
<li><strong>数据链路层</strong>：到达数据链路层，封装帧的头部，加上源MAC地址和目的MAC地址。根据目的 IP 地址，如果在本地网络，并且 ARP 缓存中有到对应 MAC 地址的映射，就将目的 MAC 地址置为该地址，如果不是，就要找到对应的路由器转发到另一个子网。</li>
<li><strong>物理层</strong>：到达物理层，转成二进制的比特流，从PC1网卡发送出</li>
</ul>
<h2 id="more"><!-- more --></h2>
<h3 id="GET和POST区别-4"><a href="https://mp.weixin.qq.com/s?__biz=MzI3NzIzMzg3Mw==&amp;mid=100000054&amp;idx=1&amp;sn=71f6c214f3833d9ca20b9f7dcd9d33e4#rd">GET和POST区别 4</a></h3>
<p><strong>HTTP对两者的规定是</strong></p>
<ol>
<li>GET 主要用于获取资源；POST 用于提交数据，可能改变服务器资源</li>
<li>GET是幂等的，同样的请求发送一次和发送多次效果一样；POST不是幂等，多次发送同一条请求可能导致添加多条数据</li>
<li>GET的参数经常作为查询字符串出现在URL之后，只能是ASCII字符，长度受限制；POST请求的数据在请求体里，数据类型不受限制，长度不受限制</li>
<li>GET可以被缓存和保留在浏览器中；POST不可以</li>
</ol>
<p><strong>但是其实本质上没有区别，只是报文格式不同</strong>。他们是HTTP的两种请求方式，但是HTTP是基于TCP/IP的，所以是在同一个传输层协议下。</p>
<p>正因为它们有这样的区别，所以不应该且<strong>不能用 GET 请求做数据的增删改这些有副作用的操作</strong>。因为get请求是幂等的，<strong>在网络不好的隧道中会尝试重试</strong>。如果用get请求增数据，会有<strong>重复操作</strong>的风险，而这种重复操作可能会导致副作用</p>
<p>在使用 XMLHttpRequest 的 POST 方法时，浏览器可能会先发送 Header 再发送 Data 分两次传输</p>
<hr>
<h3 id="TCP如何实现可靠传输-4">TCP如何实现可靠传输 4</h3>
<ul>
<li><strong>校验和</strong>，如果收到的校验和有差错，说明数据在传输过程中有变化，就丢弃报文，不发送确认</li>
<li><strong>数据包按序接受</strong>，TCP报文有序列号，接收方会按序接收报文</li>
<li><strong>丢弃重复数据</strong></li>
<li><strong>应答机制</strong>，接收方接受了数据之后，会发送确认报文</li>
<li><strong>超时重传</strong>，如果已发送的报文在一定时间内没有收到确认，就重传这个报文</li>
<li><strong>流量控制</strong>，确保接收方能接受发送方发来的数据，不会溢出</li>
</ul>
<hr>
<h3 id="消息队列-4">消息队列 4</h3>
<p><strong>常见模式</strong></p>
<ul>
<li><strong>点对点</strong></li>
</ul>
<blockquote>
<p>生产者把消息发送到 queue，消费者从 queue 中取出信息进行消费。消息被消费之后就不再存储在 queue 中，也就是说一个消息只能被一个消费者消费</p>
</blockquote>
<p>支持此模式的是 RabbitMQ</p>
<ul>
<li><strong>发布/订阅</strong></li>
</ul>
<blockquote>
<p>生产者把消息发送到 topic 中，该消息会被所有订阅者消费</p>
</blockquote>
<p>支持此模式的 RabbitMQ、Kafka</p>
<blockquote>
<p>而非消息队列的<strong>观察者模式</strong>是同步的，发送消息之后，要同步等待接收者接收数据后才能进行之后的操作</p>
</blockquote>
<p><strong>使用消息队列的好处</strong></p>
<ul>
<li>
<p>异步处理</p>
<p>发送者把消息发送给消息队列后可以立即返回进行其他操作，消息接收者从队列中订阅消息后会异步处理</p>
</li>
<li>
<p>应用解耦</p>
<p>使用消息队列后，一个模块只要向消息队列发送信息，其他模块可以选择性从消息队列中订阅消息。这样就不需要模块与模块之间直接进行通信，模块与模块之间的耦合度就很低</p>
</li>
<li>
<p>流量削峰</p>
<p>碰到流量高峰时，超过系统处理能力的消息都会被积压在消息队列中，系统只要按照自己能力从消息队列中取消息，就能保证在短暂的高峰中不会崩溃。高峰过后，系统就会很快把消息队列中积压的消息消费掉</p>
</li>
</ul>
<p><strong>RabbitMQ 和 Kafka</strong></p>
<ul>
<li><strong>吞吐量</strong>：Kafka 吞吐量大于 RabbitMQ。Kafka 10万级，RabbitMQ 万级</li>
<li><strong>时效性</strong>：RabbitMQ 延迟比 Kafka 低。RabbitMQ 微秒级，Kafka 毫秒级</li>
</ul>
<p><strong>如何保证高可用</strong></p>
<p>RabbitMQ：镜像集群，queue 里的信息存在于所有 RabbitMQ 节点中，所以其中一个服务器宕机，消息也不会丢失</p>
<p>Kafka：由多个 broker 组成，一个 topic 被分为多个 partition，每个partition存在于多个 broker 中。并且每个 partition 在另一台机器的 broker 进程中有副本，所以有一个broker 宕机，可以用副本来代替</p>
<hr>
<h3 id="ARP协议-4">ARP协议 4</h3>
<p>因为主机之间通信需要经过数据链路层，IP数据报的源地址和目的地址始终不变，但是MAC地址随着链路的改变而改变。<strong>ARP实现由IP地址得到MAC地址</strong></p>
<p>每个主机都有一个ARP高速缓存，里面有本局域网各主机IP地址到MAC地址的映射表</p>
<p>如果主机 A 知道主机 B 的 IP 地址，但是高速缓存中没有该 IP 地址到 MAC 地址的映射，就在局域网中广播发送 ARP 请求，B 主机收到后会告知 A 他的 MAC 地址，然后 A 将 B的 IP 地址到 MAC 地址的映射加入到高速缓存中</p>
<p>如果目的主机和源主机不在同一个局域网，就要通过ARP找到位于该局域网上某个路由器的 MAC 地址，然后把分组转发给路由器，让路由器转发给下一个网络</p>
<p><strong>ARP欺骗</strong></p>
<p>类似于中间人攻击，当有 A 主机发送 ARP 广播请求 B 主机的 MAC 地址时，C 主动报上自己的 MAC 地址，让数据报先经过 C 再经过 B</p>
<hr>
<h3 id="HTTP常用状态码-3">HTTP常用状态码 3</h3>
<p><strong>常见的状态码</strong></p>
<ol>
<li>2xx状态码：200 OK 操作成功 / 206 Partial Content ：表示客户端进行了范围请求，响应报文包含由 Content-Range 指定范围的实体内容。</li>
<li>3xx状态码：301永久重定向 /302 暂时重定向 / 304 Not Modified ：如果请求报文首部包含一些条件，例如：If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since，如果满足条件，表示缓存资源是最新的，则服务器会返回 304 状态码。</li>
<li>4xx状态码：客户端错误 400 Bad Request / 401 Unauthorized / 403 Forbidden / 404 Not Found</li>
<li>5xx状态码：服务端错误 500 服务器内部错误 / 503 服务不可获取</li>
</ol>
<hr>
<h3 id="TCP阻塞控制-3">TCP阻塞控制 3</h3>
<p><strong>慢启动</strong></p>
<p>一开始先把拥塞窗口设为一个最大报文段的大小，每收到一个新的确认报文，就把窗口加1。每经过一个传输轮次，拥塞窗口大小就会加倍，1，2，4，8……</p>
<p><strong>拥塞避免</strong></p>
<p>当拥塞窗口大小达到慢开始门限，开始执行拥塞避免算法，拥塞窗口大小每轮传输只增加1</p>
<blockquote>
<p>无论慢启动还是拥塞避免阶段，如果网络出现拥塞，就要把慢开始门限设置为出现拥塞时发送窗口大小的一般，然后拥塞窗口重置为1，执行慢启动算法</p>
</blockquote>
<p><strong>快重传</strong></p>
<p>要求接收方在收到一个思绪报文段就立即发出重复确认。发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文，而不必等待重传计时器时间到期</p>
<p><strong>快恢复</strong></p>
<p>当发送方连续收到三个重复确认，就把慢启动门限设置为拥塞窗口的一半，并把拥塞窗口设置为慢启动门限（+3），然后开始拥塞避免算法。不执行慢启动是因为如果可以收到好几个重复确认，就认为当前网络没有出现阻塞</p>
<hr>
<h3 id="TCP-粘包"><a href="https://draveness.me/whys-the-design-tcp-message-frame/">TCP 粘包</a></h3>
<p>TCP 是面向字节流的，本身没有数据包的概念，不会按照数据包发送数据。为了提高带宽的利用率，TCP 协议可能会将多个应用层报文合并成一个 TCP 报文段进行传输，当接受方读取时会发现不相关的数据出现在同一个 TCP 报文段中。</p>
<p>为了实现 TCP 的拆分和重组，需要定义应用层消息的边界。可以统一应用层消息的大小，或者在应用层协议头中增加一个表示长度的字段。</p>
<hr>
<h3 id="HTTP请求-2">HTTP请求 2</h3>
<p>有哪些方法，头部报文格式</p>
<ul>
<li>GET 获取资源</li>
<li>HEAD 获取报文首部</li>
<li>POST 传输数据</li>
<li>DELETE 删除数据</li>
<li>PUT 用于修改资源 - 完全替代原始资源</li>
<li>PATCH 修改资源 - 允许部分修改</li>
</ul>
<p><strong>头部报文格式</strong></p>
<ul>
<li>方法名 URI路径 HTTP版本</li>
<li>Host名</li>
<li>首部信息
<ul>
<li>请求报文：Accept-language / Accept-encoding 等</li>
<li>响应报文：Content-type / Content-length 等信息</li>
</ul>
</li>
<li>PUT / POST 的传输主体信息</li>
</ul>
<hr>
<h3 id="端口号和服务-2">端口号和服务 2</h3>
<ul>
<li>HTTP 80端口</li>
<li>SSH 22端口 远程连接</li>
<li>TELNET 23端口 远程连接</li>
<li>STMP 25端口 发送邮件</li>
<li>POP3 110端口 接收邮件</li>
<li>DNS 53端口 域名解析</li>
</ul>
<hr>
<h3 id="HTTP-1-1-和-2-0-区别-2"><a href="https://www.cnblogs.com/aspirant/p/10833143.html">HTTP 1.1 和 2.0 区别 2</a></h3>
<p><strong>HTTP 2.0</strong></p>
<ul>
<li><strong>二进制分帧</strong>，将传输的报文分为 Headers 帧和 Data 帧，都是二进制格式的（之前都是文本传输）</li>
<li><strong>多路复用</strong>，并行请求。基于二进制分帧，所有消息都是从同一个TCP连接传输，一个 TCP 连接可以承载多个双向数据流，来自不同数据流的 HTTP 消息被分解为独立的帧，交错发送，接收端根据帧头的标识符将信息重新组装</li>
<li><strong>客户端推送</strong>，在客户端请求资源时，服务端会将相关资源一起发送给客户端，客户端就不需要再次发起请求了。例如请求一个网页，服务端会把一些静态资源一起发送</li>
<li><strong>首部压缩</strong>，要求客户端和服务端维护一个包含之前见过的首部字段的表，以后就只发送索引号，避免重复传输；此外还使用霍夫曼编码对首部字段进行压缩</li>
</ul>
<p><strong>HTTP 1.1</strong></p>
<ul>
<li>支持长连接，建立一次 TCP 可以进行多次 HTTP 通信。在一个TCP中可以不用等待前一个结果返回就发送下一个 HTTP 请求。但是响应还是按顺序返回的，需要等到第一个请求返回响应才会再返回第二个，会导致队头阻塞。</li>
<li>支持打开多个 TCP 连接。客户端可以通过多个 TCP 连接实现高并发</li>
<li>支持断点传输，分块传输</li>
<li>相比 1.0 增加更多请求头和响应头</li>
</ul>
<p><strong>HTTP 1.0</strong></p>
<ul>
<li>需要使用 keep-alive 参数告诉服务器建立 TCP 长连接，否则默认情况下连接无法复用，每次请求都要重新建立TCP连接</li>
</ul>
<hr>
<h3 id="HTTP缓存策略">HTTP缓存策略</h3>
<p>HTTP 1.1 通过 Cache-control 来控制缓存</p>
<ul>
<li>no-store 禁止缓存</li>
<li>no-cache 强制缓存服务器向源服务器确认缓存有效性</li>
</ul>
<p><strong>缓存过期</strong> 可以通过设置 max-age 和 Expired 实现</p>
<p><strong>缓存验证</strong> 可以使用 ETag 首部，用 If-None-Match 判断缓存资源和最新资源 ETag 是否一致；或者用 If-Modified-Since 来验证缓存是否有效</p>
<p><strong>其中 Expired，Last-Modified，If-Modified-Since 是 HTTP 1.0就有的</strong></p>
<p><strong>Cache-Control，ETag，If-None-Match 是1.1 新增</strong></p>
<hr>
<h3 id="cookie-session">cookie/session</h3>
<p><strong>Session 是服务端用来记录用户状态的机制</strong>，为特定的用户创建特定的 session，用于标示和跟踪这个用户</p>
<p><strong>Cookie 是客户端用来保持状态的机制</strong>，用来记录用户的一些信息，是保存在本地的一小段文本，随着每次请求发送到服务器。Cookie 中保存了 Session ID，通过这个Session ID，服务端就能识别用户。如果Cookie被禁用，会把sessionid参数附在URL中，服务端根据此来识别用户。Cookie 还可以用来保存用户登陆时的用户名等信息，或者用来分析用户行为。</p>
<p><strong>Session 共享</strong></p>
<ul>
<li>主从服务器进行 session 同步，用户在主服务器登陆后，将 session 信息传递到各从服务器</li>
<li>集群统一管理 session，应用把 session 信息放到集群，需要 session 时从集群服务器上读取
<ul>
<li>一种实现是用 memcached-session-manager，以 tomcat 插件的形式部署在服务器，直接在 memcached 中创建和更新 session</li>
</ul>
</li>
</ul>
<hr>
<h3 id="TCP出现大量CLOSE-WAIT原因">TCP出现大量CLOSE_WAIT原因</h3>
<hr>
<h3 id="DNS劫持原理">DNS劫持原理</h3>
<hr>
<h3 id="路由过程和算法">路由过程和算法</h3>
<p><strong>路由过程</strong></p>
<ul>
<li>从数据报首部提取出目的主机IP地址D，得到目的网络地址N</li>
<li>如果网络直接与路由器相连，直接交付</li>
<li>如果路由表中有到D的特定主机路由，就传送给指明的下一跳路由器</li>
<li>如果有到达N的路由，就传送给指明的下一跳路由器</li>
<li>如果有默认路由，就转发给默认路由器</li>
<li>报告转发出错</li>
</ul>
<p><strong>算法</strong></p>
<p>狄杰斯特拉最短路径</p>
<p>距离向量算法</p>
<p><strong>RIP</strong></p>
<ul>
<li>是应用层协议</li>
<li>是一种基于<strong>距离向量</strong>的路由选择协议，距离是指跳数，直接相连的路由器跳数为1，跳数超过15表示不可达</li>
<li>距离向量算法：
<ul>
<li>对地址为 X 的相邻路由器发来的 RIP 报文，先修改报文中的所有项目，把下一跳字段中的地址改为 X，并把所有的距离字段加 1；</li>
<li>对修改后的 RIP 报文中的每一个项目，进行以下步骤：</li>
<li>若原来的路由表中没有目的网络 N，则把该项目添加到路由表中；</li>
<li>否则：若下一跳路由器地址是 X，则把收到的项目替换原来路由表中的项目；否则：若收到的项目中的距离 d 小于路由表中的距离，则进行更新（例如原始路由表项为 Net2, 5, P，新表项为 Net2, 4, X，则更新）；否则什么也不做。</li>
<li>若 3 分钟还没有收到相邻路由器的更新路由表，则把该相邻路由器标为不可达，即把距离置为 16。</li>
</ul>
</li>
<li>按固定的时间间隔仅和相邻路由器交换自己的路由表，经过若干次交换之后，所有路由器最终会知道到达本自治系统中任何一个网络的最短距离和下一跳路由器地址。</li>
</ul>
<p><strong>OSPF</strong></p>
<ul>
<li>使用最短路径优先算法</li>
<li>向本自治系统的所有路由器发送信息，是泛洪法</li>
<li>发送的信息是与相邻路由器的链路状态，链路状态包括与哪些路由器相连以及链路的度量，度量用费用、距离、时延、带宽等来表示。</li>
<li>只有链路状态发生变化，才会发送信息</li>
</ul>
<hr>
<h3 id="其他">其他</h3>
<p><a href="https://blog.csdn.net/zaoxier/article/details/53792842">数据链路层有保证可靠性的操作吗？</a><br>
数据链路层的差错控制: 循环冗余校验CRC，只实现无比特差错传输，不提供可靠传输<br>
ps:无比特差错与无传输差错区别：无传输差错还包括帧丢失、帧重复、帧失序等。</p>
<p>要实现可靠传输，还需要有帧编号，确认机制和重传机制</p>
<p>（由于 IP 协议 中使用了 ARP 协议，因此通常将 ARP 协议归为网络层协议。<br>
但 ARP 协议的用途是从网络层使用的 IP地址 中解析出在数据链路层使用的硬件地。其消息由数据链路层协议封装，它是在同一局域网内部通信的，从不跨网络节点路由。因此，也可以认为 ARP 协议是数据链路层协议。）</p>
<hr>
<h3 id="安全相关">安全相关</h3>
<p><strong>XSS</strong></p>
<p>在提交数据的位置加入代码，将代码嵌入到页面当中，从而盗取一些信息</p>
<p><strong>防御</strong></p>
<ul>
<li>对重要的 cookie 设置 httpOnly，防止客户端通过 document.cookie 读取 cookie</li>
<li>对输入内容的特定字符进行转码</li>
</ul>
<hr>
<p><strong>CSRF</strong></p>
<p>用户在正常登陆 A 网站且没有退出的情况下，打开了 B 恶意网站，该网站悄悄让用户去访问 A 网站的某个接口，在用户不知情的情况下，带着合法的登陆状态访问了某个接口，并完成操作。</p>
<p><strong>防御</strong></p>
<ul>
<li>双重 Cookie 验证，因为恶意网站无法获取 cookie 信息，将 cookie 中的参数取出来加入到请求参数中，服务端进行校验</li>
</ul>
<hr>
<p><strong>SQL 注入</strong></p>
<p>把 SQL 命令插入到 表单窗口 或者 URL 的查询字符串中，欺骗服务器执行恶意的 SQL 语句</p>
<p><strong>防御</strong></p>
<ul>
<li>对客户端数据的数据进行检查</li>
</ul>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>读《盲人钟表匠》的两点感悟</title>
    <url>/2018/12/09/%E8%AF%BB%E3%80%8A%E7%9B%B2%E4%BA%BA%E9%92%9F%E8%A1%A8%E5%8C%A0%E3%80%8B%E7%9A%84%E4%B8%A4%E7%82%B9%E6%84%9F%E6%82%9F/</url>
    <content><![CDATA[<blockquote>
<ul>
<li><strong>自然界中所有精密复杂的生物，其祖先都可以追溯到原始单细胞生物。</strong></li>
</ul>
</blockquote>
<span id="more"></span>
<p>「<strong>人类是由单细胞生物进化而来</strong>」这个事实是任何人都难以想象的。不过，只要把整个进化的过程想作是<em>step-by-step</em>，每次进化都是相比前一代有一点小改变，这个问题就很好解释了。有时候拿到一个问题，我们很容易被它宽宏的问题描述吓到，但是静下心来，将问题拆分成一个个自己能够理解的小部分后，就发现其实也就那么回事。</p>
<p>微积分的思想不光在进化论上，在多数领域的问题上也都适用。但我遇到问题后，总是不愿意一步步退回到我的知识层面去分解问题，而是想像自己一开始就站在一个攀登不起的高度，在周围找砖找瓦，踮着脚往上爬。但这种行为就好像是踩着想象出来的空梯子往上爬，看似离目标越来越近，可随着见到结果后幻想的破灭，当初一砖一瓦垒起来的垫脚石便随着梯子的消失一同掉回地面了。结果就是，认清事实后的自己在跌回的高度慢慢造梯子往上爬，尽管是一个费时的过程，但到最后自己总是能把问题解决。</p>
<p>芒格说「<strong>我的剑是留给能够挥舞他的人</strong>」。只要吃过两次亏，有了后见之明，就不会再去试着碰那些自己挥不起来的剑了。可是在学会控制让自己不浮躁之前，我还是很难做到不重蹈覆辙。「耐心」是现在的我最迫切需要的东西。</p>
<blockquote>
<ul>
<li><strong>有巨大差异的两类物种也可能进化出极为相似的器官，因为这种器官确实是精妙且有用，<em>眼睛</em> 就是一个极好的例子。</strong></li>
</ul>
</blockquote>
<p>同类生物有它们共有的特征，异类生物也能找到共同的特点。能在残酷的自然中存活至今的生物就已是大自然的杰作，这些杰作所共有的特质更是大自然最伟大的作品。</p>
<p>与此类似的，从那些有伟大成就的人身上，我们也能找出许多共通的品质。发现并学习这些品质不一定代表我们也能成为伟人，因为还要考虑天分和时代，但可以让我们避免成为平凡的人。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title>面试常考设计模式</title>
    <url>/2021/04/24/%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%80%83%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="单例模式-4">单例模式 4</h3>
<p><strong>懒汉</strong>(线程不安全)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getUniqueInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">      uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>如果有多个线程能进入 if(uniqueInstance == null) 并且此时 uniqueInstance 为空，就会实例化多个Single</p>
<p><strong>双重校验</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton uniqueInstance;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">synchronized</span>(Singleton.class) &#123;</span><br><span class="line">        <span class="keyword">if</span>(uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">          uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之所以要进行两次 if 判断，是因为如果两个线程同时执行 if 语句，两个线程都会进入 sychronized 语句块，等到第一个线程完成实例化之后第二个线程也会进入。为了避免第二次实例化，第二个线程如果判断得到uniqueInstance不为空，就不会进行实例化了，保证了只有一个实例</p>
<p>volatile 可以禁止指令重排，因为 uniqueInstance = new Singleton(); 这段代码实际是分3步执行的：</p>
<ol>
<li>为 uniqueInstance 分配内存空间</li>
<li>初始化uniqueInstance</li>
<li>将uniqueInstance指向被分配的内存地址</li>
</ol>
<p>由于JVM的执行重排特性，这段代码可能是按照1-3-2的顺序执行的，如果T1线程执行了1和3，T2线程调用getInstance发现不为空，就返回了 uniqueInstance ，但此时uniqueInstance还未被初始化</p>
<h3 id="工厂模式-2">工厂模式 2</h3>
<h3 id="观察者模式-1">观察者模式 1</h3>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
</search>
